---
title: "Ultraviolet light affects the color vocabulary: evidence from 728 languages"
subtitle: "Full analyses and plots"
author: "Dan Dediu (with special thanks to Mathilde Josserand)"
date: "`r date()`"
output:
  html_document: 
    highlight: textmate
    toc: yes
    toc_depth: 6
    toc_float: yes
    theme: cerulean
    number_sections: yes
  word_document: default
  pdf_document:
    toc: yes
    toc_depth: '6'
editor_options:
  chunk_output_type: console
bibliography: bibliography.bib
csl: apa-6th-edition.csl
---

<style>
caption, .caption {
color: #555555;
font-weight: bold;
font-size: 105%;
text-align: left}

a[hreflang]:before{}
</style>

```{r license, include=FALSE, eval=FALSE}
    Code and data accompanying the paper "Ultraviolet light affects the 
    color vocabulary: evidence from 728 languages".
    Copyright (C) 2019-2023 Dan Dediu

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
```


# Introduction

This `HTML` document (possibly, printed to `PDF`) resulted from compiling the corresponding `Rmarkdown` script and contains all the results and plots supporting the paper.
All the data and scripts needed to reproduce this document are available in the *GitHub* repository [https://github.com/ddediu/colors-UV-update](https://github.com/ddediu/colors-UV-update).

## Typographic conventions

This `HTML` document uses the following font and color conventions:

- *regular text* is rendered as "regular text";
- *emphasis* is represented using *italic text*, **bold text** or, in rare circumstances, ***bold+italic text***;
- *software* or programming concepts (e.g., applications, packages or function names) are represented using `fixed font text`;
- *section heads* use specific font sizes and are numbered;
- *hyperlinks* to sections of this document and to external resources on the web are represented as [link to the Introduction](#introduction) or [link to R project's website](https://www.r-project.org/), and can be clicked to navigate there;
- *notes* are represented as numbered superscripts[^example_note] which can be clicked to go to the note's text;
- *captions* use **bold font**, are numbered, and are placed below the corresponding figure and above the corresponding table;
- *raw output*, as produced by various `R` functions and expressions (for example, as in the [Appendices](#appendices)), is shown using `fixed font text` in clearly marked boxes;
- the *floating document outline* on the left shows the main sections and the path to the current location and is clickable for quick navigation.

Please note that these font and color conventions can be changed in the `Rmarkdown` script (for example, selecting a different theme in `RStudio`); here, we used *cerulean* and *textmate*.

[^example_note]: This is an example note. Click the symbol at the end of the note to go back to where the note is called in the text.

## Software and hardware info

The full information about the version of `R` [@R2021], the packages and the hardware and software platform used to obtain this document are given in the Section [*Session information*](#session-information) at the end of this document[^technical_note].
The figures were made using various `R` packages; in particular, the maps were drawn using the `maps` package (wrapped by the `map_data()` function in `ggplot2`), which, in turn uses public domain data from the [Natural Earth project](https://www.naturalearthdata.com/).

[^technical_note]: Please note that some of the models used here are computationally expensive, and even compiling this `Rmarkdown` script might require a relatively powerful machine. To help with this, and to ensure full replicability of our results, we have cached some of these expensive sections in the `cached_results` folder as `XZ`-compressed `RData` files. However, it might happen that versions of some of the packages different from those that we used here might not be fully compatible with the saved `RData` files, resulting in errors compiling this `Rmarkdown` script or errors displaying/plotting the results. In this case, we recommend using the exact same versions of `R` and of the packages that we used (listed in the [*Session information*](#session-information)), or, if not possible, the deletion of the offending `RData` files and the full recompilation of the `Rmarkdown` script (which is smart enough to re-generate only those missing cached results).


```{r setup, echo=F, message=F, warning=FALSE}
## Knitting options:
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE,                   # default code chunk options
                      fig.width=11, fig.height=6, fig.align="center", comment=NA, # default figure dimensions
                      fig.path="./figures/",                                      # save images to ./figures/
                      dpi=70, dev="jpeg",                                         # please set dpi=300 and comment out dev="jpeg" for high resolution but very big images
                      cache=TRUE, autodep=TRUE);                                  # cache chunks


## Load needed packages:

# Rmarkdown:
library(knitr);
library(pander);

# System/parallel processing:
library(parallel);
library(future);
library(pbapply); # lapply with progress bar

# Data processing:
library(plyr);
library(dplyr);
library(reshape2);

# Plotting:
library(ggplot2);
library(ggrepel); # reduce clutter with text
library(gridExtra); # combine multiple plots
library(ggnewscale); # multiple color scales in the same plot
library(cowplot); # subplots for ggplot2
library(DiagrammeR); # box and arrow diagramns
library(grid); # assemble multiple plots
library(sjPlot); # effect plots
library(glmmTMB); # effect plots

# Spatial stats and maps:
library(maptools); # as.im.RasterLayer()
#library(spatstat); # ppp()
#library(scanstatistics); # dist_to_knn() # currently it needs to be manually installed from the CRAN archive https://cran.r-project.org/src/contrib/Archive/scanstatistics/ and needs also https://cran.r-project.org/src/contrib/Archive/reliaR/; to make things easier, these are saved in the ./_needed_packages_archived_on_CRAN folder as well
#library(ape); # Moran.I()
#library(spdep); # tri2nb()
#library(deldir); # deldir()
#library(igraph); # graph()
#library(Imap); # gdist() # currently it needs to be manually installed from the CRAN archive https://cran.r-project.org/src/contrib/Archive/Imap/
library(geosphere); # geographic distances
library(maps)

# Regression and mediation analysis:
library(lmerTest); # ML mixed-effects models
library(brms); # Bayesian mixed-effects models with Stan
library(bayestestR); # Bayesian model comparison
library(sjstats); # mediation
library(performance); # multicollinearity
library(ggeffects); # regression prediction and effect

# DAGs:
#library(dagitty); # interferes with others, so load it where needed

# Path analysis/SEM:
library(lavaan); # fit models
library(lavaanPlot); # plot models
library(semPlot);

# Decison trees, random forests, and SVMs:
library(caret); # confusionMatrix()
library(partykit); # ctree() and cforest()
library(randomForest); # randomForest()
library(rsample); # initial_split()
library(rminer); # SVMs


## Set seed for reproducibility:
set.seed(42);

## For Bayesian regressions with brms (some might be different for particular models to avoid too few or too many iterations):
brms_ncores  <- max(detectCores(all.tests=TRUE, logical=FALSE), 4, na.rm=TRUE); # try to use multiple cores, if present
brms_iter    <- 5000; brms_warmup <- 2000; brms_thin <- 2; # burn-in and iterations 
brms_control <- list(adapt_delta=0.999, max_treedepth=15); # control params to pass to Stan: avoid the "divergent transitions after warmup" and "max_treedepth" warnings
brms_ci      <- 0.89; brms_rope <- c(-0.01, 0.01); # 89% HDI and a tight ROPE around 0.0 [-0.01, 0.01]
#plan(multiprocess); # parallel kfold using futures

# Use different params for the Bayesian models for development/debugging (TRUE) and for the actual runs (FALSE):
if( FALSE )
{
  # Development & testing:
  # regressions:
  reg_iter=4000; reg_warmup=2000; reg_thin=2; reg_control=list(adapt_delta=0.99, max_treedepth=10);
  # mediation:
  med_iter=8000; med_warmup=2000; med_thin=2; med_control=list(adapt_delta=0.99, max_treedepth=15);
} else
{
  # Actual runs:
  # regressions:
  reg_iter=6000;  reg_warmup=2000; reg_thin=2; reg_control=list(adapt_delta=0.9999,  max_treedepth=15);
  # mediation:
  med_iter=90000; med_warmup=3000; med_thin=3; med_control=list(adapt_delta=0.99999, max_treedepth=15);
}

## Various folders:
if( !dir.exists("./figures") ) dir.create("./figures", showWarnings=FALSE); # figures are saved here
if( !dir.exists("./cached_results") ) dir.create("./cached_results", showWarnings=FALSE); # cache expensive results here


## Auxiliary functions:

# Figure and Table caption adapted from https://stackoverflow.com/questions/37116632/rmarkdown-html-number-figures: 
outputFormat = opts_knit$get("rmarkdown.pandoc.to"); # determine the output format of the document
if( is.null(outputFormat) ) outputFormat = ""; # probably not run within knittr
capTabNo = 1; capFigNo = 1; # figure and table caption numbering, for HTML do it manually
#Function to add the Table Number
capTab = function(x)
{
  if(outputFormat == 'html'){
    x = paste0("**Table ",capTabNo,".** ",x,"")
    capTabNo <<- capTabNo + 1
  }; x
}
#Function to add the Figure Number
capFig = function(x, show_R_version=TRUE, show_package_versions=NULL, is_map=FALSE)
{
  if(outputFormat == 'html')
  {
    x <- paste0("**Figure ",capFigNo,".** ",x,"");
    if( show_R_version || (!is.null(show_package_versions) && length(show_package_versions) > 0) )
    {
      x <- paste0(x, " Figure generated using ");
      if( show_R_version ) x <- paste0(x, stringr::str_replace(R.version.string, stringr::fixed("R "), "[`R`](https://www.r-project.org/) "));
      if( !is.null(show_package_versions) && length(show_package_versions) > 0 )
      {
        x <- paste0(x, ifelse( show_R_version, " and ", " "));
        x <- paste0(x, ifelse( length(show_package_versions) > 1, "packages ", "package "));
        x <- paste0(x, paste0(vapply(show_package_versions, function(x) paste0("`",x,"`", " (version ", packageVersion(x),")"), character(1)), collapse=", "), ".");
      }
      if( is_map ) x <- paste0(x, " Maps are using public domain data from the [Natural Earth project](https://www.naturalearthdata.com/) as provided by the `R` package `maps`.");
    }
    capFigNo <<- capFigNo + 1;
  }; 
  x;
}

# Verbal interpretation of Bayes factors (BF):
BF_interpretation <- function(BF, model1_name="m1", model2_name="m2")
{
  if( BF > 100 )   return (paste0("extreme evidence for ",model1_name," against ",model2_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 30 )    return (paste0("very strong evidence for ",model1_name," against ",model2_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 10 )    return (paste0("strong evidence for ",model1_name," against ",model2_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 3 )     return (paste0("moderate evidence for ",model1_name," against ",model2_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 1 )     return (paste0("anecdotal evidence for ",model1_name," against ",model2_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF == 1 )    return (paste0("no evidence for ",model1_name," nor ",model2_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 0.33 )  return (paste0("anecdotal evidence for ",model2_name," against ",model1_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 0.10 )  return (paste0("moderate evidence for ",model2_name," against ",model1_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 0.033 ) return (paste0("strong evidence for ",model2_name," against ",model1_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 0.010 ) return (paste0("very strong evidence for ",model2_name," against ",model1_name, " (BF=",sprintf("%.3g",BF),")"));
  return (paste0("extreme evidence for ",model2_name," against ",model1_name, " (BF=",sprintf("%.3g",BF),")"));
}

# Here I hack brms' kfold code to make it run in parallel using good old mclapply instead of futures
# this avoid random crashes which seem to be due to future, but works only on *NIX (which, for me here, is not an issue)
# Adapted the code from https://github.com/paul-buerkner/brms/blob/master/R/loo.R and https://github.com/paul-buerkner/brms/blob/master/R/kfold.R
if( Sys.info()['sysname'] == "Windows" )
{
  # In Windows, fall back to the stadard implementation in brms:
  add_criterion_kfold_parallel <- function(model, K=10, chains=1)
  {
    return (add_criterion(model, criterion="kfold", K=K, chains=chains));
  }
} else
{
  # On anything else, try to use maclapply:
  add_criterion_kfold_parallel <- function(model, K=10, chains=1)
  {
    model <- restructure(model);
  
    mf <- model.frame(model); 
    attributes(mf)[c("terms", "brmsframe")] <- NULL;
    N <- nrow(mf);
    
    if( K > N ) return (model); # does not work in this case...
    
    fold_type <- "random"; folds <- loo::kfold_split_random(K, N);
    Ksub <- seq_len(K);
  
    kfold_results <- mclapply(Ksub, function(k) 
    {
      omitted <- predicted <- which(folds == k);
      mf_omitted <- mf[-omitted, , drop=FALSE];
      
      if( exists("subset_data2", envir=asNamespace("brms")) )
      {
        # Newer versions of brms:
        model_updated <- base::suppressWarnings(update(model, newdata=mf_omitted, data2=brms:::subset_data2(model$data2, -omitted), refresh=0, chains=chains));
        
        lppds <- log_lik(model_updated, newdata=mf[predicted, , drop=FALSE], newdata2=brms:::subset_data2(model$data2, predicted), 
                         allow_new_levels=TRUE, resp=NULL, combine=TRUE, chains=chains);
      } else if( exists("subset_autocor", envir=asNamespace("brms")) )
      {
        # Older versions of brms:
        model2 <- brms:::subset_autocor(model, -omitted, incl_car=TRUE);
        model_updated <- base::suppressWarnings(update(model2, newdata=mf_omitted, refresh=0, chains=chains));
        
        lppds <- log_lik(model_updated, newdata=mf[predicted, , drop=FALSE], allow_new_levels=TRUE, resp=NULL, combine=TRUE, chains=chains);
      } else
      {
        stop("Unknown version of brms!");
      }
  
      return (list("obs_order"=predicted, "lppds"=lppds));
    }, mc.cores=ifelse(exists("brms_ncores"), brms_ncores, detectCores()));
    
    # Put them back in the form expected by the the following unmodifed code:
    obs_order <- lapply(kfold_results, function(x) x$obs_order);
    lppds     <- lapply(kfold_results, function(x) x$lppds);
    
    elpds <- brms:::ulapply(lppds, function(x) apply(x, 2, brms:::log_mean_exp))
    # make sure elpds are put back in the right order
    elpds <- elpds[order(unlist(obs_order))]
    elpd_kfold <- sum(elpds)
    se_elpd_kfold <- sqrt(length(elpds) * var(elpds))
    rnames <- c("elpd_kfold", "p_kfold", "kfoldic")
    cnames <- c("Estimate", "SE")
    estimates <- matrix(nrow = 3, ncol = 2, dimnames = list(rnames, cnames))
    estimates[1, ] <- c(elpd_kfold, se_elpd_kfold)
    estimates[3, ] <- c(-2 * elpd_kfold, 2 * se_elpd_kfold)
    out <- brms:::nlist(estimates, pointwise = cbind(elpd_kfold = elpds))
    atts <- brms:::nlist(K, Ksub, NULL, folds, fold_type)
    attributes(out)[names(atts)] <- atts
    out <- structure(out, class = c("kfold", "loo"))
    
    attr(out, "yhash") <- brms:::hash_response(model, newdata=NULL, resp=NULL);
    attr(out, "model_name") <- "";
    
    model$criteria$kfold <- out;
    model;
  }
}

# Bayesian fit indices for a given model:
brms_fit_indices <- function(model, indices=c("bayes_R2", "loo", "waic", "kfold"), K=10, verbose=TRUE, do.parallel=TRUE)
{
  if( "bayes_R2" %in% indices )
  {
    if( verbose) cat("R^2...\n");
    #attr(model, "R2") <- bayes_R2(model); 
    model <- add_criterion(model, "bayes_R2"); 
  } else
  {
    # Remove the criterion (if already there):
    if( !is.null(model$criteria) && "bayes_R2" %in% names(model$criteria) ) model$criteria[[ which(names(model$criteria) == "bayes_R2") ]] <- NULL;
  }
  
  if( "loo" %in% indices )
  {
    if( verbose) cat("LOO...\n");
    model <- add_criterion(model, "loo"); 
  } else
  {
    # Remove the criterion (if already there):
    if( !is.null(model$criteria) && "loo" %in% names(model$criteria) ) model$criteria[[ which(names(model$criteria) == "loo") ]] <- NULL;
  }
  
  if( "waic" %in% indices )
  {
    if( verbose) cat("WAIC...\n");
    model <- add_criterion(model, "waic"); 
  } else
  {
    # Remove the criterion (if already there):
    if( !is.null(model$criteria) && "waic" %in% names(model$criteria) ) model$criteria[[ which(names(model$criteria) == "waic") ]] <- NULL;
  }
  
  if( "kfold" %in% indices )
  {
    if( verbose) cat(paste0("KFOLD (K=",K,")...\n"));
    model1 <- NULL;
    if( !do.parallel )
    {
      try(model1 <- add_criterion(model, "kfold", K=K, chains=1), silent=TRUE);
    } else
    {
      try(model1 <- add_criterion_kfold_parallel(model, K=K, chains=1), silent=TRUE);
    }
    if( !is.null(model1) )
    {
      model <- model1;
    } else
    {
      # Remove the criterion (if already there):
      if( !is.null(model$criteria) && "kfold" %in% names(model$criteria) ) model$criteria[[ which(names(model$criteria) == "kfold") ]] <- NULL;
    }
  } else
  {
    # Remove the criterion (if already there):
    if( !is.null(model$criteria) && "kfold" %in% names(model$criteria) ) model$criteria[[ which(names(model$criteria) == "kfold") ]] <- NULL;
  }

  gc();
  
  return (model);
}

# Bayesian model comparison:
#model1 <- b_uvbm__blue
#model2 <- b_popsize__blue
brms_compare_models <- function(model1, model2, name1=NA, name2=NA, bayes_factor=TRUE, print_results=TRUE)
{
  if( !is.null(model1$criteria) && "bayes_R2" %in% names(model1$criteria) && !is.null(model1$criteria$bayes_R2) &&
      !is.null(model2$criteria) && "bayes_R2" %in% names(model2$criteria) && !is.null(model2$criteria$bayes_R2) )
  {
    R2_1_2 <- (mean(model1$criteria$bayes_R2) - mean(model2$criteria$bayes_R2));
  } else
  {
    R2_1_2 <- NA;
  }
  
  if( bayes_factor )
  {
    invisible(capture.output(bf_1_2 <- brms::bayes_factor(model1, model2)$bf));
    bf_interpret_1_2 <- BF_interpretation(bf_1_2, ifelse(!is.na(name1), name1, "model1"), ifelse(!is.na(name2), name2, "model2")); 
  }
  else
  {
    bf_1_2 <- NULL; bf_interpret_1_2 <- NA;
  }
  
  if( !is.null(model1$criteria) && "loo" %in% names(model1$criteria) && !is.null(model1$criteria$loo) &&
      !is.null(model2$criteria) && "loo" %in% names(model2$criteria) && !is.null(model2$criteria$loo) )
  {
    loo_1_2 <- loo_compare(model1, model2, criterion="loo", model_names=c(ifelse(!is.na(name1), name1, "model1"), ifelse(!is.na(name2), name2, "model2")));
  } else
  {
    loo_1_2 <- NA;
  }
  
  if( !is.null(model1$criteria) && "waic" %in% names(model1$criteria) && !is.null(model1$criteria$waic) &&
      !is.null(model2$criteria) && "waic" %in% names(model2$criteria) && !is.null(model2$criteria$waic) )
  {
    waic_1_2 <- loo_compare(model1, model2, criterion="waic", model_names=c(ifelse(!is.na(name1), name1, "model1"), ifelse(!is.na(name2), name2, "model2")));
    mw_1_2 <- model_weights(model1, model2, weights="waic", model_names=c(ifelse(!is.na(name1), name1, "model1"), ifelse(!is.na(name2), name2, "model2")));
  } else
  {
    waic_1_2 <- NA; 
    mw_1_2 <- NA;
  }
  
  if( !is.null(model1$criteria) && "kfold" %in% names(model1$criteria) && !is.null(model1$criteria$kfold) &&
      !is.null(model2$criteria) && "kfold" %in% names(model2$criteria) && !is.null(model2$criteria$kfold) )
  {
    kfold_1_2 <- loo_compare(model1, model2, criterion="kfold", model_names=c(ifelse(!is.na(name1), name1, "model1"), ifelse(!is.na(name2), name2, "model2")));
  } else
  {
    kfold_1_2 <- NA;
  }
  
  if( print_results )
  {
    cat(paste0("\nComparing models '",ifelse(!is.na(name1), name1, "model1"),"' and '",ifelse(!is.na(name2), name2, "model2"),"':\n\n"));
    cat(paste0("\ndelta R^2 = ",sprintf("%.1f%%",100*R2_1_2),"\n\n"));
    cat(bf_interpret_1_2,"\n\n");
    cat("\nLOO:\n"); print(loo_1_2);
    cat("\nWAIC:\n"); print(waic_1_2);
    cat("\nKFOLD:\n"); print(kfold_1_2);
    cat("\nModel weights (WAIC):\n"); print(mw_1_2);
    cat("\n");
  }
  
  gc();
  
  return (list("R2"=R2_1_2, "BF"=bf_1_2, "BF_interpretation"=bf_interpret_1_2, "LOO"=loo_1_2, "WAIC"=waic_1_2, "KFOLD"=kfold_1_2, "model_weights_WAIC"=mw_1_2));
}

# Standard error of the mean:
std <- function(x) sd(x)/sqrt(length(x))

# Root Mean Square Error (RMSE) between observed (y) and predicted (yrep) values:
rmse <- function(y, yrep)
{
  yrep_mean <- colMeans(yrep)
  sqrt(mean((yrep_mean - y)^2))
}

# Panel function for the pairwise plots:
panel.cor <- function(x, y){
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- cor.test(x, y, method="pearson");
  rho <- cor.test(x, y, method="spearman");
  txt <- sprintf("r=%.2f\n(p=%.4g)\nrho=%.2f\n(p=%.4g)", 
                 r$estimate, r$p.value, rho$estimate, rho$p.value)
  cex.cor <- 0.8/strwidth(txt)
  text(0.5, 0.5, txt, cex=1.2)
}
upper.panel<-function(x, y){
  points(x,y, pch = 21, bg="lightgray", col="gray30")
  abline(lm(y ~ x), col="blue", lwd=2);
}
panel.hist <- function(x, ...)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(usr[1:2], 0, 1.5) )
  h <- hist(x, plot = FALSE)
  breaks <- h$breaks; nB <- length(breaks)
  y <- h$counts; y <- y/max(y)
  rect(breaks[-nB], 0, breaks[-1], y, col = "lightgray", ...)
}


## Draw diagrams:

# Draw an edge depending on its regression estimate
.gr_edge <- function(model, iv, precision=2, col_neg="blue", lty_neg="solid", col_pos="red", lty_pos="solid", col_null="gray", lty_null="dashed")
{
  if( is.null(model) )
  {
    paste0('[label = "ns", style = "',lty_null,'", color = "',col_null,'"]');
  } else
  {
    v <- fixef(model)[iv, "Estimate"];
    if( is.null(v) )
    {
      paste0('[label = "ns", style = "',lty_null,'", color = "',col_null,'"]');
    } else
    {
      paste0('[label = "',round(v, precision),'", style = "',ifelse(v<0,lty_neg,lty_pos),'", color = "',ifelse(v<0,col_neg,col_pos),'"]');
    }
  }
}


# Generalise the code in sjstats:::mediation.brmsfit() for more than one mediator:
.mediation_multiple_mediators_brms <- function(model, response, treatment, mediators, prob=0.95, typical="median", rope.range="default")
{
  # Get the DVs, the treatment and the mediation models:
  dv <- insight::find_response(model, combine = TRUE);
  treatment <- bayestestR:::.fix_factor_name(model, treatment);
  mediator.models <- which(dv %in% mediators); treatment.model <- which(!(dv %in% mediators));
  mediators <- vapply(mediators, function(x) bayestestR:::.fix_factor_name(model, x), character(1));
  dv <- names(dv);
  
  # Get the coefficient for the treatment and the direct effect:
  coef_treatment <- sprintf("b_%s_%s", dv[treatment.model], treatment);
  eff.direct <- model %>% brms::as_draws_matrix(variable=coef_treatment) %>% as.data.frame() %>% dplyr::pull(1);
  eff.direct_HDI <- bayestestR::hdi(eff.direct, ci=prob);
  
  # Get the coefficients for the mediators and their effects:
  coef_mediators <- sprintf("b_%s_%s", dv[treatment.model], mediators);
  eff.mediators <- lapply(coef_mediators, function(x) model %>% brms::as_draws_matrix(variable=x) %>% as.data.frame() %>% dplyr::pull(1)); names(eff.mediators) <- coef_mediators;
  
  # Get the coefficients for the indirect effects and their estimates:
  coef_indirects <- sprintf("b_%s_%s", dv[mediator.models], treatment);
  tmp.indirects <- lapply(seq_along(coef_indirects), function(i) cbind(as.data.frame(brms::as_draws_matrix(model, variable=coef_indirects[i])), as.data.frame(brms::as_draws_matrix(model, variable=coef_mediators[i])))); names(tmp.indirects) <- coef_indirects;
  eff.indirects <- do.call(cbind, lapply(tmp.indirects, function(x) x[,1] * x[,2]));
  eff.indirects_HDI <- do.call(rbind, lapply(1:ncol(eff.indirects), function(i) bayestestR::hdi(eff.indirects[,i], ci=prob)));
  
  # Get the total effect:
  eff.total <- rowSums(eff.indirects) + eff.direct;
  eff.total_HDI <- bayestestR::hdi(eff.total, ci=prob);
  
  # The proportion mediated:
  prop.mediated <- apply(eff.indirects, 2, function(x) sjmisc::typical_value(x, fun=typical)) / sjmisc::typical_value(eff.total, fun=typical);
  
  # The HDI and standard errors:
  hdi_eff <- lapply(1:ncol(eff.indirects), function(i) bayestestR::hdi(eff.indirects[,i] / eff.total, ci=prob)); names(hdi_eff) <- colnames(eff.indirects);
  prop.se <- vapply(hdi_eff, function(x) (x$CI_high - x$CI_low)/2, numeric(1));
  prop.hdi <- do.call(rbind, lapply(1:length(prop.se), function(i) prop.mediated[i] + c(-1, 1) * prop.se[i]));
  
  # The return value as a data.frame that contains all the important info:
  ret_val <- data.frame("effect"  =c("total",                             # total  
                                     "direct",                            # direct  
                                     rep("indirect", length(mediators))), # indirect
                        "mediator"=c(NA,         # total 
                                     NA,         # direct       
                                     mediators), # indirect
                        "estimate"=c(sjmisc::typical_value(eff.total, fun=typical),                                                                 # total 
                                     sjmisc::typical_value(eff.direct, fun=typical),                                                                # direct
                                     vapply(1:ncol(eff.indirects), function(i) sjmisc::typical_value(eff.indirects[,i], fun=typical), numeric(1))), # indirect
                        "estimate_HDI_low" =c(eff.total_HDI$CI_low[1],   # total  
                                              eff.direct_HDI$CI_low[1],  # direct 
                                              eff.indirects_HDI$CI_low), # indirect
                        "estimate_HDI_high"=c(eff.total_HDI$CI_high[1],   # total 
                                              eff.direct_HDI$CI_high[1],  # direct 
                                              eff.indirects_HDI$CI_high), # indirect
                        "p_ROPE"=c(rope(eff.total, range=rope.range, ci=prob)$ROPE_Percentage[1],                                                                 # total
                                   rope(eff.direct, range=rope.range, ci=prob)$ROPE_Percentage[1],                                                                # direct
                                   vapply(1:ncol(eff.indirects), function(i) rope(eff.indirects[,i], range=rope.range, ci=prob)$ROPE_Percentage[1], numeric(1))), # indirect
                        "proportion"=c(1.00,                      # total  
                                       1.00 - sum(prop.mediated), # direct
                                       prop.mediated),            # indirect
                        "proportion_HDI_low" =c(1.00,                     # total  
                                                1.00 - sum(prop.hdi[,2]), # direct
                                                prop.hdi[,1]),            # indirect
                        "proportion_HDI_high"=c(1.00,                     # total  
                                                1.00 - sum(prop.hdi[,1]), # direct
                                                prop.hdi[,2])             # indirect
  );
  attr(ret_val, "response") <- response;
  attr(ret_val, "treatment") <- treatment;
  attr(ret_val, "mediators") <- mediators;
  attr(ret_val, "prob") <- prob;
  attr(ret_val, "typical") <- typical;
  attr(ret_val, "rope.range") <- rope.range;
  
  return (ret_val);
}

# Pretty print mediation results (as a data.frame):
.print_multiple_mediators_brms <- function(x)
{
  ret_val <- data.frame("outcome"=attr(x,"response"),
                        "mediators"=paste0(attr(x,"mediators"), collapse=" "),
                        "effect"=paste0(x$effect, ifelse(x$effect == "indirect", paste0(" (",x$mediator,")") ,"")),
                        "size"=sprintf("%.2f; %.0f%%HDI [%.2f, %.2f]; p=%.2g%s", 
                                       x$estimate, attr(x,"prob")*100, x$estimate_HDI_low, x$estimate_HDI_high, x$p_ROPE, gtools::stars.pval(x$p_ROPE)),
                        "proportion"=sprintf("%.1f%% [%.1f%%, %.1f%%]",
                                             100*x$proportion, 100*x$proportion_HDI_low, 100*x$proportion_HDI_high));
  ret_val$effect <- gsub("se_v_redYes", "vowel reduction", ret_val$effect);
  ret_val$effect <- gsub("se_v_delYes", "vowel deletion",  ret_val$effect);
  ret_val$effect <- gsub("se_v_devYes", "vowel devoicing", ret_val$effect);
  ret_val;
}

# Fit mediation analysis T -> M -> O
.fit_mediation_model <- function(d=d_colors_ag, 
                                 outcome="exists_blue", outcome_name="blue", 
                                 treatment="latitude_r", treatment_name="latitude", 
                                 mediator="UVB_r", mediator_name="UVB", 
                                 family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                                 cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control,
                                 save_model=FALSE, show_results=FALSE)
{
  # Mediation with brms:
  f_mediator <- bf(formula(paste0(mediator," ~ ",treatment," + ",                ranefs)), family=family_mediator);
  f_outcome  <- bf(formula(paste0(outcome, " ~ ",mediator, " + ",treatment," + ",ranefs)), family=family_outcome);
  model <- brm(f_mediator + f_outcome + set_rescor(FALSE), # uncorrelated residuals
               save_pars=save_pars(all=TRUE), # needed for Bayes factors
               sample_prior=TRUE,  # needed for hypotheses tests
               data=d, cores=cores, iter=iter, warmup=warmup, thin=thin, control=control);
  #model <- brms_fit_indices(model);
  model_summary <- summary(model); if(show_results) { print(model_summary); mcmc_plot(model, type="trace"); mcmc_plot(model); }
  if( show_results) { bayestestR::mediation(model); }
  model_mediation <- .mediation_multiple_mediators_brms(model, response=outcome, treatment=treatment, mediators=c(mediator)); if( show_results) { print(model_mediation); }
  #.print_multiple_mediators_brms(model_mediation);

  # Return and possibly save the results:
  ret_val <- list("outcome"=outcome, "outcome_name"=outcome_name,
                  "treatment"=treatment, "treatment_name"=treatment_name,
                  "mediator"=mediator, "mediator_name"=mediator_name,
                  "formulas"=c("mediator"=paste0(mediator," ~ ",treatment," + ",ranefs), "outcome"=paste0(outcome, " ~ ",mediator, " + ",treatment," + ",ranefs)),
                  "brms_param"=list("cores"=cores, "iter"=iter, "warmup"=warmup, "thin"=thin, "control"=control),
                  "model"=if(save_model){ model } else { NULL }, "summary"=list("fixed"=model_summary$fixed), "mediation"=model_mediation);
  return (ret_val);
}

# Plot the results of a mediation analysis T -> M -> O using DiagrammeR:
.plot_mediation_model <- function(model_summary, model_mediation, 
                                  outcome=NA,   outcome_name="",   outcome_col="gray95",
                                  treatment=NA, treatment_name="", treatment_col="gray95",
                                  mediator=NA,  mediator_name="",  mediator_col="gray95",
                                  edge_ns_col="gray80", edge_neg_col="blue", edge_pos_col="red",
                                  summary_col_ns="gray50", summary_col_neg="blue", summary_col_pos="red")
{
  .edge_col <- function(edge_lo, edge_hi)
  {
    if(edge_lo < 0 && 0 < edge_hi)
      return (edge_ns_col) # ns
    else if( edge_hi < 0 )
      return (edge_neg_col) # < 0
    else
      return (edge_pos_col); # > 0
  }
  
  .eff_col <- function(eff_estim, eff_p, eff_lo, eff_hi)
  {
    if(eff_p >= 0.05 && (eff_lo < 0 && 0 < eff_hi))
      return (summary_col_ns) # ns
    else if( eff_estim < 0 )
      return (summary_col_neg) # < 0
    else
      return (summary_col_pos); # > 0
  }

  T_O <- model_summary$fixed[grep(paste0(gsub("_","",outcome,fixed=TRUE), "_", treatment), rownames(model_summary$fixed), fixed=TRUE),];
  T_O_0in <- as.numeric(T_O["l-95% CI"] < 0 && 0 < T_O["u-95% CI"])+1;
  T_O_col <- .edge_col(T_O["l-95% CI"], T_O["u-95% CI"]);
  T_M <- model_summary$fixed[grep(paste0(gsub("_","",mediator,fixed=TRUE), "_", treatment), rownames(model_summary$fixed), fixed=TRUE),];
  T_M_0in <- as.numeric(T_M["l-95% CI"] < 0 && 0 < T_M["u-95% CI"])+1;
  T_M_col <- .edge_col(T_M["l-95% CI"], T_M["u-95% CI"]);
  M_O <- model_summary$fixed[grep(paste0(gsub("_","",outcome,fixed=TRUE), "_", mediator), rownames(model_summary$fixed), fixed=TRUE),];
  M_O_0in <- as.numeric(M_O["l-95% CI"] < 0 && 0 < M_O["u-95% CI"])+1;
  M_O_col <- .edge_col(M_O["l-95% CI"], M_O["u-95% CI"]);
  TotEf <-  model_mediation[model_mediation$effect == "total",];
  Tot_col <- .eff_col(TotEf["estimate"], TotEf["p_ROPE"], TotEf["estimate_HDI_low"], TotEf["estimate_HDI_high"]);
  DirEf <-  model_mediation[model_mediation$effect == "direct",];
  Dir_col <- .eff_col(DirEf["estimate"], DirEf["p_ROPE"], DirEf["estimate_HDI_low"], DirEf["estimate_HDI_high"]);
  IndEf <-  model_mediation[model_mediation$effect == "indirect",];
  Ind_col <- .eff_col(IndEf["estimate"], IndEf["p_ROPE"], IndEf["estimate_HDI_low"], IndEf["estimate_HDI_high"]);
  
  DiagrammeR::grViz(paste0('
    digraph mediation_d2l_lat {
  
    # the graph:
    graph [overlap = true]
    rankdir="LR";
  
    # the nodes:
    node [shape = box, style = "filled"]
    T    [label = "',treatment_name,'", tooltip = "treatment", fillcolor = "',treatment_col,'"]; 
    M    [label = "',mediator_name,'",  tooltip = "mediator",  fillcolor = "',outcome_col,'"]; 
    R    [label = "',outcome_name,'",   tooltip = "outcome",   fillcolor = "',mediator_col,'"]; 
  
    # the edges:
    edge [style = "solid", color = "black"]
    T -> R [label="',sprintf("%.2f [%.2f, %.2f]", T_O["Estimate"], T_O["l-95% CI"], T_O["u-95% CI"]),'", tooltip="treatment -> outcome", 
            style="',c("solid","dashed")[T_O_0in],'", color="',T_O_col,'", fontcolor="',T_O_col,'"]
    T -> M [label="',sprintf("%.2f [%.2f, %.2f]", T_M["Estimate"], T_M["l-95% CI"], T_M["u-95% CI"]),'", tooltip="treatment -> mediator", 
            style="',c("solid","dashed")[T_M_0in],'", color="',T_M_col,'", fontcolor="',T_M_col,'"]
    M -> R [label="',sprintf("%.2f [%.2f, %.2f]", M_O["Estimate"], M_O["l-95% CI"], M_O["u-95% CI"]),'", tooltip="mediator -> outcome", 
            style="',c("solid","dashed")[M_O_0in],'", color="',M_O_col,'", fontcolor="',M_O_col,'"]
    
    # summary:
    te [shape="none", style="empty", fontcolor="',Tot_col,'", 
        tooltip="Total effect", label=',ifelse(TotEf["p_ROPE"] < 0.05,'< <B>','"'),sprintf("Total effect = %.2f [%.2f, %.2f], p = %.4g%s", 
                                                 TotEf["estimate"], TotEf["estimate_HDI_low"], TotEf["estimate_HDI_high"], TotEf["p_ROPE"], ifelse(TotEf["p_ROPE"] < 0.05, "*", "")),ifelse(TotEf["p_ROPE"] < 0.05,'</B> >','"'),']
    de [shape="none", style="empty", fontcolor="',Dir_col,'", 
        tooltip="Direct effect", label=',ifelse(DirEf["p_ROPE"] < 0.05,'< <B>','"'),sprintf("Direct effect = %.2f [%.2f, %.2f], p = %.4g%s", 
                                                 DirEf["estimate"], DirEf["estimate_HDI_low"], DirEf["estimate_HDI_high"], DirEf["p_ROPE"], ifelse(DirEf["p_ROPE"] < 0.05, "*", "")),ifelse(DirEf["p_ROPE"] < 0.05,'</B> >','"'),']
    ie [shape="none", style="empty", fontcolor="',Ind_col,'", 
        tooltip="Indirect effect", label=',ifelse(IndEf["p_ROPE"] < 0.05,'< <B>','"'),sprintf("Indirect effect = %.2f [%.2f, %.2f], p = %.4g%s", 
                                                 IndEf["estimate"], IndEf["estimate_HDI_low"], IndEf["estimate_HDI_high"], IndEf["p_ROPE"], ifelse(IndEf["p_ROPE"] < 0.05, "*", "")),ifelse(IndEf["p_ROPE"] < 0.05,'</B> >','"'),']
    # trick for aligning them:
    te -> de [style = "none", color = "none"]
    de -> ie [style = "none", color = "none"]
  }
  '));
}

# Helper for plotting a mediation model stored in a .fit.mediation.model() result:
.plot_mediation <- function(m, save_to_pdf=NULL)
{
  p <- .plot_mediation_model(m$summary, m$mediation, 
                             outcome=m$outcome, outcome_name=m$outcome_name, 
                             treatment=m$treatment, treatment_name=m$treatment_name, 
                             mediator=m$mediator, mediator_name=m$mediator_name);
  if( !is.null(save_to_pdf) && length(save_to_pdf) == 1 )
  {
    # Export it as PDF (https://github.com/rich-iannone/DiagrammeR/issues/330#issuecomment-766090870):
    tmp <- DiagrammeRsvg::export_svg(p);
    tmp <- charToRaw(tmp) # flatten
    rsvg::rsvg_pdf(tmp, paste0("./paper/fig_",save_to_pdf,".pdf")); # saved graph as png in current working directory
  }
  p; # plot it!
}



# Scientific notation using Markdown conventions (inspired from https://www.r-bloggers.com/2015/03/scientific-notation-for-rlatex/):
scinot <- function(xs, digits=2, pvalue=TRUE)
{
  scinot1 <- function(x)
  {
    sign <- "";
    if(x < 0)
    {
      sign <- "-";
      x <- -x;
    }
    exponent <- floor(log10(x));
    if(exponent && pvalue && exponent < -3) 
    {
      xx <- round(x / 10^exponent, digits=digits);
      e <- paste0("×10^", round(exponent,0), "^");
    } else 
    {
      xx <- round(x, digits=digits+1);
      e <- "";
    }
    paste0(sign, xx, e);
  }
  vapply(xs, scinot1, character(1));
}

# Escape * in a string:
escstar <- function(s)
{
  gsub("*", "\\*", s, fixed=TRUE);
}
```

# Data preparation

Data preparation, cleaning and formatting.

```{r load and prepare data, error=FALSE, include=FALSE}
# Assume the working directory contains this RMarkdown document!

# Load the world map and change it for Pacific-centered plotting:
mapWorld <- map_data("world", wrap=c(-20,340), ylim=c(-70,100));



###############################################################

###--- 0) Read the color data for the language families --- ###

###############################################################


d_fam <- read.table("./input_files/databases/family/data_families.csv", header=TRUE, sep=";", quote='"', stringsAsFactors=FALSE); # comma-separated double-quoted CVS file

d_fam$longitude_180  <- d_fam$longitude;
d_fam$longitude      <- ifelse(d_fam$longitude_180 < -20, d_fam$longitude_180 + 360, d_fam$longitude_180);


# Add the various info, both for the languages and for the families.
# For humidity, keep only the mean annual median and IQR as all the other measures are very highly correlated with these
# For UV, do not use the individual frequency bands, but the wide categories "A" and "B" (and overall):
d_climate_fam    <- read.table("input_files/databases/family/data_climate.tsv",      header=TRUE, sep="\t", quote="");
d_humidity_fam   <- read.table("input_files/databases/family/data_humidity.tsv",     header=TRUE, sep="\t", quote="");
d_dist2water_fam <- read.table("input_files/databases/family/data_dist2water.tsv",   header=TRUE, sep="\t", quote="");
d_uv_fam         <- read.table("input_files/databases/family/data_UV_incidence.tsv", header=TRUE, sep="\t", quote="");
d_uv_wc_fam         <- read.table("input_files/databases/family/data_UV_incidence_worldclim.tsv", header=TRUE, sep="\t", quote="");
names(d_uv_wc_fam)[names(d_uv_wc_fam) == 'UV_mean'] <- 'UV_mean_wc';
names(d_uv_wc_fam)[names(d_uv_wc_fam) == 'UV_sd']   <- 'UV_sd_wc';
d_elevation_fam  <- read.table("input_files/databases/family/data_elevation.tsv",    header=TRUE, sep="\t", quote="");

# merge and change name column so that we know it's for family
d_fam <-  d_climate_fam[,c("glottocode","latitude", "longitude", "longitude_180", "clim_PC1", "clim_PC2", "clim_PC3")]
names(d_fam) <- c("glottocode", "latitude_family","longitude_family", "longitude_family_180", "clim_PC1_family", "clim_PC2_family", "clim_PC3_family");
d_fam <- merge(d_fam, d_humidity_fam[,c("glottocode","humidity_mean_annual_median", "humidity_mean_annual_IQR")], by="glottocode", all.x=TRUE, all.y=FALSE);
names(d_fam)[ncol(d_fam)-c(1,0)] <- c("hum_median_family", "hum_IQR_family");
d_fam <- merge(d_fam, d_dist2water_fam[,c("glottocode", "dist2ocean", "dist2lakes", "dist2rivers", "dist2water")], by="glottocode", all.x=TRUE, all.y=FALSE);
names(d_fam)[ncol(d_fam)-c(3,2,1,0)] <- c("dist2ocean_family", "dist2lakes_family", "dist2rivers_family", "dist2water_family");
d_fam <- merge(d_fam, d_uv_wc_fam[,c("glottocode", "UV_mean_wc", "UV_sd_wc")], by="glottocode", all.x=TRUE, all.y=FALSE);
names(d_fam)[ncol(d_fam)-c(1,0)] <- c("UV_mean_wc_family", "UV_sd_wc_family");
d_fam <- merge(d_fam, d_uv_fam[,c("glottocode", "UV_mean", "UV_sd")], by="glottocode", all.x=TRUE, all.y=FALSE);
names(d_fam)[ncol(d_fam)-c(1,0)] <- c("UV_mean_family", "UV_sd_family");
d_fam <- merge(d_fam, d_elevation_fam[,c("glottocode", "elevation")], by="glottocode", all.x=TRUE, all.y=FALSE);
names(d_fam)[ncol(d_fam)-c(0)] <- c("elevation_family");
names(d_fam)[names(d_fam) == 'glottocode'] <- 'glottocode_family'

###############################################################

###--- 1) Read the color data for CLICS database        --- ###

###############################################################


# Load the colors data:
d_colors <- read.table("input_files/databases/clics/data_culture.csv", header=TRUE, sep=";", quote='"', stringsAsFactors=FALSE); # comma-separated double-quoted CVS file
# there already are some duplicated rows...
d_colors <- d_colors[!duplicated(d_colors), ];

# change longitude format
d_colors$longitude_180  <- d_colors$longitude;
d_colors$longitude      <- ifelse(d_colors$longitude_180 < 0, d_colors$longitude_180 + 360, d_colors$longitude_180);

# Add the various info, both for the languages and for the families.
# For humidity, keep only the mean annual median and IQR as all the other measures are very highly correlated with these
# For UV, do not use the individual frequency bands, but the wide categories "A" and "B" (and overall):
d_climate    <- read.table("input_files/databases/clics/data_climate.tsv",                header=TRUE, sep="\t", quote="");
d_humidity   <- read.table("input_files/databases/clics/data_humidity.tsv",               header=TRUE, sep="\t", quote="");
d_dist2water <- read.table("input_files/databases/clics/data_dist2water.tsv",             header=TRUE, sep="\t", quote="");
d_uv         <- read.table("input_files/databases/clics/data_UV_incidence.tsv",           header=TRUE, sep="\t", quote="");
d_uv_wc      <- read.table("input_files/databases/clics/data_UV_incidence_worldclim.tsv", header=TRUE, sep="\t", quote="");
names(d_uv_wc)[names(d_uv_wc) == 'UV_mean'] <- 'UV_mean_wc';
names(d_uv_wc)[names(d_uv_wc) == 'UV_sd']   <- 'UV_sd_wc';
d_elevation  <- read.table("input_files/databases/clics/data_elevation.tsv",              header=TRUE, sep="\t", quote="");

# for languages ...
d_colors <- merge(d_colors[, c("glottocode", "exists_blue", "macroarea", "latitude", "longitude", "longitude_180", "glottocode_family", "status", "subsistence", "popsize_ethno", "popsize_wiki")], d_climate[,c("glottocode","latitude", "longitude_180", "clim_PC1", "clim_PC2", "clim_PC3")], by=c("glottocode", "latitude", "longitude_180"), all.x=TRUE, all.y=FALSE);
d_colors <- merge(d_colors, d_humidity[,c("glottocode", "latitude", "longitude", "humidity_mean_annual_median", "humidity_mean_annual_IQR")], by=c("glottocode", "latitude", "longitude"), all.x=TRUE, all.y=FALSE);
names(d_colors)[ncol(d_colors)-c(1,0)] <- c("hum_median", "hum_IQR");
d_colors <- merge(d_colors, d_dist2water[,c("glottocode", "latitude", "longitude", "dist2ocean", "dist2lakes", "dist2rivers", "dist2water")], by=c("glottocode", "latitude", "longitude"), all.x=TRUE, all.y=FALSE);
d_colors <- merge(d_colors, d_uv[,c("glottocode", "latitude", "longitude", "UV_mean", "UV_sd")], by=c("glottocode", "latitude", "longitude"), all.x=TRUE, all.y=FALSE);
d_colors <- merge(d_colors, d_uv_wc[,c("glottocode", "latitude", "longitude", "UV_mean_wc", "UV_sd_wc")], by=c("glottocode", "latitude", "longitude"), all.x=TRUE, all.y=FALSE);
d_colors <- merge(d_colors, d_elevation[,c("glottocode", "latitude", "longitude_180", "elevation")], by=c("glottocode", "latitude", "longitude_180"), all.x=TRUE, all.y=FALSE);
#d_colors <- merge(d_colors, d_genetics, by="glottocode", all.x=TRUE, all.y=FALSE);

# For a mysterious reason some duplicated rows appears
d_colors <- d_colors[!duplicated(d_colors), ];

# change a weird thing with spaces
d_colors$glottocode_family[d_colors$glottocode_family=="atla1278  "] <- "atla1278";
d_colors$glottocode_family[d_colors$glottocode_family=="aust1305   "] <- "aust1305";

# ... and for families
d_colors <- merge(d_colors, d_fam, by="glottocode_family", all.x=TRUE, all.y=FALSE);

# create specific file
d_colors_clics <- d_colors;
d_colors_clics$database <- "CLICS";



###############################################################

###--- 2) Read the color data from OTHERS database      --- ###

###############################################################

# Load the colors data:
d_colors <- read.table("input_files/databases/other/data_culture.csv", header=TRUE, sep=";", quote='"', stringsAsFactors=FALSE); # comma-separated double-quoted CVS file

# change longitude format
d_colors$longitude_180  <- d_colors$longitude;
d_colors$longitude      <- ifelse(d_colors$longitude_180 < 0, d_colors$longitude_180 + 360, d_colors$longitude_180);

# Add the various info, both for the languages and for the families.
# For humidity, keep only the mean annual median and IQR as all the other measures are very highly correlated with these
# For UV, do not use the individual frequency bands, but the wide categories "A" and "B" (and overall):
d_climate    <- read.table("input_files/databases/other/data_climate.tsv",                header=TRUE, sep="\t", quote="");
d_humidity   <- read.table("input_files/databases/other/data_humidity.tsv",               header=TRUE, sep="\t", quote="");
d_dist2water <- read.table("input_files/databases/other/data_dist2water.tsv",             header=TRUE, sep="\t", quote="");
d_uv         <- read.table("input_files/databases/other/data_UV_incidence.tsv",           header=TRUE, sep="\t", quote="");
d_uv_wc      <- read.table("input_files/databases/other/data_UV_incidence_worldclim.tsv", header=TRUE, sep="\t", quote="");
names(d_uv_wc)[names(d_uv_wc) == 'UV_mean'] <- 'UV_mean_wc';
names(d_uv_wc)[names(d_uv_wc) == 'UV_sd']   <- 'UV_sd_wc';
d_elevation  <- read.table("input_files/databases/other/data_elevation.tsv",              header=TRUE, sep="\t", quote="");

# for languages ...
d_colors <- merge(d_colors[, c("glottocode", "exists_blue", "macroarea", "latitude", "longitude", "longitude_180", "glottocode_family", "status", "subsistence", "popsize_ethno", "popsize_wiki")], d_climate[,c("glottocode","latitude", "longitude", "longitude_180", "clim_PC1", "clim_PC2", "clim_PC3")], by=c("glottocode", "latitude", "longitude", "longitude_180"), all.x=TRUE, all.y=FALSE);
d_colors <- merge(d_colors, d_humidity[,c("glottocode", "latitude", "longitude", "humidity_mean_annual_median", "humidity_mean_annual_IQR")], by=c("glottocode", "latitude", "longitude"), all.x=TRUE, all.y=FALSE);
names(d_colors)[ncol(d_colors)-c(1,0)] <- c("hum_median", "hum_IQR");
d_colors <- merge(d_colors, d_dist2water[,c("glottocode", "latitude", "longitude", "dist2ocean", "dist2lakes", "dist2rivers", "dist2water")], by=c("glottocode", "latitude", "longitude"), all.x=TRUE, all.y=FALSE);
d_colors <- merge(d_colors, d_uv[,c("glottocode", "latitude", "longitude", "UV_mean", "UV_sd")], by=c("glottocode", "latitude", "longitude"), all.x=TRUE, all.y=FALSE);
d_colors <- merge(d_colors, d_uv_wc[,c("glottocode", "latitude", "longitude", "UV_mean_wc", "UV_sd_wc")], by=c("glottocode", "latitude", "longitude"), all.x=TRUE, all.y=FALSE);
d_colors <- merge(d_colors, d_elevation[,c("glottocode", "latitude", "longitude", "elevation")], by=c("glottocode", "latitude", "longitude"), all.x=TRUE, all.y=FALSE);

# ... and for families
d_colors <- merge(d_colors, d_fam, by="glottocode_family", all.x=TRUE, all.y=FALSE);

# create specific file
d_colors_other <- d_colors;
d_colors_other$database <- "other";


###############################################################

### --- 3) Preliminary check briefly new UV measures    --- ###

###############################################################

d_uv_all    <- read.table("input_files/databases/scirep_paper/data_UV_incidence.tsv",             header=TRUE, sep="\t", quote="");
d_uv_1998m  <- read.table("input_files/databases/scirep_paper/data_UV_incidence_1998_m2.tsv",     header=TRUE, sep="\t", quote="");
d_uv_1998j  <- read.table("input_files/databases/scirep_paper/data_UV_incidence_1998_joules.tsv", header=TRUE, sep="\t", quote="");

all <- merge(d_uv_all[,c("glottocode", "UV_mean", "UV_sd")], d_uv_1998m[,c("glottocode", "UV_mean", "UV_sd")], by="glottocode");
all <- merge(all, d_uv_1998j[,c("glottocode", "UV_B_mean", "UV_B_sd")], by="glottocode");

colnames(all) <- c("glottocode", "UV_mean_all", "UV_sd_all", "UV_mean_1998m", "UV_sd_1998m", "UV_mean_1998j", "UV_sd_1998j");

# check the mean:
all$UV_mean_all   <- as.numeric(scale(all$UV_mean_all)); # remove the scale-specific attributes to avoid thw warning about attributes in gather()
all$UV_mean_1998m <- as.numeric(scale(all$UV_mean_1998m));
all$UV_mean_1998j <- as.numeric(scale(all$UV_mean_1998j));
all_gat <- gather(all, condition, measurement, c(UV_mean_all, UV_mean_1998m, UV_mean_1998j));
all_gat$glottocode <- as.numeric(as.factor(all_gat$glottocode)); # just for plotting get rid of the glottocodes
ggplot(all_gat, aes(x=glottocode, y=measurement, color=condition))+
  geom_point() +
  geom_line()

## The mean is very similar for the 3 files...

# check the sds:
all$UV_sd_all   <- as.numeric(scale(all$UV_sd_all));
all$UV_sd_1998m <- as.numeric(scale(all$UV_sd_1998m));
all$UV_sd_1998j <- as.numeric(scale(all$UV_sd_1998j));
all_gat <- gather(all, condition, measurement, c(UV_sd_all, UV_sd_1998m, UV_sd_1998j));
all_gat$glottocode <- as.numeric(as.factor(all_gat$glottocode)); # just for plotting get rid of the glottocodes
ggplot(all_gat, aes(x=glottocode, y=measurement, color=condition))+
  geom_point() +
  geom_line()

## The sd is exactly the opposite shape for the previous file and the files now!



###############################################################

###--- 3) Read the color data from PREVIOUS database    --- ###

###############################################################

d_colors <- read.table("input_files/databases/scirep_paper/data_colors.csv", header=TRUE, sep=";", quote='"', stringsAsFactors=FALSE);
d_colors <- d_colors[, 1:(ncol(d_colors)-1) ]; # last column is an artifact 

d_climate    <- read.table("input_files/databases/scirep_paper/data_climate.tsv",                header=TRUE, sep="\t", quote="");
d_humidity   <- read.table("input_files/databases/scirep_paper/data_humidity.tsv",               header=TRUE, sep="\t", quote="");
d_dist2water <- read.table("input_files/databases/scirep_paper/data_dist2water.tsv",             header=TRUE, sep="\t", quote="");
d_uv         <- read.table("input_files/databases/scirep_paper/data_UV_incidence.tsv",           header=TRUE, sep="\t", quote="");
d_uv_wc      <- read.table("input_files/databases/scirep_paper/data_UV_incidence_worldclim.tsv", header=TRUE, sep="\t", quote="");

names(d_uv_wc)[names(d_uv_wc) == 'UV_mean'] <- 'UV_mean_wc';
names(d_uv_wc)[names(d_uv_wc) == 'UV_sd']   <- 'UV_sd_wc';
d_elevation  <- read.table("input_files/databases/scirep_paper/data_elevation.tsv",              header=TRUE, sep="\t", quote="");

# for languages ...
d_colors <- merge(d_colors, d_climate[,c("glottocode", "clim_PC1", "clim_PC2", "clim_PC3")], by="glottocode", all.x=TRUE, all.y=FALSE);
d_colors <- merge(d_colors, d_humidity[,c("glottocode", "humidity_mean_annual_median", "humidity_mean_annual_IQR")], by="glottocode", all.x=TRUE, all.y=FALSE);
names(d_colors)[ncol(d_colors)-c(1,0)] <- c("hum_median", "hum_IQR");
d_colors <- merge(d_colors, d_dist2water[,c("glottocode", "dist2ocean", "dist2lakes", "dist2rivers", "dist2water")], by="glottocode", all.x=TRUE, all.y=FALSE);
d_colors <- merge(d_colors, d_uv[,c("glottocode", "UV_mean", "UV_sd")], by="glottocode", all.x=TRUE, all.y=FALSE);
d_colors <- merge(d_colors, d_uv_wc[,c("glottocode", "UV_mean_wc", "UV_sd_wc")], by="glottocode", all.x=TRUE, all.y=FALSE);
d_colors <- merge(d_colors, d_elevation[,c("glottocode", "elevation")], by="glottocode", all.x=TRUE, all.y=FALSE);

drop <- c("daltonism", "L1", "macro_family", "genetic_incomplete", "genetic_full");
d_colors = d_colors[,!(names(d_colors) %in% drop)];

# ... and for families
d_colors <- merge(d_colors, d_fam, by="glottocode_family", all.x=TRUE, all.y=FALSE);

# check if there are any updates and if yes, apply them:
d_scirep_updates <- read.table("input_files/databases/scirep_paper/updates.csv", header=TRUE, sep=";", quote='"', stringsAsFactors=FALSE);
for( i in 1:nrow(d_scirep_updates) )
{
  if( (d_scirep_updates$glottocode[i] %in% d_colors$glottocode) && (d_scirep_updates$variable[i] %in% names(d_colors)) )
  {
    d_colors[ d_colors$glottocode == d_scirep_updates$glottocode[i], names(d_colors) == d_scirep_updates$variable[i] ] <- d_scirep_updates$new_value[i];
  }
}

# create specific file:
d_colors_previous <- d_colors;
d_colors_previous$database <- "scirep_paper";

# unlog the column to make similar comparison with other database:
d_colors_previous$popsize_ethno <- exp(as.numeric(d_colors_previous$log_popSize)) - 1; # undo the log(x + 1) process...
d_colors_previous <- d_colors_previous[ , -which(names(d_colors_previous) %in% c("log_popSize", "X"))];

# create column for status (alive, dead, just_extinct)
d_colors_previous$status <- "alive";
d_colors_previous$status[d_colors_previous$glottocode=="pare1266" | d_colors_previous$glottocode == "manx1243"] <- "just_extinct";

# Alternative view of the globe: all longitudes > 180 are "flipped" to negative values:
d_colors_previous$longitude_family_180 <- ifelse(d_colors_previous$longitude_family <= 180, d_colors_previous$longitude_family, d_colors_previous$longitude_family - 360);
d_colors_previous$longitude_180        <- ifelse(d_colors_previous$longitude <= 180,        d_colors_previous$longitude,        d_colors_previous$longitude - 360);


###############################################################

### --- 4) MERGE all databases                          --- ###

###############################################################

# sort dataframe by column name:
d_colors_previous <- d_colors_previous[ , order(names(d_colors_previous))];
d_colors_other    <- d_colors_other[ ,    order(names(d_colors_other))];
d_colors_clics    <- d_colors_clics[ ,    order(names(d_colors_clics))];

# bind them:
d_colors <- rbind(d_colors_clics, d_colors_other, d_colors_previous);

# for better plotting, slightly change the longitude format
d_colors$longitude <- ifelse(d_colors$longitude > 340, d_colors$longitude - 360, d_colors$longitude);

# Rescale variables (we use the suffix _r for them):
# - popsize: log(+1) because there are some populations set to 0, so increase everything by 1 to avoid -Inf (the state of the language is indicated in status)
d_colors$log_popSize_ethno  <- log(d_colors$popsize_ethno + 1);
d_colors$log_popSize_wiki   <- log(ifelse(is.na(d_colors$popsize_wiki) | d_colors$popsize_wiki==(-10), NA, d_colors$popsize_wiki) + 1); # replace the special value (-10) by NA

# - elevation: log(+1) because there are some elevations set to 0 meters, so increase everything by 1m to avoid -Inf:
# actually some elevation are below 0
d_colors$elevation_r          <- ifelse(d_colors$elevation < 0, 0, d_colors$elevation);
d_colors$elevation_r          <- log(d_colors$elevation_r + 1);
d_colors$elevation_family_r   <- ifelse(d_colors$elevation_family < 0, 0, d_colors$elevation_family);
d_colors$elevation_family_r   <- log(d_colors$elevation_family_r + 1);
# - distance to water bodies: log() as distances to water are never 0.0, so no need to guard against -Inf here:
d_colors$dist2water_r         <- log(d_colors$dist2water + 1);
d_colors$dist2rivers_r        <- log(d_colors$dist2rivers + 1);
d_colors$dist2ocean_r         <- log(d_colors$dist2ocean + 1);
d_colors$dist2lakes_r         <- log(d_colors$dist2lakes + 1);
d_colors$dist2water_family_r  <- log(d_colors$dist2water_family + 1);
d_colors$dist2rivers_family_r <- log(d_colors$dist2rivers_family + 1);
d_colors$dist2ocean_family_r  <- log(d_colors$dist2ocean_family + 1);
d_colors$dist2lakes_family_r  <- log(d_colors$dist2lakes_family + 1);
# - longitude and latitude: cosine (degrees -> radians):
d_colors$latitude_r           <- 1.0 - cos(d_colors$latitude*(pi/180)); # make sure these longitudes are still highest at the poles
d_colors$longitude_r          <- cos(d_colors$longitude*(pi/180));
d_colors$latitude_family_r    <- 1.0 - cos(d_colors$latitude_family*(pi/180));
d_colors$longitude_family_r   <- cos(d_colors$longitude_family*(pi/180));
# - UV incidence: z-score:
d_colors$UV_mean_r            <- as.numeric(scale(d_colors$UV_mean)); # get rid of the scale()-specific attributes
d_colors$UV_sd_r              <- as.numeric(scale(d_colors$UV_sd)); # get rid of the scale()-specific attributes
d_colors$UV_mean_wc_r         <- as.numeric(scale(d_colors$UV_mean_wc)); # get rid of the scale()-specific attributes
d_colors$UV_sd_wc_r           <- as.numeric(scale(d_colors$UV_sd_wc)); # get rid of the scale()-specific attributes

d_colors$UV_mean_family_r     <- as.numeric(scale(d_colors$UV_mean_family)); # get rid of the scale()-specific attributes
d_colors$UV_sd_family_r       <- as.numeric(scale(d_colors$UV_sd_family)); # get rid of the scale()-specific attributes
d_colors$UV_mean_wc_family_r  <- as.numeric(scale(d_colors$UV_mean_wc_family)); # get rid of the scale()-specific attributes
d_colors$UV_sd_wc_family_r    <- as.numeric(scale(d_colors$UV_sd_wc_family)); # get rid of the scale()-specific attributes

# - climate: z-score:
d_colors$clim_PC1_r           <- as.numeric(scale(d_colors$clim_PC1)); # get rid of the scale()-specific attributes
d_colors$clim_PC2_r           <- as.numeric(scale(d_colors$clim_PC2)); # get rid of the scale()-specific attributes
d_colors$clim_PC3_r           <- as.numeric(scale(d_colors$clim_PC3)); # get rid of the scale()-specific attributes
d_colors$clim_PC1_family_r    <- as.numeric(scale(d_colors$clim_PC1_family)); # get rid of the scale()-specific attributes
d_colors$clim_PC2_family_r    <- as.numeric(scale(d_colors$clim_PC2_family)); # get rid of the scale()-specific attributes
d_colors$clim_PC3_family_r    <- as.numeric(scale(d_colors$clim_PC3_family)); # get rid of the scale()-specific attributes


# Ensure factors have the right levels and contrasts:
d_colors$exists_blue <- factor(d_colors$exists_blue, levels=c("no", "yes")); # please note that this implicitly transforms the "mixed_with" languages in CLICKS into missing data (NA), which is the desired behavior given their unclear interpretation
d_colors$subsistence <- factor(d_colors$subsistence, levels=c("HG", "AGR"));

# Collapse the families with few languages into the "Other"category (for plotting purposes):
mytab <- data.frame(table(d_colors$glottocode_family));
mytab <- mytab[order(-mytab$Freq),];
list_glot <- as.character(mytab$Var1[1:13]); # select only the first 13 columns because they count more than 10 languages
d_colors$glottocode_family_other <- ifelse(d_colors$glottocode_family %in% list_glot,
                                           as.character(d_colors$glottocode_family),
                                           "Other");

# Just the language families data:
d_colors_families <- unique(d_colors[, grep("_family", names(d_colors), fixed=TRUE) ]);

# Just the coordinates:
d_coords <- cbind(d_colors[,c("glottocode_family", "latitude_family", "longitude_family", "longitude_family_180")], "type"="family");
names(d_coords) <- c("glottocode", "latitude", "longitude", "longitude_180", "type");
d_coords <- rbind(cbind(d_colors[,c("glottocode", "latitude", "longitude", "longitude_180")], "type"="language"), d_coords);
d_coords <- unique(d_coords);


###############################################################

### --- 5) CLEAN database (subjective choice!)          --- ###

###############################################################

# obviously, remove populations for which we don't know if they have a word for blue
# (after looking, it's only empty rows)
cat("There are ",sum(is.na(d_colors$exists_blue))," entires with no data for blue...\n"); # 20
d_colors <- d_colors[is.na(d_colors$exists_blue)==FALSE,];

# select only languages that are alive or just extinct
# (remove very old dead language and languages that are only written but not spoken)
cat("There are ",sum(!(d_colors$status=="alive" | d_colors$status=="just_extinct"))," entires for long-gone or only written languages...\n"); # 34
d_colors <- d_colors[d_colors$status=="alive" | d_colors$status=="just_extinct",];

## there are some weirdly high population sizes that also show discrepancies between ethnologue and wikipedia:
#plot(log(d_colors$popsize_wiki,10), log(d_colors$popsize_ethno,10)); identify(log(d_colors$popsize_wiki,10), log(d_colors$popsize_ethno,10));
#s <- (!is.na(d_colors$popsize_ethno) & !is.na(d_colors$popsize_wiki) & abs(log(d_colors$popsize_ethno,10) - log(d_colors$popsize_wiki,10)) > 1); # 1 order of magnitude or more between the ethnologue and wikipedia
#sum(s, na.rm=TRUE); # 42 outliers: check them against the last free edition of the Ethnologue using WayBackmachine (https://archive.org/web/) -> the version from 6/1/2013 !
#View(d_colors[s & !is.na(s),]);
## following manual checks (see file "input_files/databases/manual_checks_popsize_ethnologue.txt" for details) we need to fix the following in ethnologue: 
## kurd1259 nepa1254 alba1267 basq1248 tzot1259 mari1278 erzy1239 rian1262 hadz1240 saya1246
#View(d_colors[ d_colors$glottocode %in% c("kurd1259", "nepa1254", "alba1267", "basq1248", "tzot1259", "mari1278", "erzy1239", "rian1262", "hadz1240", "saya1246"), ]);
# -> fixed using the scirep_paper/updates.csv mechanism


# create a version aggregated by glottocode (in clics database, there are many datapoints for each glottocode)
### Aggregate by glottocode
# not the most elegant, but it does the job!
d_colors_ag <- d_colors %>% 
  dplyr::group_by(glottocode, database, exists_blue, glottocode_family, macroarea, status, subsistence, glottocode_family_other) %>%
  dplyr::summarize(clim_PC1       =mean(clim_PC1),
                   clim_PC1_family=mean(clim_PC1_family),
                   clim_PC2       =mean(clim_PC2),
                   clim_PC2_family=mean(clim_PC2_family),
                   clim_PC3       =mean(clim_PC3),
                   clim_PC3_family=mean(clim_PC3_family),
                   
                   clim_PC1_r       =mean(clim_PC1_r),
                   clim_PC1_family_r=mean(clim_PC1_family_r),
                   clim_PC2_r       =mean(clim_PC2_r),
                   clim_PC2_family_r=mean(clim_PC2_family_r),
                   clim_PC3_r       =mean(clim_PC3_r),
                   clim_PC3_family_r=mean(clim_PC3_family_r),
                   
                   
                   dist2lakes        =mean(dist2lakes),
                   dist2lakes_family =mean(dist2lakes_family),
                   dist2ocean        =mean(dist2ocean),
                   dist2ocean_family =mean(dist2ocean_family),
                   dist2rivers       =mean(dist2rivers),
                   dist2rivers_family=mean(dist2rivers_family),
                   dist2water        =mean(dist2water),
                   dist2water_family =mean(dist2water_family),
                   
                   dist2water_r        =log(mean(dist2water) + 1), # better reflects the log(x + 1) process than mean(x_r)
                   dist2rivers_r       =log(mean(dist2rivers) + 1),
                   dist2ocean_r        =log(mean(dist2ocean) + 1),
                   dist2lakes_r        =log(mean(dist2lakes) + 1),
                   dist2water_family_r =log(mean(dist2water_family) + 1),
                   dist2rivers_family_r=log(mean(dist2rivers_family) + 1),
                   dist2lakes_family_r =log(mean(dist2lakes_family) + 1),
                   dist2ocean_family_r =log(mean(dist2ocean_family) + 1),
                   
                   
                   elevation       =mean(elevation),
                   elevation_family=mean(elevation_family),
                   
                   elevation_r       =log(mean(elevation_r) + 1),
                   elevation_family_r=log(mean(elevation_family_r) + 1),
                   
                   
                   hum_IQR          =mean(hum_IQR),
                   hum_IQR_family   =mean(hum_IQR_family),
                   hum_median       =mean(hum_median),
                   hum_median_family=mean(hum_median_family),
                   
                   latitude       =mean(latitude),
                   latitude_family=mean(latitude_family),
                   
                   longitude           =mean(longitude),
                   longitude_180       =mean(longitude_180),
                   longitude_family    =mean(longitude_family),
                   longitude_family_180=mean(longitude_family_180),
                   longitude_family_r  =mean(longitude_family_r),
                   
                   latitude_r       =mean(latitude_r),
                   longitude_r      =mean(longitude_r),
                   latitude_family_r=mean(latitude_family_r),
                   
                   
                   popsize_ethno    =mean(popsize_ethno),
                   popsize_wiki     =mean(popsize_wiki),
                   log_popSize_ethno=log(mean(exp(log_popSize_ethno)-1) + 1), # better reflects the log(x + 1) process than mean(x_r) and exp()
                   log_popSize_wiki =log(mean(exp(log_popSize_wiki)-1)  + 1),
                   
                   UV_mean          =mean(UV_mean),
                   UV_mean_wc       =mean(UV_mean_wc),
                   UV_mean_family   =mean(UV_mean_family),
                   UV_mean_wc_family=mean(UV_mean_wc_family),
                   UV_sd            =mean(UV_sd),
                   UV_sd_wc         =mean(UV_sd_wc),
                   UV_sd_family     =mean(UV_sd_family),
                   UV_sd_wc_family  =mean(UV_sd_wc_family),
                   
                   UV_mean_r          =mean(UV_mean_r),
                   UV_mean_wc_r       =mean(UV_mean_wc_r),
                   UV_sd_r            =mean(UV_sd_r),
                   UV_sd_wc_r         =mean(UV_sd_wc_r),
                   UV_mean_family_r   =mean(UV_mean_family_r),
                   UV_mean_wc_family_r=mean(UV_mean_wc_family_r),
                   UV_sd_family_r     =mean(UV_sd_family_r),
                   UV_sd_wc_family_r  =mean(UV_sd_wc_family_r));

# Now let's check the length of unique glottocode:
length(unique(d_colors_ag$glottocode));

# and the total number of aggregated rows:
nrow(d_colors_ag);

# now let's look at duplicated glottocodes:
n_occur <- data.frame(table(d_colors_ag$glottocode));
list_glotto_dup <- as.character(n_occur[n_occur$Freq > 1,]$Var1);
tocheck <- d_colors_ag[d_colors_ag$glottocode %in% list_glotto_dup,];

# "unfactor" the factors:
d_colors$exists_blue    <- as.character(d_colors$exists_blue);
d_colors$database       <- as.character(d_colors$database);
d_colors_ag$exists_blue <- as.character(d_colors_ag$exists_blue);
d_colors_ag$database    <- as.character(d_colors_ag$database);

# keep this database with duplicates between databases and dialects as well:
d_colors_original <- d_colors;

# now let's check each individual case:
list_lang_2db <- c() # initialize empty list with duplicated glottocode across database
for (glot in unique(tocheck$glottocode))
{
  subdf <- tocheck[tocheck$glottocode==glot,];
  if (length(unique(subdf$database)) > 1)
  {
    # this appears in more than one database, apply the priority rules: scirep_paper > other > CLICS:
    list_lang_2db <- c(list_lang_2db, glot);
    cat(glot," appears in ",length(unique(subdf$database))," (",paste0(unique(subdf$database),collapse=","),") databases:");
    
    if( "scirep_paper" %in% subdf$database )
    {
      # remove all the others:
      cat(" keep scirep_paper");
      d_colors$database[ d_colors$glottocode == glot & d_colors$database != "scirep_paper" ] <-  
        d_colors_ag$database[ d_colors_ag$glottocode == glot & d_colors_ag$database != "scirep_paper" ] <-  
        subdf$database[ subdf$glottocode == glot & subdf$database != "scirep_paper" ] <- 
        "remove";
    } else if( "other" %in% subdf$database )
    {
      # remove all the others:
      cat(" keep others");
      d_colors$database[ d_colors$glottocode == glot & d_colors$database != "other" ] <- 
        d_colors_ag$database[ d_colors_ag$glottocode == glot & d_colors_ag$database != "other" ] <- 
        subdf$database[ subdf$glottocode == glot & subdf$database != "other" ] <- 
        "remove";
    }
    cat("\n");
  }
  
  # it happens also often that in CLICS, some villages have and some don't have a specific term for 'blue':
  s <- (subdf$database != "remove"); # look only at the retained database
  if( length(unique(subdf$exists_blue[s])) > 1 )
  {
    cat(glot," has different values for blue in database ",paste0(unique(subdf$database[s]),collapse=","),", so we remove it");
    d_colors$exists_blue[ d_colors$glottocode == glot & d_colors$database != "remove" ] <- 
      d_colors_ag$exists_blue[ d_colors_ag$glottocode == glot & d_colors_ag$database != "remove" ] <- 
      "depends_dialect";
    cat("\n");
  }
}

# remove data where the word for blue depends on the dialect
cat("There are ",length(unique(d_colors$glottocode[d_colors$exists_blue == "depends_dialect"]))," languages where CLICS give different values for different villages/dialects: we remove them.\n");
d_colors    <- d_colors[    d_colors$exists_blue    != "depends_dialect", ];
d_colors_ag <- d_colors_ag[ d_colors_ag$exists_blue != "depends_dialect", ];

# create dataframe with database duplicates for further analysis...
duplic_database <- d_colors_ag[ d_colors_ag$glottocode %in% list_lang_2db, ];

# ... and remove the duplicates from the final database
cat("There are ",length(unique(d_colors$glottocode[d_colors$database == "remove"]))," languages duplicated among databases: we apply the hierarchy scirep_paper > other > CLICS to retain only one database.\n");
d_colors    <- d_colors[    d_colors$database    != "remove", ];
d_colors_ag <- d_colors_ag[ d_colors_ag$database != "remove", ];

# make them factors
d_colors_original$exists_blue <- factor(d_colors_original$exists_blue, levels=c("no", "yes"));
d_colors_original$database    <- factor(d_colors_original$database, levels=c("CLICS", "other", "scirep_paper"));
d_colors_ag$exists_blue <- factor(d_colors_ag$exists_blue, levels=c("no", "yes"));
d_colors_ag$database    <- factor(d_colors_ag$database, levels=c("CLICS", "other", "scirep_paper"));
d_colors$exists_blue <- factor(d_colors$exists_blue, levels=c("no", "yes"));
d_colors$database    <- factor(d_colors$database, levels=c("CLICS", "other", "scirep_paper"));

# remove all populations where there are missing data
d_colors_nona <-      d_colors[is.na(d_colors$subsistence)==FALSE &
                                 is.na(d_colors$log_popSize_ethno)==FALSE & is.na(d_colors$log_popSize_wiki)==FALSE &
                                 is.na(d_colors$clim_PC1)==FALSE,]
d_colors_ag_nona <-   d_colors_ag[is.na(d_colors_ag$subsistence)==FALSE &
                                    is.na(d_colors_ag$log_popSize_ethno)==FALSE & is.na(d_colors_ag$log_popSize_wiki)==FALSE &
                                    is.na(d_colors_ag$clim_PC1)==FALSE,]

### SO TO CONCLUDE:
# We end up with 5 different databases:
# - d_colors_original: almost all data except dead languages
# - d_colors: almost all data except dead languages, duplicates, and languages where the word for blue depend on the dialect
# - d_colors_ag: same as above but aggregated by glottocode
# - d_colors_nona: same as d_colors but containing only language without missing data
# - d_colors_ag_nona: same as above but aggregated by glottocode

cat("Number of rows (observations) by database: ","\n- d_colors_original =",nrow(d_colors_original),"\n- d_colors =",nrow(d_colors),"\n- d_colors_ag =",nrow(d_colors_ag),"\n- d_colors_nona =",nrow(d_colors_nona),"\n- d_colors_ag_nona =",nrow(d_colors_ag_nona),".\n");
summary(d_colors_original);
summary(d_colors);
summary(d_colors_ag);
summary(d_colors_nona);
summary(d_colors_ag_nona);

# Check for glottocode duplicates in the aggregated dataset:
if( any(duplicated(d_colors_ag$glottocode)) ) stop("Opps! duplicated glottocodes in the aggregated dataset: how did they get here?");


### Make sure the various z-scores are re-applied for d_colors_ag (as this is the one we'll use in the following and its mean and as have changed due to various selections and manipulations)!
d_colors_ag$UV_mean_r            <- as.numeric(scale(d_colors_ag$UV_mean));
d_colors_ag$UV_sd_r              <- as.numeric(scale(d_colors_ag$UV_sd));
d_colors_ag$UV_mean_wc_r         <- as.numeric(scale(d_colors_ag$UV_mean_wc));
d_colors_ag$UV_sd_wc_r           <- as.numeric(scale(d_colors_ag$UV_sd_wc));
d_colors_ag$UV_mean_family_r     <- as.numeric(scale(d_colors_ag$UV_mean_family));
d_colors_ag$UV_sd_family_r       <- as.numeric(scale(d_colors_ag$UV_sd_family));
d_colors_ag$UV_mean_wc_family_r  <- as.numeric(scale(d_colors_ag$UV_mean_wc_family));
d_colors_ag$UV_sd_wc_family_r    <- as.numeric(scale(d_colors_ag$UV_sd_wc_family));
d_colors_ag$clim_PC1_r           <- as.numeric(scale(d_colors_ag$clim_PC1));
d_colors_ag$clim_PC2_r           <- as.numeric(scale(d_colors_ag$clim_PC2));
d_colors_ag$clim_PC3_r           <- as.numeric(scale(d_colors_ag$clim_PC3));
d_colors_ag$clim_PC1_family_r    <- as.numeric(scale(d_colors_ag$clim_PC1_family));
d_colors_ag$clim_PC2_family_r    <- as.numeric(scale(d_colors_ag$clim_PC2_family));
d_colors_ag$clim_PC3_family_r    <- as.numeric(scale(d_colors_ag$clim_PC3_family));
```

Following the pre-processing, we have the following versions of the data:

1. **`d_colors`**: the data containing all the existant and recently extinct languages, including duplicates (except for those where there are differences between dialects in the existence of a word for blue as reported in CLICS): `r nrow(d_colors)` datapoints, of which `r tmp <- table(d_colors$glottocode); sprintf("%d (%.1f%%)", sum(tmp>1), 100*sum(tmp>1)/length(tmp))` are languages (aka glottocodes) that appear at least twice in one or more databases (usually CLICS);

2. **`d_colors_ag`**: same as above, but with all the languages that appear in more than 1 database aggregated by taking the mean of the continuous variables (manual checking suggests that averaging is meaningful in these cases); please note that this aggregation is done with respect to the presence or not of a word for blue (i.e., we do not aggregate across varieties of the same language that have different values for this variable): there are `r nrow(d_colors_ag)` datapoints (i.e., an apparent loss of `r sprintf("%d (%.1f%%)", nrow(d_colors)-nrow(d_colors_ag), 100*(nrow(d_colors)-nrow(d_colors_ag))/nrow(d_colors))` datapoints that have extremely similar values for the variables of interest relative to the above);

3. **`d_colors_nona`** and 4. **`d_colors_ag_nona`**: variants of the above with all the entries with missing data in the variables of interest (subsistence, population size and climate) removed: there are `r nrow(d_colors_nona)` and `r nrow(d_colors_ag_nona)` datapoints, respectively, representing a loss of `r sprintf("%d (%.1f%%)", nrow(d_colors)-nrow(d_colors_nona), 100*(nrow(d_colors)-nrow(d_colors_nona))/nrow(d_colors))` and `r sprintf("%d (%.1f%%)", nrow(d_colors_ag)-nrow(d_colors_ag_nona), 100*(nrow(d_colors_ag)-nrow(d_colors_ag_nona))/nrow(d_colors))` datapoints relative to the corresponding databases above.

In the following analyses we will use the aggregated database `d_colors_ag`.


# Data

## Populations and languages

In our dataset, there are `r length(unique(d_colors_ag$glottocode))` populations, each uniquely identified by the [Glottolog](https://glottolog.org/) code (the *glottocode*) of the primary language they speak (the matching was done manually).


## Geographic location

The geographic coordinates of the populations were retrieved from the [Glottolog](https://glottolog.org/) based on their *glottocode*s.
As per @brown_color_2004, we computed the cosine of these *latitude*s and the *longitude*s to be used in the statistical models; while `cos(latitude)` captures the closeness to the equator and ranging between 0.0 (one of the poles) and 1.0 (the equator), we use here `1.0 - cos(latitude)` so that they are 0.0 at the equator and 1.0 at the poles, converting the "natural" interpretation of latitudes, and `cos(longitude)`range between -1.0 and 1.0 (corresponding to -180 and 180 degrees, respectively); 
please note that longitude can be coded (and plotted) either as ranging between 0° and 360°, or between -180° and +180°, when we need to avoid the International Date Line (IDL) producing an artefactual boundary.

In the following plot, we plot the geographic coordinates with a focus on Europe and India:

```{r populations map 2, fig.cap=capFig("Map of the populations in our sample (with language names and details for Europe and the Indian subcontinent).", TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=10, fig.width=11}
# Inset Europe:
submap_europe <- mapWorld[mapWorld$lat<70 & mapWorld$lat>36 & mapWorld$long>-20 & mapWorld$long<35,]
d_colors_europe <- d_colors_ag[d_colors_ag$latitude>36 & d_colors_ag$latitude<70 & d_colors_ag$longitude<35 & d_colors_ag$longitude>-20,]
europe <- ggplot() + theme_bw() +
  geom_polygon(data=submap_europe, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_europe, aes(x=longitude, y=latitude), color="black") +
  geom_label_repel(data=d_colors_europe, aes(x=longitude, y=latitude, label=glottocode), color="blue", fill="lightyellow", alpha=0.75, size=2.75, label.padding=0.10, label.r=0.05) + 
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  NULL;

# Inset India:
submap_india <- mapWorld[mapWorld$lat>5 & mapWorld$lat<33& mapWorld$long>58 & mapWorld$long<99 ,]
d_colors_india <- d_colors_ag[d_colors_ag$latitude>5 & d_colors_ag$latitude<33 & d_colors_ag$longitude>58 & d_colors_ag$longitude<99,]
india <- ggplot() + theme_bw() +
  geom_polygon(data=submap_india, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_india, aes(x=longitude, y=latitude), color="black") +
  geom_label_repel(data=d_colors_india, aes(x=longitude, y=latitude, label=glottocode), color="blue", fill="lightyellow", alpha=0.75, size=2.75, label.padding=0.10, label.r=0.05) + 
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  NULL;

# World map:
d_colors_all <- d_colors_ag[!(d_colors_ag$latitude>36 & d_colors_ag$latitude<70 & d_colors_ag$longitude<35 & d_colors_ag$longitude>-20) & !(d_colors_ag$latitude>5 & d_colors_ag$latitude<33 & d_colors_ag$longitude>58 & d_colors_ag$longitude<99),]

all <- ggplot() + theme_bw() +
  geom_rect(data=mapWorld, mapping=aes(xmin=-10, xmax=35, ymin=36, ymax=70), size=0.3, color="black", alpha=0.1) +
  geom_rect(data=mapWorld, mapping=aes(xmin=60, xmax=97, ymin=5, ymax=33),  size=0.3, color="black", alpha=0.1) +
  geom_polygon(data=mapWorld[mapWorld$lat>-60,], aes(x=long, y=lat, group=group), fill="grey", alpha=0.7) + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses +
  geom_point(data=d_colors_all, aes(x=longitude, y=latitude), color="black") +
  geom_label_repel(data=d_colors_all, aes(x=longitude, y=latitude, label=glottocode), color="blue", fill="lightyellow", alpha=0.75, size=2.75, label.padding=0.10, label.r=0.05) + 
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  NULL;

# Assemble the image:
grid.newpage(); # new page
pushViewport(viewport(layout = grid.layout(5, 2)));
define_region <- function(row, col){ viewport(layout.pos.row = row, layout.pos.col = col); } 
print(all,    vp = define_region(1:3, 1:2));
print(europe, vp = define_region(4:5, 1));
print(india,  vp = define_region(4:5, 2));
```

```{r geographic location transform, fig.cap=capFig("Relationship between raw and transformed values for latitude (left, blue) and longitude (right, red); please note that, as opposed to the map above, longitude was shifted so that longitudes > 180° are negative (i.e., centered on 0°).", TRUE, c("ggplot2"), is_map=FALSE), fig.height=4*1, fig.width=4*2}
grid.arrange(ggplot(data=d_colors_ag, aes(x=latitude, y=latitude_r),) + theme_bw() +
               xlab("Latitude (raw, in °, negative = south)") + ylab("Latitude transformed = 1 - cos(latitude)") +
               geom_point(alpha=0.5, color="blue") +
               NULL,
             ggplot(data=d_colors_ag, aes(x=longitude_180, y=longitude_r),) + theme_bw() +
               xlab("Longitude (raw, in °, negative = west)") + ylab("Longitude transformed = cos(longitude)") +
               geom_point(alpha=0.5, color="red") +
               NULL,
             ncol=2);
```


## Elevation

Most elevation data (altitude, in meters) was obtained using [Mapzen](https://en.wikipedia.org/wiki/Mapzen) data, which is still available (July 2022) on the [Terrain Tiles on Amazon Web Services](https://aws.amazon.com/public-datasets/terrain/) and accessible through the [`elevatr` package](https://cran.r-project.org/web/packages/elevatr/vignettes/introduction_to_elevatr.html#get_raster_elevation_data) in R, as a replication of the method used in @josserand_environment_2021 (see github [ddediu/colors-UV](https://github.com/ddediu/colors-UV/tree/master/input_files) for more information). However, a few datapoints were not correctly mapped using this method (below zero elevation). To complete this database, we used additional data from [Worldclim](https://www.worldclim.org/data/worldclim21.html) (derived from the SRTM elevation data; see `01_preprocess_file.R` for more details). Using both the first method (get_elev_raster) and the second method (Worldclim), some data was still missing (20 datapoints): the elevation of the remaining datapoints was manually coded using [Google Earth](https://earth.google.com/web/). 
Please note that for the analyses, we use `log(elevation + 1)` (we added 1m to avoid errors for the locations recorded at sea level, 0m).

```{r summary elevation}
pander(summary(d_colors_ag$elevation)); cat("SD = ", round(sd(d_colors_ag$elevation, na.rm=TRUE),1), "IQR = ", round(IQR(d_colors_ag$elevation, na.rm=TRUE),1),"\n");
```

```{r distribution of elevation, fig.cap=capFig("Distribution of elevation.", TRUE, c("ggplot2"), is_map=FALSE)}
ggplot(d_colors_ag, aes(x=elevation)) +
  theme_bw() +
  geom_histogram(color="tomato", fill="tomato", alpha=0.5)+
  ggtitle("Distribution of elevation") +
  theme(plot.title = element_text(size = 10, face = "bold")); 
```

```{r map elevation, fig.cap=capFig("Map of elevation (color scale).", TRUE, c("ggplot2"), is_map=TRUE)}
ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=elevation), color="black", fill="lightyellow", alpha=0.75, size=2.75, label.padding=0.10, label.r=0.05) + 
  geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=elevation), color="black") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "Elevation (m)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
  NULL;
```

```{r elevation transform, fig.cap=capFig("Relationship between raw and transformed values for elevation.", TRUE, c("ggplot2"), is_map=FALSE), fig.height=4*1, fig.width=4*1}
ggplot(data=d_colors_ag, aes(x=elevation, y=elevation_r),) + theme_bw() +
  xlab("Elevation (raw, in meters)") + ylab("Elevation transformed = log(elevation + 1)") +
  geom_point(alpha=0.5, color="blue") +
  NULL;
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=elevation), color="black") +
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=round(elevation,0)), color="black", fill="yellow", alpha=0.5, size=2.75, label.padding=0.10, label.r=0.05, max.overlaps=15) + 
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "Elevation") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="Elevation") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=elevation)) +
  theme_bw() +
  geom_histogram(color="navyblue", fill="lightskyblue1", alpha=0.5)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_elevation";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```

## Climate and ecology 
We reused the code from @bentz_evolution_2018 to extract historical data on global weather and climate from [WorldClim](https://www.worldclim.org/) (version 1.4, now obsolete) for the period 1960-1990, encoded in 19 variables covering various measures (such as temperature, seasonality or precipitation). 
As in @bentz_evolution_2018, we conduced a Principal Component Analysis (PCA) for our data only, and we found similar results, namely that the first two principal components (PCs) explain most of the data and have meaningful interpretations: the PC1 explains 53.9% of the variance and reflects low seasonality, wet and hot climate, whereas PC2 explains 23.3% of the variance and reflects high seasonality, hot and dry climate; PC3 explains only 7.1% and its interpretation is less straightforward; see @bentz_evolution_2018 for details (please note that the sign of the PCs is arbitrary). 
For the analyses, these variables were z-scored (thus, the relationship between raw and transformed values is linear).


### Climate PC1

```{r summary PC1}
# Climate PC1
pander(summary(d_colors_ag$clim_PC1))
```

```{r distribution of PC1, fig.cap=capFig("Distribution of climate PC1.", TRUE, c("ggplot2"), is_map=FALSE)}
ggplot(d_colors_ag, aes(x=clim_PC1)) + 
  theme_bw() +
  geom_density(color="tomato", fill="tomato", alpha=0.5)+
  ggtitle("Distribution of climate PC1") +
  theme(plot.title = element_text(size = 10, face = "bold")); 
```

```{r map PC1, fig.cap=capFig("Map of climate PC1 (color scale).", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=clim_PC1), color="black") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "Climate PC1") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
  NULL;
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=clim_PC1), color="black") +
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "PC1") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="PC1") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=clim_PC1)) +
  theme_bw() +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.5)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_climate_pc1";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```

### Climate PC2

```{r summary PC2}
# Climate PC2
pander(summary(d_colors_ag$clim_PC2))
```

```{r distribution of PC2, fig.cap=capFig("Distribution of climate PC2.", TRUE, c("ggplot2"), is_map=FALSE)}
ggplot(d_colors_ag, aes(x=clim_PC2)) + 
  theme_bw() +
  geom_density(color="tomato", fill="tomato", alpha=0.5)+
  ggtitle("Distribution of climate PC2") +
  theme(plot.title = element_text(size = 10, face = "bold")); 
```

```{r map PC2, fig.cap=capFig("Map of climate PC2 (color scale).", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=clim_PC2), color="black") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "Climate PC2") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
  NULL;
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=clim_PC2), color="black") +
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "PC2") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="PC2") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=clim_PC2)) +
  theme_bw() +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.5)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_climate_pc2";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```

### Climate PC3

```{r summary PC3}
# Climate PC3
pander(summary(d_colors_ag$clim_PC3))
```

```{r distribution of PC3, fig.cap=capFig("Distribution of climate PC3.", TRUE, c("ggplot2"), is_map=FALSE)}
ggplot(d_colors_ag, aes(x=clim_PC3)) + 
  theme_bw() +
  geom_density(color="tomato", fill="tomato", alpha=0.5)+
  ggtitle("Distribution of climate PC3") +
  theme(plot.title = element_text(size = 10, face = "bold")); 
```

```{r map PC3, fig.cap=capFig("Map of climate PC3 (color scale).", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=clim_PC3), color="black") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "Climate PC3") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
  NULL;
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=clim_PC3), color="black") +
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "PC3") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="PC3") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=clim_PC3)) +
  theme_bw() +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.5)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_climate_pc3";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```


## Humidity 

We obtained specific humidity ("the mass of water vapour in a unit mass of moist air, usually expressed as grams of vapour per kilogram of air"; [Encyclopaedia Britannica](https://www.britannica.com/science/specific-humidity)) data from the [NOAA](http://iridl.ldeo.columbia.edu/SOURCES/.NOAA/.NCEP-NCAR/.CDAS-1/.MONTHLY/.Diagnostic/.above_ground/.qa/datafiles.html), given as monthly extractions between 1 January 1949 and the download date, and we computed the overall mean, median, standard deviation and IQR across all measurements, as well as the mean across the yearly means, medians, standard deviations and IQRs.
However, all these measures are highly correlated by type (see plots below), such that we only retain here the mean of the yearly medians and IQRs.
We did not transform these variables for the analyses.

```{r echo=FALSE, message=FALSE, fig.cap=capFig("Pairwise correlations between measures of central tendency for humidity.", TRUE, NULL, is_map=FALSE), fig.width=8, fig.height=8}
pairs(d_humidity[,c("humidity_overall_mean", "humidity_overall_median", "humidity_mean_annual_mean", "humidity_mean_annual_median")], 
      lower.panel=panel.cor, diag.panel=panel.hist, upper.panel=upper.panel); 
```

```{r echo=FALSE, message=FALSE, fig.cap=capFig("Pairwise correlations between measures of dispersion for humidity.", TRUE, NULL, is_map=FALSE), fig.width=8, fig.height=8}
pairs(d_humidity[,c("humidity_overall_sd", "humidity_overall_IQR", "humidity_mean_annual_sd", "humidity_mean_annual_IQR")], 
      lower.panel=panel.cor, diag.panel=panel.hist, upper.panel=upper.panel); 
```

### Median (mean of yearly medians)

```{r summary median humidity}
pander(summary(d_colors_ag$hum_median)); cat("SD = ", sd(d_colors_ag$hum_median, na.rm=TRUE), "IQR = ", IQR(d_colors_ag$hum_median, na.rm=TRUE),"\n");
```

```{r distribution of median humidity, fig.cap=capFig("Distribution of median humidity.", TRUE, c("ggplot2"), is_map=FALSE)}
ggplot(d_colors_ag, aes(x=hum_median)) + 
  theme_bw() +
  geom_density(color="tomato", fill="tomato", alpha=0.5)+
  ggtitle("Distribution of median humidity") +
  theme(plot.title = element_text(size = 10, face = "bold")); 
```

```{r map median humidity, fig.cap=capFig("Map of median humidity (color scale).", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=hum_median), color="black") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "Median humidity") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
  NULL;
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=hum_median), color="black") +
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "Hum (med)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="Hum (med)") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=hum_median)) +
  theme_bw() +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.5)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_humidity_median";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```

### Variation (mean of yearly IQRs)

```{r summary IQR humidity}
pander(summary(d_colors_ag$hum_IQR)); cat("SD = ", sd(d_colors_ag$hum_IQR, na.rm=TRUE), "IQR = ", IQR(d_colors_ag$hum_IQR, na.rm=TRUE),"\n");
```

```{r distribution of IQR humidity, fig.cap=capFig("Distribution of variation in humidity (IQR).", TRUE, c("ggplot2"), is_map=FALSE)}
ggplot(d_colors_ag, aes(x=hum_IQR)) + 
  theme_bw() +
  geom_density(color="tomato", fill="tomato", alpha=0.5)+
  ggtitle("Distribution of variation in humidity (IQR)") +
  theme(plot.title = element_text(size = 10, face = "bold")); 
```

```{r map IQR humidity, fig.cap=capFig("Map of variation in humidity (IQR) (color scale).", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=hum_IQR), color="black") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "IQR humidity") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
  NULL;
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=hum_IQR), color="black") +
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "Hum (var)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="Hum (var)") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=hum_IQR)) +
  theme_bw() +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.5)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_humidity_iqr";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```


## Distance to bodies of water

We reused the code from @bentz_evolution_2018 to compute the distances from each of our populations to the nearest lake, ocean, river, and water in general, using [OpenStreetMap](http://openstreetmapdata.com/) raster files[^openstreetmaps]. 
For the analyses, we use the `log` of these distances.

```{r distance to water transform, fig.cap=capFig("Relationship between raw and transformed values for distance to large bodies of water. For left to right and top to bottom, distances to: lakes, rivers, oceans and water in general.", TRUE, c("ggplot2"), is_map=FALSE), fig.height=4*2, fig.width=4*2}
grid.arrange(ggplot(data=d_colors_ag, aes(x=dist2lakes, y=dist2lakes_r)) + theme_bw() +
               xlab("Distance to lakes (raw, in Km)") + ylab("Distance transformed = log(distance)") +
               geom_point(alpha=0.5, color="blue") +
               NULL,
             ggplot(data=d_colors_ag, aes(x=dist2rivers, y=dist2rivers_r)) + theme_bw() +
               xlab("Distance to rivers (raw, in Km)") + ylab("Distance transformed = log(distance)") +
               geom_point(alpha=0.5, color="blue") +
               NULL,
             ggplot(data=d_colors_ag, aes(x=dist2ocean, y=dist2ocean_r)) + theme_bw() +
               xlab("Distance to ocean/sea (raw, in Km)") + ylab("Distance transformed = log(distance)") +
               geom_point(alpha=0.5, color="blue") +
               NULL,
             ggplot(data=d_colors_ag, aes(x=dist2water, y=dist2water_r)) + theme_bw() +
               xlab("Distance to water (raw, in Km)") + ylab("Distance transformed = log(distance)") +
               geom_point(alpha=0.5, color="blue") +
               NULL,
             ncol=2);
```

[^openstreetmaps]: Unfortunately, the primary data from [OpenStreetMap](http://openstreetmapdata.com/), the ["Reduced waterbodies as raster masks"](http://openstreetmapdata.com/data/water-reduced-raster) seems to no longer be available for download as of July 2020, so we used here the original data downloaded in March 2018 by Dan Dediu and used in the @bentz_evolution_2018 paper.


### Distance to lakes

```{r summary dist lakes}
# Distance to lakes
pander(summary(d_colors_ag$dist2lakes)); cat("SD = ", round(sd(d_colors_ag$dist2lakes, na.rm=TRUE),1), "IQR = ", round(IQR(d_colors_ag$dist2lakes, na.rm=TRUE),1),"\n");
```

```{r distribution dist lakes, fig.cap=capFig("Distribution of distances to lakes.", TRUE, c("ggplot2"), is_map=FALSE)}
ggplot(d_colors_ag, aes(x=dist2lakes)) +
  theme_bw() +
  geom_density(color="tomato", fill="tomato", alpha=0.5)+
  #ggtitle("Distribution of distances to lakes") +
  xlab("Dist. to lakes (km)") + 
  theme(plot.title = element_text(size = 10, face = "bold")); 
```

```{r map dist lakes, fig.cap=capFig("Map of distances to lakes (color scale).", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
ggplot() + 
  theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=round(dist2lakes,0)), color="black", fill="lightyellow", alpha=0.75, size=2.75, label.padding=0.10, label.r=0.05) + 
  geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=dist2lakes), color="black") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "Dist. to lakes (km)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
  NULL;


ggplot() + 
  theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=round(dist2lakes_r,0)), color="black", fill="lightyellow", alpha=0.75, size=2.75, label.padding=0.10, label.r=0.05) + 
  geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=dist2lakes_r), color="black") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "log(dist. to lakes)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
  NULL;
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=dist2lakes_r), color="black") +
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=round(dist2lakes_r,1)), color="black", fill="yellow", alpha=0.5, size=2.75, label.padding=0.10, label.r=0.05, max.overlaps=10) + 
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "log(d2l)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="log(d2l)") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=dist2lakes_r)) +
  theme_bw() +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.5)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_dist2lake";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```

### Distance to rivers

```{r summary dist rivers}
# Distance to lakes
pander(summary(d_colors_ag$dist2rivers)); cat("SD = ", round(sd(d_colors_ag$dist2rivers, na.rm=TRUE),1), "IQR = ", round(IQR(d_colors_ag$dist2rivers, na.rm=TRUE),1),"\n");
```

```{r distribution dist rivers, fig.cap=capFig("Distribution of distances to rivers.", TRUE, c("ggplot2"), is_map=FALSE)}
ggplot(d_colors_ag, aes(x=dist2rivers)) + 
  theme_bw() +
  geom_density(color="tomato", fill="tomato", alpha=0.5)+
  #ggtitle("Distribution of log distance to rivers") +
  xlab("Dist. to rivers (km)") + 
  theme(plot.title = element_text(size = 10, face = "bold")); 
```

```{r map dist rivers, fig.cap=capFig("Map of distances to rivers (color scale).", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
ggplot() + 
  theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=round(dist2rivers,0)), color="black", fill="lightyellow", alpha=0.75, size=2.75, label.padding=0.10, label.r=0.05) + 
  geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=dist2rivers), color="black") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "Dist. to rivers (km)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
  NULL;
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=dist2rivers_r), color="black") +
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=round(dist2rivers_r,1)), color="black", fill="yellow", alpha=0.5, size=2.75, label.padding=0.10, label.r=0.05, max.overlaps=10) + 
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "log(d2r)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="log(d2r)") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=dist2rivers_r)) +
  theme_bw() +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.5)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_dist2river";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```


### Distance to oceans

```{r summary dist oceans}
# Distance to oceans
pander(summary(d_colors_ag$dist2ocean)); cat("SD = ", round(sd(d_colors_ag$dist2ocean, na.rm=TRUE),1), "IQR = ", round(IQR(d_colors_ag$dist2ocean, na.rm=TRUE),1),"\n");
```

```{r distribution dist oceans, fig.cap=capFig("Distribution of distances to oceans.", TRUE, c("ggplot2"), is_map=FALSE)}
ggplot(d_colors_ag, aes(x=dist2ocean)) + 
  theme_bw() +
  geom_density(color="tomato", fill="tomato", alpha=0.5)+
  #ggtitle("Distribution of log distance to oceans") +
  xlab("Dist. to oceans (km)") + 
  theme(plot.title = element_text(size = 10, face = "bold")); 
```

```{r map dist oceans, fig.cap=capFig("Map of distances to oceans (color scale).", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
ggplot() + 
  theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=round(dist2ocean,0)), color="black", fill="lightyellow", alpha=0.75, size=2.75, label.padding=0.10, label.r=0.05) + 
  geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=dist2ocean), color="black") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "Dist. to oceans (km)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
  NULL;
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=dist2ocean_r), color="black") +
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=round(dist2ocean_r,1)), color="black", fill="yellow", alpha=0.5, size=2.75, label.padding=0.10, label.r=0.05, max.overlaps=10) + 
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "log(d2o)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="log(d2o)") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=dist2ocean_r)) +
  theme_bw() +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.5)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_dist2ocean";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```

### Distance to water

```{r summary dist water}
# Distance to water
pander(summary(d_colors_ag$dist2water)); cat("SD = ", round(sd(d_colors_ag$dist2water, na.rm=TRUE),1), "IQR = ", round(IQR(d_colors_ag$dist2water, na.rm=TRUE),1),"\n");
```

```{r distribution dist water, fig.cap=capFig("Distribution of distances to water.", TRUE, c("ggplot2"), is_map=FALSE)}
ggplot(d_colors_ag, aes(x=dist2water)) + 
  theme_bw() +
  geom_density(color="tomato", fill="tomato", alpha=0.5)+
  #ggtitle("Distribution of log distance to v") +
  xlab("log dist water (km)") + 
  theme(plot.title = element_text(size = 10, face = "bold")); 
```

```{r map dist water, fig.cap=capFig("Map of distances to water (color scale).", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
ggplot() + 
  theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=round(dist2water,0)), color="black", fill="lightyellow", alpha=0.75, size=2.75, label.padding=0.10, label.r=0.05) + 
  geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=dist2water), color="black") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "Dist. to water (km)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
  NULL;
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=dist2water_r), color="black") +
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=round(dist2water_r,1)), color="black", fill="yellow", alpha=0.5, size=2.75, label.padding=0.10, label.r=0.05, max.overlaps=10) + 
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "log(d2w)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="log(d2w)") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=dist2water_r)) +
  theme_bw() +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.5)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_dist2water";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```


## UV incidence

We used two different databases for UV incidence:

 - one database coming from [NASA](https://disc.gsfc.nasa.gov/);
 - one database coming from [Worldclim](https://www.worldclim.org/data/worldclim21.html)


### UV from TOMS

This data comes from *TOMS Nimbus-7 UV-B Erythemal Local Noon Irradiance Monthly*, which shows the local noon erythemal UV irradiance values (monthly averaged), in mW/m^2^. Two datasets covering different time range are used: 

 - this [dataset](https://disc.gsfc.nasa.gov/datasets/TOMSN7L3mery_008/summary?keywords=erythemal%20uv) from 1978-11-01 to 1993-05-01 
 - this [dataset](https://disc.gsfc.nasa.gov/datasets/TOMSEPL3mery_008/summary?keywords=erythemal%20uv) from 1996-08-01 to 2003-09-01 

It covers a total of 22 years, with a break between 1993 and 1996. Here, we computed the *mean* for all years and the *standard deviation* (first by aggregating the data by months, and then by applying the standard deviation on the averaged value of all months) for each location. This data shows the **erythemal UV**, which is the amount of UV radiation received by the human body, taking into account the thickness of the ozone layer in the stratosphere, the amount of cloud cover, the elevation, and how high the sun is in the sky. Finally, these were further z-scored for the statistical analyses (thus, the relationship between raw and transformed values is linear).

Note: on the previous analysis from the paper *Environment and culture shape both the colour lexicon and the genetic of colour perception*, we had also used [NASA Total Ozone Mapping Spectrometer (TOMS)](http://toms.gsfc.nasa.gov/ery_uv/new_uv/) data. However, there are two differences: first, the data from the previous paper was collected only for the year 1998, in order to replicate the procedure in @brown_color_2004. Second, we had used a different NASA database and the previous data was in (J/m^2^) and covering several UV wavelength. 

Number of data points: `r sprintf("%d (%.1f%%)", sum(!is.na(d_colors_ag$UV_mean)), 100*sum(!is.na(d_colors_ag$UV_mean))/nrow(d_colors_ag))`.

Summaries for mean UV:
```{r}
pander(summary(d_colors_ag$UV_mean)); cat("SD = ", round(sd(d_colors_ag$UV_mean, na.rm=TRUE),1), "IQR = ", round(IQR(d_colors_ag$UV_mean, na.rm=TRUE),1),"\n");
```

Summaries for sd UV:
```{r}
pander(summary(d_colors_ag$UV_sd)); cat("SD = ", round(sd(d_colors_ag$UV_sd, na.rm=TRUE),1), "IQR = ", round(IQR(d_colors_ag$UV_sd, na.rm=TRUE),1),"\n");
```

```{r fig.cap=capFig("UV from TOMS (mean and standard deviation).", TRUE, c("ggplot2"), is_map=FALSE)}
grid.arrange(ggplot(d_colors_ag, aes(x=UV_mean)) + 
               theme_bw() +
               geom_density(color="tomato", fill="tomato", alpha=0.5)+
               ggtitle("Distribution of mean UV (TOMS)") +
               theme(plot.title = element_text(size = 10, face = "bold")),
             ggplot(d_colors_ag, aes(x=UV_sd)) + 
               theme_bw() +
               geom_density(color="tomato", fill="tomato", alpha=0.5)+
               ggtitle("Distribution of sd UV (TOMS)") +
               theme(plot.title = element_text(size = 10, face = "bold")),
             ncol=2);
```

```{r map UV-A, fig.cap=capFig("Map of UV from TOMS (mean and standard deviation).", TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=12}
grid.arrange(ggplot() + theme_bw() +
               geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
               geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=UV_mean), color="black") +
               theme(legend.position = c(0.75, 0.5), 
                     legend.justification = c(1, 1), 
                     legend.title = element_text(size = 9), 
                     legend.text = element_text(size = 10)) +
               labs(fill = "Mean UV (TOMS)") +
               scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
               NULL,
             ggplot() + theme_bw() +
               geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
               geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=UV_sd), color="black") +
               theme(legend.position = c(0.75, 0.5), 
                     legend.justification = c(1, 1), 
                     legend.title = element_text(size = 9), 
                     legend.text = element_text(size = 10)) +
               labs(fill = "SD UV (TOMS)") +
               scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
               NULL,
             ncol=1);
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=UV_mean), color="black") +
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "Mean UV") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="Mean UV") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=UV_mean)) + 
  theme_bw() + xlab("Mean UV") +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.75)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_uv_mean_toms";
png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
#jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();


pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=UV_sd), color="black") +
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "sd UV") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="sd UV") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=UV_sd)) + 
  theme_bw() + xlab("sd UV") +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.75)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_uv_sd_toms";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```

### UV from Worldclim

We extracted the solar radiation (kJ m^-2^ day^-1^) data from [Worldclim](https://www.worldclim.org/data/worldclim21.html). This data contains the average top-of-atmosphere incident solar radiation (calculated from latitude) per month for the years 1970-2000. We computed the *mean* and the *standard deviation* of all months for each location. 
Please note that even if *WorldClim* data concern solar radiation and not UV-B specifically, for consistency with the *TOMS* data we will also denote the *WorldClim*-related variables as *UV*.

Number of data points: `r sprintf("%d (%.1f%%)", sum(!is.na(d_colors_ag$UV_mean_wc)), 100*sum(!is.na(d_colors_ag$UV_mean_wc))/nrow(d_colors_ag))`.

Summaries for mean UV:
```{r}
pander(summary(d_colors_ag$UV_mean_wc)); cat("SD = ", round(sd(d_colors_ag$UV_mean_wc, na.rm=TRUE),1), "IQR = ", round(IQR(d_colors_ag$UV_mean_wc, na.rm=TRUE),1),"\n");
```

Summaries for sd UV:
```{r}
pander(summary(d_colors_ag$UV_sd_wc)); cat("SD = ", round(sd(d_colors_ag$UV_sd_wc, na.rm=TRUE),1), "IQR = ", round(IQR(d_colors_ag$UV_sd_wc, na.rm=TRUE),1),"\n");
```

```{r fig.cap=capFig("UV from Worldclim (mean and standard deviation).", TRUE, c("ggplot2"), is_map=FALSE)}
grid.arrange(ggplot(d_colors_ag, aes(x=UV_mean_wc)) + 
               theme_bw() +
               geom_density(color="tomato", fill="tomato", alpha=0.5)+
               ggtitle("Distribution of mean UV (Worldclim)") +
               theme(plot.title = element_text(size = 10, face = "bold")),
             ggplot(d_colors_ag, aes(x=UV_sd_wc)) + 
               theme_bw() +
               geom_density(color="tomato", fill="tomato", alpha=0.5)+
               ggtitle("Distribution of sd UV (Worldclim)") +
               theme(plot.title = element_text(size = 10, face = "bold")),
             ncol=2);

```

```{r map UV-B, fig.cap=capFig("Map of UV from Worldclim (mean and standard deviation).", TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=12}
grid.arrange(ggplot() + theme_bw() +
               geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
               geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=UV_mean_wc), color="black") +
               theme(legend.position = c(0.75, 0.5), 
                     legend.justification = c(1, 1), 
                     legend.title = element_text(size = 9), 
                     legend.text = element_text(size = 10)) +
               labs(fill = "Mean UV (Worldclim)") +
               scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
               NULL,
             ggplot() + theme_bw() +
               geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
               geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=UV_sd_wc), color="black") +
               theme(legend.position = c(0.75, 0.5), 
                     legend.justification = c(1, 1), 
                     legend.title = element_text(size = 9), 
                     legend.text = element_text(size = 10)) +
               labs(fill = "SD UV (Worldclim)") +
               scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
               NULL,
             ncol=1);
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=UV_mean_wc), color="black") +
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "Mean UV") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="Mean UV") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=UV_mean_wc)) + 
  theme_bw() + xlab("Mean UV") +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.75)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_uv_mean_wc";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();


pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=UV_sd_wc), color="black") +
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "sd UV") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="sd UV") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=UV_sd_wc)) + 
  theme_bw() + xlab("sd UV") +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.75)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_uv_sd_wc";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```


### Relationship between TOMS and WorldClim

Correlations:

- *means*: `r sprintf("Pearson's *r*=%.2f, *p*=%.3g", (r <- cor.test(d_colors_ag$UV_mean, d_colors_ag$UV_mean_wc))$estimate, r$p.value)`; `r sprintf("Spearman's *rho*=%.2f, *p*=%.3g", (r <- cor.test(d_colors_ag$UV_mean, d_colors_ag$UV_mean_wc, method="spearman"))$estimate, r$p.value)`
- *sds*: `r sprintf("Pearson's *r*=%.2f, *p*=%.3g", (r <- cor.test(d_colors_ag$UV_sd, d_colors_ag$UV_sd_wc))$estimate, r$p.value)`; `r sprintf("Spearman's *rho*=%.2f, *p*=%.3g", (r <- cor.test(d_colors_ag$UV_sd, d_colors_ag$UV_sd_wc, method="spearman"))$estimate, r$p.value)`

```{r fig.width=7, fig.height=14, fig.cap=capFig("Relationship between UV incidence from the two databases.")}
grid.arrange(ggplot(d_colors_ag, aes(x=UV_mean, y=UV_mean_wc)) + 
               xlab("UV mean (TOMS)") + ylab("UV mean (WorldClim)") +
               geom_point() + 
               geom_smooth(method="lm", color="blue") +
               geom_smooth(method="loess", color="red") + 
               ggtitle("Means"),
             ggplot(d_colors_ag, aes(x=UV_sd, y=UV_sd_wc)) + 
               xlab("UV sd (TOMS)") + ylab("UV sd (WorldClim)") +
               geom_point() + 
               geom_smooth(method="lm", color="blue") +
               geom_smooth(method="loess", color="red") + 
               ggtitle("Standard deviations"),
             ncol=1);
```

```{r include=FALSE}
# figure for paper:
file_name <- "fig_uv_toms_vs_wc";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
grid.arrange(ggplot(d_colors_ag, aes(x=UV_mean, y=UV_mean_wc)) + 
               xlab("TOMS (mW/m"^"2"~")") + ylab("WorldClim (kJ/m"^"2"~"day)") +
               geom_point(size=0.75, alpha=0.5) + 
               geom_smooth(method="lm", color="blue") +
               geom_smooth(method="loess", color="red") + 
               ggtitle("Mean UV-B incidence"),
             ggplot(d_colors_ag, aes(x=UV_sd, y=UV_sd_wc)) + 
               xlab("TOMS (mW/m"^"2"~")") + ylab("WorldClim (kJ/m"^"2"~"day)") +
               geom_point(size=0.75, alpha=0.5) + 
               geom_smooth(method="lm", color="blue") +
               geom_smooth(method="loess", color="red") + 
               ggtitle("SD of UV-B incidence"),
             ncol=2)
dev.off();
```

So, while they seem pretty similar and highly correlated, there are also differences between them (especially in the high mean/low sd regions), so we decided to include them separately in the analyses.

However, we should note that the TOMS data is *a priori* more appropriate for testing the lens brunescence hypothesis than the WorldClim data, as it contains the erythemal UV (i.e., the UV radiation actually received by the human body and, in particular, hitting the eye).


### Relationship between mean and sd UV

Correlations:

- *TOMS*: `r sprintf("Pearson's *r*=%.2f, *p*=%.3g", (r <- cor.test(d_colors_ag$UV_mean, d_colors_ag$UV_sd))$estimate, r$p.value)`; `r sprintf("Spearman's *rho*=%.2f, *p*=%.3g", (r <- cor.test(d_colors_ag$UV_mean, d_colors_ag$UV_sd, method="spearman"))$estimate, r$p.value)`
- *WorldClim*: `r sprintf("Pearson's *r*=%.2f, *p*=%.3g", (r <- cor.test(d_colors_ag$UV_mean_wc, d_colors_ag$UV_sd_wc))$estimate, r$p.value)`; `r sprintf("Spearman's *rho*=%.2f, *p*=%.3g", (r <- cor.test(d_colors_ag$UV_mean_wc, d_colors_ag$UV_sd_wc, method="spearman"))$estimate, r$p.value)`

```{r fig.width=7, fig.height=14, fig.cap=capFig("Relationship between mean and sd of the UV incidence per databases.")}
grid.arrange(ggplot(d_colors_ag, aes(x=UV_mean, y=UV_sd)) + 
               xlab("UV mean") + ylab("UV sd") +
               geom_point() + 
               geom_smooth(method="lm", color="blue") +
               geom_smooth(method="loess", color="red") + 
               ggtitle("TOMS"),
             ggplot(d_colors_ag, aes(x=UV_mean_wc, y=UV_sd_wc)) + 
               xlab("UV mean") + ylab("UV sd") +
               geom_point() + 
               geom_smooth(method="lm", color="blue") +
               geom_smooth(method="loess", color="red") + 
               ggtitle("WorldClim"),
             ncol=1);
```

```{r include=FALSE}
# figure for paper:
file_name <- "fig_uv_mean_vs_sd";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
grid.arrange(ggplot(d_colors_ag, aes(x=UV_mean, y=UV_sd)) + 
               xlab("UV mean (mW/m"^"2"~")") + ylab("UV sd (mW/m"^"2"~")") +
               geom_point(size=0.75, alpha=0.5) + 
               geom_smooth(method="lm", color="blue") +
               geom_smooth(method="loess", color="red") + 
               ggtitle("TOMS"),
             ggplot(d_colors_ag, aes(x=UV_mean_wc, y=UV_sd_wc)) + 
               xlab("UV mean (kJ/m"^"2"~"day)") + ylab("UV sd (kJ/m"^"2"~"day)") +
               geom_point(size=0.75, alpha=0.5) + 
               geom_smooth(method="lm", color="blue") +
               geom_smooth(method="loess", color="red") + 
               ggtitle("WorldClim"),
             ncol=2)
dev.off();
```

So, as expected, there is an inverse relationship between UV mean and sd incidence in the two databases.


## Population size

Information on population size was collected from two sources (and stred in two columns, 'Ethnologue' and 'Wiki', respectively):
 
  1. using the information given by [Glottolog](https://glottolog.org/): from there, we accessed [Multitree](http://www.multitree.org/)'s denotations part, where the number of speakers is given. We always used the "total across all countries", if available, with the exception of Spanish, Portuguese, French and English, were we used the numbers only for Spain, Portugal, France, and the UK, respectively.
      
  2. using the information from [Wikipedia](https://en.wikipedia.org/wiki/Main_Page)/[Wikidata](https://www.wikidata.org/wiki/Wikidata:Main_Page), accessed from [Glottolog](https://glottolog.org/): ff several numbers were given, we chose according to the following criteria: (a) the number that has the most references, (b) the source of the number was the most recent, and (c) if two numbers have the same number of reference and from the same year(s), we chose the larger one. We used preferentially Wikidata over Wikipedia.
      
After this procedure, a lot of data were still missing (from both sources). Therefore, when actual data was present in one column only, we copied the information into the other one. 
For the analyses, we use the `log+1` of these numbers. 
To summarize, the two columns present in our databases are the following:

 - `log_popSize_wiki`: mostly data from Wikipedia/Wikidata, but occasionally data from Ethnologue when missing data
 - `log_popSize_ethno`: mostly data from Ethnologue, but occasionally data from Wikipedia/Wikidata when missing data
    
We applied this method for all data except the data for the `log_popSize_ethno` coming from the previous paper *Environment and culture shape both the colour lexicon and the genetic of colour perception*; for these populations, we used the same data as in that paper, based on @bentz_evolution_2018 (which, in turn, is based on the Ethnologue). 

Please note that, during this process, we identified a number of languages for which the population sizes reported by these two sources differed by at least one order of magnitude.
Further manual investigation using data from the latest free version of *Ethnologue* (accessed through the [WayBackMachine](https://archive.org/web/), in particular we used the snapshot from 6/1/2013), confirms that for 10 languages (kurd1259, nepa1254, alba1267, basq1248, tzot1259, mari1278, erzy1239, rian1262, hadz1240, and saya1246) there are genuine errors, which we fixed using the `scirep_paper/updates.csv` file (please note that, as these data come as `log(x+1)`, we likewise used the `log(x+1)` for the corrected data as well). 
For another 29 languages, the differences seem to be genuine as they may refer to different years (especially important for endangered languages) or to different categories (e.g., native speakers vs ethnic labels) -- we did not modify these data.

### Based on Ethnologue

There are `r sprintf("%d (%.1f%%)", sum(!is.na(d_colors_ag$log_popSize_ethno)), 100*sum(!is.na(d_colors_ag$log_popSize_ethno))/nrow(d_colors_ag))` data points with population size info.

```{r summary log_popSize_ethno}
# population size
pander(summary((x <- (exp(d_colors_ag$log_popSize_ethno)-1)/10000)));  cat("SD = ", round(sd(x, na.rm=TRUE),1), "IQR = ", round(IQR(x, na.rm=TRUE),1),"\n");
```

```{r distribution popsize ethnologue, fig.cap=capFig("Log population size.", TRUE, c("ggplot2"), is_map=FALSE)}
ggplot(d_colors_ag, aes(x=log_popSize_ethno)) + 
  theme_bw() +
  geom_density(color="tomato", fill="tomato", alpha=0.5)+
  #ggtitle("Distribution of population size (log)") +
  theme(plot.title = element_text(size = 10, face = "bold")); 
```

```{r map popsize ethnologue, fig.cap=capFig("Map of log population size.", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=round(log_popSize_ethno,1)), color="black", fill="lightyellow", alpha=0.75, size=2.75, label.padding=0.10, label.r=0.05) + 
  geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=log_popSize_ethno), color="black") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "Log(pop. size)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
  NULL;
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=log_popSize_ethno), color="black") +
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=round(log_popSize_ethno,1)), color="black", fill="yellow", alpha=0.5, size=2.75, label.padding=0.10, label.r=0.05, max.overlaps=10) + 
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "log(psize)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="log(psize)") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=log_popSize_ethno)) +
  theme_bw() +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.5)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_popsize_ethno";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```

### Based on Wikipedia/Wikidata

There are `r sprintf("%d (%.1f%%)", sum(!is.na(d_colors_ag$log_popSize_wiki)), 100*sum(!is.na(d_colors_ag$log_popSize_wiki))/nrow(d_colors_ag))` data points with population size info.

```{r summary log_popSize_wiki}
# population size
pander(summary((x <- (exp(d_colors_ag$log_popSize_wiki)-1)/10000)));  cat("SD = ", round(sd(x, na.rm=TRUE),1), "IQR = ", round(IQR(x, na.rm=TRUE),1),"\n");
```

```{r distribution popsize wikipedia, fig.cap=capFig("Log population size.", TRUE, c("ggplot2"), is_map=FALSE)}
ggplot(d_colors_ag, aes(x=log_popSize_wiki)) + 
  theme_bw() +
  geom_density(color="tomato", fill="tomato", alpha=0.5)+
  #ggtitle("Distribution of population size (log)") +
  theme(plot.title = element_text(size = 10, face = "bold")); 
```

```{r map popsize wikipedia, fig.cap=capFig("Map of log population size.", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=round(log_popSize_wiki,1)), color="black", fill="lightyellow", alpha=0.75, size=2.75, label.padding=0.10, label.r=0.05) + 
  geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=log_popSize_wiki), color="black") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "Log(pop. size)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue") + 
  NULL;
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, size=0.90, shape=21, aes(x=longitude, y=latitude, fill=log_popSize_wiki), color="black") +
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=round(log_popSize_wiki,1)), color="black", fill="yellow", alpha=0.5, size=2.75, label.padding=0.10, label.r=0.05, max.overlaps=10) + 
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(fill = "log(psize)") +
  scale_fill_gradient(low = "lightskyblue1", high = "navyblue", name="log(psize)") + 
  NULL;
pinset <- ggplot(d_colors_ag, aes(x=log_popSize_wiki)) +
  theme_bw() +
  geom_density(color="navyblue", fill="lightskyblue1", alpha=0.5)+
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_popsize_wiki";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```

### Relationship between the two

```{r fig.cap=capFig(paste0("Relationship between log population size from the two sources. ", sprintf("Pearson's correlation *r*=%.2f, *p*=%.3g; Spearman's correlation *rho*=%.2f, *p*=%.3g", (r <- cor.test(d_colors_ag$log_popSize_wiki, d_colors_ag$log_popSize_ethno, method="pearson"))$estimate, r$p.value, (r <- cor.test(d_colors_ag$log_popSize_wiki, d_colors_ag$log_popSize_ethno, method="spearman"))$estimate, r$p.value)), TRUE, c("ggplot2"), is_map=FALSE)}
ggplot(d_colors_ag, aes(x=log_popSize_wiki, y=log_popSize_ethno)) + 
  xlab("Wikipedia") + ylab("Etnologue") +
  geom_point(alpha=0.25, color="black") + 
  #geom_smooth(method="loess", color="red") + 
  geom_smooth(method="lm", color="blue") + 
  NULL;
```

```{r include=FALSE}
# figure for paper:
p <- ggplot(d_colors_ag, aes(x=log_popSize_wiki, y=log_popSize_ethno)) + 
  xlab("log(population size [Wikipedia])") + ylab("log(population size [Etnologue])") +
  geom_point(alpha=0.25, color="black") + 
  #geom_smooth(method="loess", color="red") + 
  geom_smooth(method="lm", color="blue", size=0.5) + 
  NULL;

file_name <- "fig_popsize_ethno_vs_wiki";
#png(paste0("./paper/",file_name,".png"), width=4, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=4, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```


## Subsistence strategy

Subsistence strategy was obtained mainly from [AUTOTYP](http://www.autotyp.uzh.ch/) [@bickel_autotyp_2017] as coded in [@blasi_human_2019], supplemented with information from other databases such as [D-Place](https://d-place.org/) [@kirby_dplace_2016] and [Seshat](http://seshatdatabank.info/) [@turchin_seshat_2015], as well as various other websites: all information is available in the references in [mathjoss/replic_colors](https://github.com/mathjoss/replic_colors/tree/main/references/subsistence).
This is represented by the binary variable *subsistence* with values 'HG' for populations whose subsistence mode is based on hunting, fishing, gathering and/or foraging, and 'AGR' for populations with subsistence modes centered around food production. 
There are `r sprintf("%d (%.1f%%)", sum(!is.na(d_colors_ag$subsistence)), 100*sum(!is.na(d_colors_ag$subsistence))/nrow(d_colors_ag))` data points with subsistence info.

```{r summary subsistence}
pander(summary(d_colors_ag$subsistence))
```

```{r distribution subsistence, fig.cap=capFig("Subsistence strategy.", TRUE, c("ggplot2"), is_map=FALSE)}
ggplot(data=d_colors_ag[ !is.na(d_colors_ag$subsistence), ] )+
  theme_bw() +
  geom_bar(aes(x=as.factor(subsistence), fill=as.factor(subsistence)), alpha=0.75) + 
  labs(x="Subsistence strategy", fill="")+
  guides(fill=FALSE) +
  scale_fill_viridis_d()
```

```{r map subsistence, fig.cap=capFig("Map of subsistence strategy.", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data= d_colors_ag[ !is.na(d_colors_ag$subsistence), ], shape=21, aes(x = longitude, y = latitude, fill=subsistence), color="red") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "subsistence?") +
  scale_fill_viridis_d()
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag[ !is.na(d_colors_ag$subsistence), ], size=0.90, shape=21, aes(x=longitude, y=latitude, fill=subsistence), color="black") +
  ylim(-57, NA) + 
  theme(legend.position = c(0.715, 0.33), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  scale_fill_manual(values=c("HG"="yellow", "AGR"="darkgreen"), name="subsist") + 
  NULL;
pinset <- ggplot(data =d_colors_ag[ !is.na(d_colors_ag$subsistence), ])+
  theme_bw() + 
  geom_bar(aes(x=as.factor(subsistence), fill=as.factor(subsistence)), color="black", alpha=0.75) + 
  scale_fill_manual(values=c("HG"="yellow", "AGR"="darkgreen"), name="subsist") + 
  guides(fill=FALSE) + 
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_subsistence";
#png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```


## Color vocabulary

Here, we used only one variable, namely the *presence of a specific term for blue* (variable *exists_blue* with values "yes" or "no"). We collected this data using 3 different sources/methods:
    
 - the **previous database from @josserand_environment_2021's paper**: we re-used this database, which was obtained thanks to @brown_color_2004 (who generously accepted to share their database with us), and @meeussen_colour_2015, who collected additional information; for more information on the color vocabulary data included and their coding, please see @meeussen_colour_2015 's Master thesis, as well as @josserand_environment_2021;

 - the **CLICS database** [@rzymski_database_2020]: we first selected all the languages having a [concept for blue](https://clics.clld.org/parameters/837#1/21/1); then, we selected all populations for which the blue concept is colexified with the [concept for green](https://clics.clld.org/edges/837-1425) or any another colour, resulting in a column `colexification` which takes the values *none* (if the concept blue is not colexified), *green* (if the concept is colexified with green) concept, and "NameColor" (for example *green black* if the concept is colexified with green and black concepts). All the meta data from these populations (glottocode, location) were extracted from the CLICS database (see [here](https://clics.clld.org/download)). Starting from this column, we coded the variable *exists_blue* as follows:
 
    - if the blue concept is colexified with green, the variable *exists_blue* is set to *no*,
    - if the blue concept is *not* colexified with green, the variable *exists_blue* is set to *yes*,
    - if the blue concept is colexified with green and another color, the variable *exists_blue* is set to *no*,
    - if the blue concept is colexified with other colors but not green, the variable *exists_blue* is set to *mixed_with* (we decided to set these to `NA` given the uncertainty of their interpretation).

 - **manual checking of dictionnaries and personal communications**: we manually checked several dictionaries (especially for Australian languages) and we benefited from personal communication from specialists in specific languages from the [Laboratoire Dynamique du Langage (DDL; Université Lyon 2/CNRS, France)](http://www.ddl.ish-lyon.cnrs.fr/). All the references are available in the file [`references_blueword.csv`](https://github.com/mathjoss/replic_colors/blob/main/references/exists_blue/other/references_blueword.csv) in the GitHub repository.


### Is there a specific term for 'blue'

```{r summary word for blue}
# Visualize data
pander(summary(d_colors_ag$exists_blue))
```

```{r distribution word for blue, fig.cap=capFig("Is there a specific term for 'blue'?", TRUE, c("ggplot2"), is_map=FALSE)}
# DISTRIBUTION color vocab
ggplot(data =d_colors_ag)+
  theme_bw() +
  geom_bar(aes(x=as.factor(exists_blue), fill=as.factor(exists_blue)), alpha=0.75) + 
  labs(x="Is there a specific term for 'blue'?", fill="")+
  guides(fill=FALSE) +
  scale_fill_viridis_d()
```

```{r map word for blue, fig.cap=capFig("Map of specific terms for 'blue'.", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
# plot exists_blue on map
ggplot() + theme_bw() + 
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data= d_colors_ag, shape=21, aes(x = longitude, y = latitude, fill=exists_blue), color="red") +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(fill = "Term for 'blue'?") +
  scale_fill_viridis_d() + 
  NULL
```

```{r include=FALSE}
# figure for paper:
pmain <- ggplot() + theme_bw() + 
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="seashell3") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  #geom_point(data= d_colors_ag, size=0.75, alpha=0.75, aes(x = longitude, y = latitude, color=exists_blue)) +
  geom_point(data= d_colors_ag, size=0.90, shape=21, alpha=0.75, aes(x = longitude, y = latitude, fill=exists_blue), color="black") +
  ylim(-57, NA) + 
  theme(legend.position = c(0.78, 0.15), 
        legend.background = element_rect(fill="seashell", size=0.2, linetype="solid", colour ="black"), legend.key = element_rect(fill = "seashell"),
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 10)) +
  labs(color = "Term for 'blue'?") +
  scale_fill_manual(values=c("no"="yellow", "yes"="navyblue")) + 
  NULL;
pinset <- ggplot(data =d_colors_ag)+
  theme_bw() + 
  geom_bar(aes(x=as.factor(exists_blue), fill=as.factor(exists_blue)), color="black", alpha=0.75) + 
  scale_fill_manual(values=c("no"="yellow", "yes"="navyblue")) + 
  guides(fill=FALSE) + 
  theme(axis.text=element_text(size=6), axis.title=element_text(size=6), axis.title.x = element_blank(), axis.title.y = element_blank(),
        plot.background = element_rect(fill="seashell", color="black"), panel.background=element_rect(fill = "seashell")) + 
  NULL;
p <-
  ggdraw() +
  draw_plot(pmain) +
  draw_plot(pinset, x = 0.17, y = 0.01, width = .2, height = .25);

file_name <- "fig_map_blue";
png(paste0("./paper/",file_name,".png"), width=8, height=4, units="in", res=300); # for main paper
#jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=4, units="in", res=300, quality=85); # for SI
p;
dev.off();
```


## Language family

For each language, we obtained its family affiliation from the [Glottolog](https://glottolog.org/) [@hammarstrom_glottolog_2018]; there are `r length(unique(d_colors_ag$glottocode_family))` unique language families, most languages belonging to the Indo-European (indo1319), Atlantic-Congo (atla1278) and Afro-Asiatic (afro1255). 

```{r summary families}
# language family
pander(sort(table(d_colors_ag$glottocode_family), decreasing=TRUE));
```

```{r distribution families, fig.cap=capFig("The distribution of languages across families. Only the 15 most represented families are explicitely shown, the others being gathered in the umbrella category 'Other'.", TRUE, c("ggplot2"), is_map=FALSE)}
# Make sure "Other" is the last one:
d_colors_ag$glottocode_family_other <- factor(d_colors_ag$glottocode_family_other, levels=c(sort(setdiff(unique(d_colors_ag$glottocode_family_other), "Other")), "Other"));
ggplot(data =d_colors_ag)+
  theme_bw() +
  geom_bar(aes(x=as.factor(glottocode_family_other), fill=as.factor(glottocode_family_other)), alpha=0.5) + 
  labs(x="Language families", fill="") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  scale_fill_viridis_d() + 
  guides(fill=FALSE)
```

```{r map family, fig.cap=capFig("Map of the main language families. Only the 15 most represented language families have individual colors.", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
# Use an other variable to plot: only 15 main language families, other families are gathered under "Other"
ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_label_repel(data=d_colors_ag, aes(x=longitude, y=latitude, label=glottocode_family, fill=glottocode_family_other), 
                   color="black", alpha=0.75, size=2.75, label.padding=0.10, label.r=0.05) + 
  geom_point(data=d_colors_ag, shape=21, aes(x=longitude, y=latitude, fill=glottocode_family_other), color="black") +
  theme(legend.position = "none") +
  scale_fill_viridis_d(begin=0.2) + 
  NULL
```

### Putative origins of (macro-)families

The homelands of the language family were obtained using the following procedure:

 - if available, latitude and longitudes of languages families were retrieved using @wichmann_homelands_2010 's paper,
 - then, some of the missing data was filled using the Supplementary Materials from @josserand_environment_2021's (see input_files folder in https://github.com/ddediu/colors-UV),
 - the case of language isolates: we used the same glottocode for the language family (and the same latitude and longitude),
 - however, even after completing the previous three steps, we still had some missing data: for these, we obtained the latitude and longitude of the remaining glottocodes using different methods described in the file [`method_data_families.csv`](https://github.com/mathjoss/replic_colors/blob/main/references/latlong_language_family/method_data_families.csv) in this GitHub repository.

```{r map family origins, fig.cap=capFig("Origins of the putative origins of language (macro-)families.", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_label_repel(data=d_colors_families, aes(x=longitude_family, y=latitude_family, label=glottocode_family), 
                   color="black", fill="lightyellow", alpha=0.75, size=2.75, label.padding=0.10, label.r=0.05) + 
  geom_point(data=d_colors_families, shape=21, aes(x=longitude_family, y=latitude_family, fill=glottocode_family), color="black", alpha=0.75) +
  theme(legend.position = "none") +
  scale_fill_viridis_d() + 
  NULL
```

We also collected data corresponding to these locations for elevation, climate and ecology, humidity, distance to bodies of water and UV incidence; please note that (a) these locations are highly speculative, and (b) the information associated does not necessarily reflect the state of the world at the time when the proto-languages were spoken.

#### Relationship between variables for languages and family origins

Here we look at the relationship between the variables that have values for the actual languages and the family origins.

##### UV-B incidence

```{r results='asis'}
cat(paste0("***",(var.name <- "UV-B (mean; TOMS)"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=UV_mean_family, y=UV_mean)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(UV_mean,na.rm=TRUE), "n"=sum(!is.na(UV_mean))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + UV_mean_r + UV_mean_family_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$UV_mean_r, d_colors_ag$UV_mean_family_r, method="pearson");
r2 <- cor.test(d_colors_ag$UV_mean_r, d_colors_ag$UV_mean_family_r, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


```{r results='asis'}
cat(paste0("***",(var.name <- "UV-B (sd; TOMS)"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=UV_sd_family, y=UV_sd)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(UV_sd,na.rm=TRUE), "n"=sum(!is.na(UV_sd))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + UV_sd_r + UV_sd_family_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$UV_sd_r, d_colors_ag$UV_sd_family_r, method="pearson");
r2 <- cor.test(d_colors_ag$UV_sd_r, d_colors_ag$UV_sd_family_r, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


```{r results='asis'}
cat(paste0("***",(var.name <- "UV-B (mean; WorldClim)"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=UV_mean_wc_family, y=UV_mean_wc)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(UV_mean_wc,na.rm=TRUE), "n"=sum(!is.na(UV_mean_wc))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + UV_mean_wc_r + UV_mean_wc_family_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$UV_mean_wc_r, d_colors_ag$UV_mean_wc_family_r, method="pearson");
r2 <- cor.test(d_colors_ag$UV_mean_wc_r, d_colors_ag$UV_mean_wc_family_r, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


```{r results='asis'}
cat(paste0("***",(var.name <- "UV-B (sd; WorldClim)"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=UV_sd_wc_family, y=UV_sd_wc)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(UV_sd_wc,na.rm=TRUE), "n"=sum(!is.na(UV_sd_wc))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + UV_sd_wc_r + UV_sd_wc_family_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$UV_sd_wc_r, d_colors_ag$UV_sd_wc_family_r, method="pearson");
r2 <- cor.test(d_colors_ag$UV_sd_wc_r, d_colors_ag$UV_sd_wc_family_r, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


##### Climate and humidity

```{r results='asis'}
cat(paste0("***",(var.name <- "PC1"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=clim_PC1_family, y=clim_PC1)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(clim_PC1,na.rm=TRUE), "n"=sum(!is.na(clim_PC1))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + clim_PC1_r + clim_PC1_family_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$clim_PC1_r, d_colors_ag$clim_PC1_family_r, method="pearson");
r2 <- cor.test(d_colors_ag$clim_PC1_r, d_colors_ag$clim_PC1_family_r, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


```{r results='asis'}
cat(paste0("***",(var.name <- "PC2"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=clim_PC2_family, y=clim_PC2)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(clim_PC2,na.rm=TRUE), "n"=sum(!is.na(clim_PC2))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + clim_PC2_r + clim_PC2_family_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$clim_PC2_r, d_colors_ag$clim_PC2_family_r, method="pearson");
r2 <- cor.test(d_colors_ag$clim_PC2_r, d_colors_ag$clim_PC2_family_r, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


```{r results='asis'}
cat(paste0("***",(var.name <- "PC3"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=clim_PC3_family, y=clim_PC3)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(clim_PC3,na.rm=TRUE), "n"=sum(!is.na(clim_PC3))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + clim_PC3_r + clim_PC3_family_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$clim_PC3_r, d_colors_ag$clim_PC3_family_r, method="pearson");
r2 <- cor.test(d_colors_ag$clim_PC3_r, d_colors_ag$clim_PC3_family_r, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


```{r results='asis'}
cat(paste0("***",(var.name <- "Humidity (median)"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=hum_median_family, y=hum_median)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(hum_median,na.rm=TRUE), "n"=sum(!is.na(hum_median))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + hum_median + hum_median_family + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$hum_median, d_colors_ag$hum_median_family, method="pearson");
r2 <- cor.test(d_colors_ag$hum_median, d_colors_ag$hum_median_family, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


```{r results='asis'}
cat(paste0("***",(var.name <- "Humidity (IQR)"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=hum_IQR_family, y=hum_IQR)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(hum_IQR,na.rm=TRUE), "n"=sum(!is.na(hum_IQR))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + hum_IQR + hum_IQR_family + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$hum_IQR, d_colors_ag$hum_IQR_family, method="pearson");
r2 <- cor.test(d_colors_ag$hum_IQR, d_colors_ag$hum_IQR_family, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


##### Distances to large bodies of water

```{r results='asis'}
cat(paste0("***",(var.name <- "dist2lakes"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=dist2lakes_family, y=dist2lakes)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(dist2lakes,na.rm=TRUE), "n"=sum(!is.na(dist2lakes))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + dist2lakes_r + dist2lakes_family_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$dist2lakes_r, d_colors_ag$dist2lakes_family_r, method="pearson");
r2 <- cor.test(d_colors_ag$dist2lakes_r, d_colors_ag$dist2lakes_family_r, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


```{r results='asis'}
cat(paste0("***",(var.name <- "dist2rivers"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=dist2rivers_family, y=dist2rivers)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(dist2rivers,na.rm=TRUE), "n"=sum(!is.na(dist2rivers))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + dist2rivers_r + dist2rivers_family_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$dist2rivers_r, d_colors_ag$dist2rivers_family_r, method="pearson");
r2 <- cor.test(d_colors_ag$dist2rivers_r, d_colors_ag$dist2rivers_family_r, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


```{r results='asis'}
cat(paste0("***",(var.name <- "dist2ocean"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=dist2ocean_family, y=dist2ocean)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(dist2ocean,na.rm=TRUE), "n"=sum(!is.na(dist2ocean))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + dist2ocean_r + dist2ocean_family_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$dist2ocean_r, d_colors_ag$dist2ocean_family_r, method="pearson");
r2 <- cor.test(d_colors_ag$dist2ocean_r, d_colors_ag$dist2ocean_family_r, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


```{r results='asis'}
cat(paste0("***",(var.name <- "dist2water"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=dist2water_family, y=dist2water)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(dist2water,na.rm=TRUE), "n"=sum(!is.na(dist2water))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + dist2water_r + dist2water_family_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$dist2water_r, d_colors_ag$dist2water_family_r, method="pearson");
r2 <- cor.test(d_colors_ag$dist2water_r, d_colors_ag$dist2water_family_r, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


##### Elevation

```{r results='asis'}
cat(paste0("***",(var.name <- "elevation"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=elevation_family, y=elevation)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(elevation,na.rm=TRUE), "n"=sum(!is.na(elevation))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + elevation_r + elevation_family_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$elevation_r, d_colors_ag$elevation_family_r, method="pearson");
r2 <- cor.test(d_colors_ag$elevation_r, d_colors_ag$elevation_family_r, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


##### Geographical location

```{r results='asis'}
cat(paste0("***",(var.name <- "longitude"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=longitude_family, y=longitude)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(longitude,na.rm=TRUE), "n"=sum(!is.na(longitude))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + longitude_r + longitude_family_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$longitude_r, d_colors_ag$longitude_family_r, method="pearson");
r2 <- cor.test(d_colors_ag$longitude_r, d_colors_ag$longitude_family_r, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


```{r results='asis'}
cat(paste0("***",(var.name <- "latitude"),"***:\n"));
```
```{r fig.width=8, fig.height=8, fig.cap=capFig(paste0("Relationship between language-level measurements (x axis) and estimates at the family origin (y axis) for ",var.name,"."))}
# Plot:
ggplot(d_colors_ag, aes(x=latitude_family, y=latitude)) + 
  geom_point() + xlab("Language-level") + ylab("Family-origins-level") + ggtitle(var.name) + 
  geom_smooth(method="lm", color="blue") + geom_smooth(method="loess", color="red") + 
  NULL;
```
```{r}
# Families with lots of variance:
tmp <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("sd"=sd(latitude,na.rm=TRUE), "n"=sum(!is.na(latitude))) %>% as.data.frame(); 
tmp <- tmp[ !is.na(tmp[,2]), ]; tmp <- tmp[ order(tmp[,2], decreasing=TRUE), ];
med.sd <- median(tmp$sd);
kable(tmp[ tmp$sd >= med.sd, ], col.names=c("Family", "std.dev.", "# lgs"), digits=c(NA, 2, 0), cap=capTab(paste0("Families with std.dev >= median(std.dev.) (=",round(med.sd,2),") ordered decreasingly by std.dev for ",var.name,".")));
```
```{r results='hide'}
# VIF:
m <- glmer(exists_blue ~ 1 + latitude_r + latitude_family_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
summary(m);
(m_VIF <- performance::check_collinearity(m));
r1 <- cor.test(d_colors_ag$latitude_r, d_colors_ag$latitude_family_r, method="pearson");
r2 <- cor.test(d_colors_ag$latitude_r, d_colors_ag$latitude_family_r, method="spearman");
```
For `r var.name`: cor(language, family): `r sprintf("pearson's r=%.2f, p=%.3g; spearman's rho=%.2f, p=%.3g", r1$estimate, r1$p.value, r2$estimate, r2$p.value)`; VIF (language) = `r round(m_VIF$VIF[1],2)` and VIF (family) = `r round(m_VIF$VIF[2],2)`.


## Macroarea

We collected the macroareas as given by the [Glottolog](https://glottolog.org/) [@hammarstrom_glottolog_2018].

```{r map macroareas, fig.cap=capFig("Map of populations in our sample highlighting their macroarea.", TRUE, c("ggplot2", "maps"), is_map=TRUE)}
# macroarea
pander(sort(table(d_colors_ag$macroarea), decreasing=TRUE));

ggplot() + theme_bw() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
  geom_point(data=d_colors_ag, aes(x=longitude, y=latitude, color=macroarea, shape=macroarea)) +
  theme(legend.position = c(0.75, 0.5), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) +
  labs(color="Macroarea", shape="Macroarea") +
  scale_color_viridis_d() + 
  NULL
```


## New versus old databses

We went from `r length(unique(d_colors_previous$glottocode))` to `r length(unique(d_colors_ag$glottocode))` unique datapoints (i.e., the new database is `r round(length(unique(d_colors_ag$glottocode)) / length(unique(d_colors_previous$glottocode)),2)` time bigger, representing an increase of `r round(100*(length(unique(d_colors_ag$glottocode)) - length(unique(d_colors_previous$glottocode)))/length(unique(d_colors_previous$glottocode)),1)`% overall).

There are now `r length(unique(d_colors_ag$glottocode_family))` unique families (`r length(setdiff(unique(d_colors_ag$glottocode_family), unique(d_colors_previous$glottocode_family)))` new ones):
```{r}
tmp1 <- d_colors_ag %>% group_by(glottocode_family) %>% summarise("lgs.per.fam"=n()) %>% arrange(-lgs.per.fam) %>% as.data.frame;
tmp2 <- d_colors_previous %>% group_by(glottocode_family) %>% summarise("lgs.per.fam"=n()) %>% arrange(-lgs.per.fam) %>% as.data.frame;
tmp <- merge(tmp1, tmp2, by="glottocode_family", suffixes=c(".new", ".old"), all=TRUE);
tmp$diff <- tmp$lgs.per.fam.new - ifelse(is.na(tmp$lgs.per.fam.old), 0, tmp$lgs.per.fam.old); tmp$diff.perc <- ifelse(!is.na(tmp$lgs.per.fam.old), sprintf("%.1f%%",tmp$diff / tmp$lgs.per.fam.old * 100), "new");
tmp <- tmp[order(-tmp$diff, tmp$glottocode_family, na.last=TRUE),];
tmp <- tmp[ order(is.na(tmp$lgs.per.fam.old)),];
kable(tmp, row.names=FALSE, col.names=c("Family", "# lgs (new)", "# lgs (old)", "Difference", "% increase"), caption=capTab("Families in the new and the old database (sorted by decreasing difference, new families at the end)."));
```

In what concerns the macroareas:
```{r}
tmp1 <- d_colors_ag %>% group_by(macroarea) %>% summarise("lgs.per.macroarea"=n()) %>% arrange(-lgs.per.macroarea) %>% as.data.frame;
tmp2 <- d_colors_previous %>% group_by(macroarea) %>% summarise("lgs.per.macroarea"=n()) %>% arrange(-lgs.per.macroarea) %>% as.data.frame;
tmp <- merge(tmp1, tmp2, by="macroarea", suffixes=c(".new", ".old"), all=TRUE);
tmp$diff <- tmp$lgs.per.macroarea.new - tmp$lgs.per.macroarea.old; tmp$diff.perc <- sprintf("%.1f%%",tmp$diff / tmp$lgs.per.macroarea.old * 100);
tmp <- tmp[order(-tmp$diff, tmp$macroarea, na.last=TRUE),];
kable(tmp, row.names=FALSE, col.names=c("Macroarea", "# lgs (new)", "# lgs (old)", "Difference", "% increase"), caption=capTab("Macroareas in the new and the old database (sorted by decreasing difference)."));
```


# Notes on methods

## Bayesian mixed-effects regressions

For `brms`, to select the best model, we used Bayes factors, WAIC, LOO and KFOLD.
Please note that, for `brms`, there might be differences between Bayes factors, on the one hand, and WAIC/LOO/KFOLD, on the other, due to the default use of improper priors (see, for example, https://stats.stackexchange.com/questions/407964/bayes-factors-and-predictive-accuracy-in-model-comparison-in-rstan-brms) and intrinsic differences in what they capture [@mcelreath_statistical_2020]; therefore, we will combine these methods for model selection.

However, in some cases, we will base our selection of IVs only on their posterior distribution vis-a-vis 0.0 (judged jointly from the posterior plots, 95% HDIs, and formal hypothesis tests against 0).


## Mediation analysis

For the mediation analysis, we used a Bayesian approach as implemented by `brms`: in essence, given a treatment $T$ (for example, latitude), a mediator $M$ (for example, UV incidence), as an outcome $O$ (for example, the existence of a specific word for 'blue'), the mediation model looks like:

```{r fig.cap=capFig("Visual representation of a mediation, showing the individual estimates (edges, $a$, $b$ and $c$) and the effects (total, direct and indirect). We may use line style and color to differentiate ns, negative and positive edges. Likewise, we may report the total, direct and indirect effects on the diagram itself using colors to distinguish significant and ns effects.", TRUE, c("DiagrammeR"), is_map=FALSE)}
# Mediation:
DiagrammeR::grViz('
  digraph mediation_simple {

  # the graph:
  graph [overlap = true]
  rankdir="LR";
  
  # show types of edges:
  1 [style="none", shape="none", label="", tooltip=""]
  2 [style="none", shape="none", label="", tooltip=""]
  1 -> 2 [style="dashed", color="gray80", fontcolor="gray80", label="ns", tooltip="ns"]
  3 [style="none", shape="none", label="", tooltip=""]
  4 [style="none", shape="none", label="", tooltip=""]
  3 -> 4 [style="solid", color="blue", fontcolor="blue", label="< 0 (negative)", tooltip="negative (< 0)"]
  5 [style="none", shape="none", label="", tooltip=""]
  6 [style="none", shape="none", label="", tooltip=""]
  5 -> 6 [style="solid", color="red", fontcolor="red", label="> 0 (positive)", tooltip="negative (> 0)"]

  # the nodes:
  node [shape = box, style = "filled", fillcolor = "gray95"]
  T [label = "treatment"]; 
  M [label = "mediator"]; 
  O [label = "outcome"]; 

  # the edges:
  edge [style = "solid", color = "black"]
  T->O [label = "c"]
  T->M [label = "a"]
  M->O [label = "b"]
  
  # summary:
  te [shape="none", style="empty", fontcolor="blue",   tooltip="Total effect",    label="Total effect = ab+c < 0 [95%HDI], p < 0.05"]
  de [shape="none", style="empty", fontcolor="gray50", tooltip="Direct effect",   label="Direct effect = c [95%HDI], ns"]
  ie [shape="none", style="empty", fontcolor="red",    tooltip="Indirect effect", label="Indirect effect = ab > 0 [95%HDI], p < 0.05"]
  te -> de [style = "none", color = "none"]
  de -> ie [style = "none", color = "none"]
}
')
```

The *total effect* (i.e., the overall influence of $T$ on $O$, defined as $a \cdot b + c$) is decomposed into the *direct effect* (the arrow $T \longrightarrow O$, defined as being equal to $c$) and the *indirect effect* "flowing" through $M$ ($T \longrightarrow M \longrightarrow O$, defined as $a \cdot b$).
These are estimated by fitting the two mixed-effects regressions (with *family* and *macroarea* as random effects) to the data jointly:

$$
\begin{array}{l}
  M \sim T + (1 | family) + (1 | macroarea) \\
  O \sim T + M + (1 | family) + (1 | macroarea)
\end{array}
$$

Please note that in our plots, we may draw the edges differently depending on the "significance" and value of their estimates ($a$, $b$ and $c$). 



# Results

## Should we model families and macroareas as random effects?

First, we need to investigate the variation between and within families and macroareas, as we want to *a priori* include them as random effects in our models.

```{r blue null model, include=FALSE}
# Null model (intercept) -> word for blue:
file_name <- "./cached_results/test_rnd_effs.RData";
if( !all(file.exists(file_name)) )
{
  # check the random effects:
  
  # GLMER (+ ICC):
  m_0__blue_fm <- glmer(exists_blue ~ 1 + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag); # all random effects
  summary(m_0__blue_fm);
  (icc_fm <- performance::icc(m_0__blue_fm)); # 0.28
  # remove family:
  m_0__blue_m <- update(m_0__blue_fm, . ~ . - (1 | glottocode_family)); # macroarea
  summary(m_0__blue_m);
  (icc_m <- performance::icc(m_0__blue_m)); # 0.20
  (anova_m <- anova(m_0__blue_fm, m_0__blue_m)); # m_0__blue_fm is better (p=6.438e-07, ΔAIC=22.78)
  # remove macroarea:
  m_0__blue_f <- update(m_0__blue_fm, . ~ . - (1 | macroarea)); # family and language
  summary(m_0__blue_f);
  (icc_f <- performance::icc(m_0__blue_f)); # 0.31
  (anova_f <- anova(m_0__blue_fm, m_0__blue_f)); # m_0__blue_fm is better (p=0.0001129, ΔAIC=12.91)
  # -> clearly family and macroarea are need

  
  # BRMS:
  b_0__blue_fm <- brm(exists_blue ~ 1 + (1 | glottocode_family) + (1 | macroarea), # all random effects
                      family=bernoulli(link="logit"), data=d_colors_ag, 
                      prior=c(prior(student_t(3, 0, 2.5), class="Intercept")), # pretty wide priors centered on 0
                      save_pars=save_pars(all=TRUE), # needed for Bayes factors
                      sample_prior=TRUE,  # needed for hypotheses tests
                      cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
  summary(b_0__blue_fm); mcmc_plot(b_0__blue_fm, type="trace"); mcmc_plot(b_0__blue_fm);
  b_0__blue_fm <- brms_fit_indices(b_0__blue_fm);
  # remove family:
  b_0__blue_m <- update(b_0__blue_fm, . ~ . - (1 | glottocode_family), cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control); # macroarea
  summary(b_0__blue_m); mcmc_plot(b_0__blue_m, type="trace"); mcmc_plot(b_0__blue_m);
  b_0__blue_m <- brms_fit_indices(b_0__blue_m);
  compare_m <- brms_compare_models(b_0__blue_fm, b_0__blue_m, "full", "remove family"); # clearly language family is needed!
  # remove macroarea:
  b_0__blue_f <- update(b_0__blue_fm, . ~ . - (1 | macroarea), cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control); # family
  summary(b_0__blue_m); mcmc_plot(b_0__blue_f, type="trace"); mcmc_plot(b_0__blue_f);
  b_0__blue_f <- brms_fit_indices(b_0__blue_f);
  compare_f <- brms_compare_models(b_0__blue_fm, b_0__blue_f, "full", "remove macroarea"); # macroarea is also needed
  # -> clearly family is need, but macroarea is more marginal -- so let's keep both of them...

  
  # Save results:
  save(icc_fm, icc_m, anova_m, icc_f, anova_f,
       compare_m, compare_f,
       file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

Both the frequentist (`glmer`) and Bayesian (`brms`) models show that:

- the null model including both random effects (i.e., family crossed with macroarea, `(1 | family) + (1 | macroarea))`) has a relatively high ICC of `r round(icc_fm$ICC_adjusted*100,1)`%;

- removing *family* significantly drops the fit relative to the null model with all the random effects (`r sprintf("*p*=%s, ΔAIC=%.1f", scinot(anova_m[2,"Pr(>Chisq)"]), abs(anova_m$AIC[1]-anova_m$AIC[2]))`; `r sprintf("BayesFactor=%s, ΔLOO=%.1f, ΔWAIC=%.1f, ΔKFOLD=%.1f", scinot(compare_m$BF, pvalue=FALSE), abs(compare_m$LOO[1,1]-compare_m$LOO[2,1]), abs(compare_m$WAIC[1,1]-compare_m$WAIC[2,1]), abs(compare_m$KFOLD[1,1]-compare_m$KFOLD[2,1]))`)

- removing *macroarea* significantly drops the fit relative to the null model with all the random effects (`r sprintf("*p*=%s, ΔAIC=%.1f", scinot(anova_f[2,"Pr(>Chisq)"]), abs(anova_f$AIC[1]-anova_f$AIC[2]))`; `r sprintf("BayesFactor=%s, ΔLOO=%.1f, ΔWAIC=%.1f, ΔKFOLD=%.1f", scinot(compare_f$BF, pvalue=FALSE), abs(compare_f$LOO[1,1]-compare_f$LOO[2,1]), abs(compare_f$WAIC[1,1]-compare_f$WAIC[2,1]), abs(compare_f$KFOLD[1,1]-compare_f$KFOLD[2,1]))`).

Given these, we will do our modelling using the aggregated dataset (`d_colors_ag`) with both *family* and *macroarea* as crossed random effects.


## Individual logistic regressions

Here we look at the potential predictors of the existence of a specific word for 'blue' individually.

```{r null model for blue and model fitting auxiliary function, include=FALSE}
# The null models:
file_name <- "./cached_results/uv__blue_0.RData";
if( !all(file.exists(c(file_name))) )
{
  ### Null models:
  uv__blue_0 <- list(); # collect the models UV --> blue
  
  ## TOMS:
  uv__blue_0$toms$data <- d_colors_ag[ !is.na(d_colors_ag$UV_mean_r) & !is.na(d_colors_ag$UV_sd_r), ];
  m <- glmer(exists_blue ~ 1 + (1 | glottocode_family) + (1 | macroarea), # just the random effects
             family=binomial(), data=uv__blue_0$toms$data);
  summary(m);
  uv__blue_0$toms$glmer <- m;
  m <- brm(exists_blue ~ 1 + (1 | glottocode_family) + (1 | macroarea), # just the random effects
           family=bernoulli(link="logit"), data=uv__blue_0$toms$data,
           prior=c(prior(student_t(3, 0, 2.5), class="Intercept")), # pretty wide priors centered on 0
           save_pars=save_pars(all=TRUE), # needed for Bayes factors
           sample_prior=TRUE,  # needed for hypotheses tests
           cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
  summary(m); mcmc_plot(m, type="trace"); mcmc_plot(m);
  m <- brms_fit_indices(m);
  uv__blue_0$toms$brms <- m;
  
  ## WorldClim:
  uv__blue_0$wc$data <- d_colors_ag[ !is.na(d_colors_ag$UV_mean_wc_r) & !is.na(d_colors_ag$UV_sd_wc_r), ];
  m <- glmer(exists_blue ~ 1 + (1 | glottocode_family) + (1 | macroarea), # just the random effects
             family=binomial(), data=uv__blue_0$wc$data);
  summary(m);
  uv__blue_0$wc$glmer <- m;
  m <- brm(exists_blue ~ 1 + (1 | glottocode_family) + (1 | macroarea), # just the random effects
           family=bernoulli(link="logit"), data=uv__blue_0$wc$data,
           prior=c(prior(student_t(3, 0, 2.5), class="Intercept")), # pretty wide priors centered on 0
           save_pars=save_pars(all=TRUE), # needed for Bayes factors
           sample_prior=TRUE,  # needed for hypotheses tests
           cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
  summary(m); mcmc_plot(m, type="trace"); mcmc_plot(m);
  m <- brms_fit_indices(m);
  uv__blue_0$wc$brms <- m;
  
  # Both:
  uv__blue_0$both$data <- d_colors_ag[ !is.na(d_colors_ag$UV_mean_r) & !is.na(d_colors_ag$UV_sd_r) & 
                                         !is.na(d_colors_ag$UV_mean_wc_r) & !is.na(d_colors_ag$UV_sd_wc_r), ];
  m <- glmer(exists_blue ~ 1 + (1 | glottocode_family) + (1 | macroarea), # just the random effects
             family=binomial(), data=uv__blue_0$both$data);
  summary(m);
  uv__blue_0$both$glmer <- m;
  m <- brm(exists_blue ~ 1 + (1 | glottocode_family) + (1 | macroarea), # just the random effects
           family=bernoulli(link="logit"), data=uv__blue_0$both$data,
           prior=c(prior(student_t(3, 0, 2.5), class="Intercept")), # pretty wide priors centered on 0
           save_pars=save_pars(all=TRUE), # needed for Bayes factors
           sample_prior=TRUE,  # needed for hypotheses tests
           cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
  summary(m); mcmc_plot(m, type="trace"); mcmc_plot(m);
  m <- brms_fit_indices(m);
  uv__blue_0$both$brms <- m;
  
  # Save results:
  save(uv__blue_0, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}  

# auxiliary function for doing the fitting:
.fit.iv.blue.models <- function(d, iv, fit.quadratic=TRUE, refit.0=FALSE, iv_h=iv)
{
  # glmer:
  m0 <- d$glmer;
  if( !refit.0 )
  {
    m1 <- update(m0, formula(paste0(". ~ . + ",iv))); # linear
  } else
  {
    d$data <- d$data[ !is.na(d$data[,iv]), ];
    m1 <- glmer(formula(paste0(Reduce(paste, deparse(formula(m0)))," + ",iv)), family=family(m0), data=d$data); # fit m1 first
    m0 <- update(m1, formula(paste0(". ~ . - ",iv))); # refit m0 to the same data
  }
  summary(m1);
  (a0_1 <- anova(m0, m1));
  glmer.results <- list("linear"   =list("coefs"=summary(m1)$coefficients, "R2"=performance::r2(m1),  "anova_vs_0"=a0_1));
  # Test quadratic:
  if( fit.quadratic ) 
  {
    m12 <- update(m1, formula(paste0(". ~ . + I(",iv,"^2)")));
    summary(m12);
    (a1_12 <- anova(m1, m12));
    (a0_12 <- anova(m0, m12));
    glmer.results$quadratic <- list("coefs"=summary(m12)$coefficients, "R2"=performance::r2(m12), "anova_vs_0"=a0_12, "anova_vs_linear"=a1_12);
  }
  
  # brms:
  if( !refit.0 )
  {
    m0 <- d$brms;
  }
  m1 <- brm(formula(paste0("exists_blue ~ 1 + ",iv," + (1 | glottocode_family) + (1 | macroarea)")), # linear 
            family=bernoulli(link="logit"), data=d$data, 
            prior=c(prior(student_t(3, 0, 2.5), class="Intercept"),
                    prior(student_t(3, 0, 2.5), class="b")), # pretty wide priors centered on 0
            save_pars=save_pars(all=TRUE), # needed for Bayes factors
            sample_prior=TRUE,  # needed for hypotheses tests
            cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
  summary(m1); mcmc_plot(m1, type="trace"); mcmc_plot(m1);
  m1 <- brms_fit_indices(m1);
  (h_1 <- brms::hypothesis(m1, paste0(iv_h,c(" = 0", " < 0", " > 0"))));
  (hdi_1 <- hdi(m1, ci=0.95));
  if( refit.0 )
  {
    # Fit m0 to the same data as m1:
    m0 <- update(m1, formula(paste0(". ~ . - ",iv)), cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
    m0 <- brms_fit_indices(m0);
  }
  cmp0_1 <- brms_compare_models(m0, m1, "null", "linear"); 
  brms.results <- list("linear"   =list("hyps"=h_1,  "HDI"=hdi_1,  "cmp_vs_0"=cmp0_1));
  # Test quadratic:
  if( fit.quadratic )
  {
    m12 <- update(m1, formula(paste0(". ~ . + I(",iv,"^2)")), cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
    summary(m12); mcmc_plot(m12, type="trace"); mcmc_plot(m12);
    m12 <- brms_fit_indices(m12);
    (h_12 <- brms::hypothesis(m12, c(paste0(iv, c(" = 0", " < 0", " > 0")), paste0("I",iv,"E2 = 0"))));
    (hdi_12 <- hdi(m12, ci=0.95));
    cmp1_12 <- brms_compare_models(m1, m12, "linear", "quadratic");
    cmp0_12 <- brms_compare_models(m0, m12, "null", "quadratic");
    brms.results$quadratic <- list("hyps"=h_12, "HDI"=hdi_12, "cmp_vs_0"=cmp0_12, "cmp_vs_linear"=cmp1_12);
  }
  
  # return:
  return (list("glmer"=glmer.results, "brms"=brms.results));
}

# print model comparisons
.print.model.comparison <- function(a=NULL, a.names=NULL, b=NULL) # a is the anova and b is the Bayesian comparison (only one can be non-NULL), a.names are the mappings between the inner and user-friendly model names
{
  # ANOVA:
  if( !is.null(a) )
  {
    a <- as.data.frame(a);
    if( !is.null(a.names) )
    {
      if( length(a.names) != nrow(a) || !all(names(a.names) %in% rownames(a)) )
      {
        stop("a.names do not correspond the anova model names!");
        return (NULL);
      }
      rownames(a) <- a.names[rownames(a)];
    }
    i <- which.min(a$AIC);
    s.a <- sprintf("%s %s %s: ΔAIC=%.1f, ΔBIC=%.1f", 
                   rownames(a)[i], 
                   ifelse((!is.na(a[2,"Pr(>Chisq)"]) && a[2,"Pr(>Chisq)"] <0.05) || (abs(a$AIC[1] - a$AIC[2]) > 3), ">", "≈"),
                   rownames(a)[3-i],
                   abs(a$AIC[1] - a$AIC[2]), 
                   abs(a$BIC[1] - a$BIC[2]));
    if( !is.na(a[2,"Pr(>Chisq)"]) )
    {
      s.a <- paste0(s.a,
                    sprintf(", *p*=%s", scinot(a[2,"Pr(>Chisq)"])));
    }
    
    # return value:
    return (s.a);
  }
  
  # Bayesian comparison:
  if( !is.null(b) )
  {
    s.b <- sprintf("BF: %s, ΔLOO(%s %s %s)=%.1f (%.1f), ΔWAIC(%s %s %s)=%.1f (%.1f), ΔKFOLD(%s %s %s)=%.1f (%.1f)",
                   # BF:
                   b$BF_interpretation, 
                   # LOO:
                   rownames(b$LOO)[1],
                   ifelse(abs(b$LOO[1,1]-b$LOO[2,1]) < 4 || abs(b$LOO[1,1]-b$LOO[2,1]) < b$LOO[2,2], "≈", ifelse(abs(b$LOO[1,1]-b$LOO[2,1]) < 2*b$LOO[2,2], ">", ">>")),
                   rownames(b$LOO)[2], 
                   abs(b$LOO[1,1]-b$LOO[2,1]), b$LOO[2,2], 
                   # WAIC:
                   rownames(b$WAIC)[1], 
                   ifelse(abs(b$WAIC[1,1]-b$WAIC[2,1]) < 4 || abs(b$WAIC[1,1]-b$WAIC[2,1]) < b$WAIC[2,2], "≈", ifelse(abs(b$WAIC[1,1]-b$WAIC[2,1]) < 2*b$WAIC[2,2], ">", ">>")), 
                   rownames(b$WAIC)[2], 
                   abs(b$WAIC[1,1]-b$WAIC[2,1]), b$WAIC[2,2],
                   # KFOLD:
                   rownames(b$KFOLD)[1], 
                   ifelse(abs(b$KFOLD[1,1]-b$KFOLD[2,1]) < 4 || abs(b$KFOLD[1,1]-b$KFOLD[2,1]) < b$KFOLD[2,2], "≈", ifelse(abs(b$KFOLD[1,1]-b$KFOLD[2,1]) < 2*b$KFOLD[2,2], ">", ">>")), 
                   rownames(b$KFOLD)[2], 
                   abs(b$KFOLD[1,1]-b$KFOLD[2,1]), b$KFOLD[2,2]);
    
    # return value:
    return (s.b);
  }
}

# Summarize a simple iv -> sv regressions model as fitted by .fit.iv.blue.models() into a single row data.frame:
.summarize.iv.blue.models.as.data.frame <- function(m, iv, iv.name="IV", no.quadratic=FALSE, show.linear.for.null=TRUE,
                                                    alpha.level=0.05, elpd.cutoff=4.0, BF.cutoff=1/3) # using pretty liberal cut-offs as we want to avoid potential false negatives at this stage...
{
  if( !no.quadratic) iv2 <- paste0("I(",iv,"^2)"); 
  glmer.best <- ifelse(!no.quadratic && 
                         m$glmer$quadratic$anova_vs_linear$`Pr(>Chisq)`[2] < alpha.level && 
                         m$glmer$quadratic$anova_vs_0$`Pr(>Chisq)`[2] < alpha.level, 
                       "quadratic", 
                       ifelse(m$glmer$linear$anova_vs_0$`Pr(>Chisq)`[2] < alpha.level, 
                              "linear", 
                              "null"));
  brms.best  <- ifelse( !no.quadratic && 
                          ((m$brms$quadratic$hyps$hypothesis$Star[ m$brms$quadratic$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0") ] == "*" ||
                              !(m$brms$quadratic$HDI$CI_low[ m$brms$quadratic$HDI$Parameter == paste0("b_I",iv,"E2") ] < 0 && m$brms$quadratic$HDI$CI_high[ m$brms$quadratic$HDI$Parameter == paste0("b_I",iv,"E2") ] > 0)) && 
                             (m$brms$quadratic$cmp_vs_linear$BF <= BF.cutoff || 
                                (abs(m$brms$quadratic$cmp_vs_linear$LOO["linear", "elpd_diff"])   >= elpd.cutoff && m$brms$quadratic$cmp_vs_linear$LOO["linear", "elpd_diff"]   <= -m$brms$quadratic$cmp_vs_linear$LOO["linear", "se_diff"])   || 
                                (abs(m$brms$quadratic$cmp_vs_linear$KFOLD["linear", "elpd_diff"]) >= elpd.cutoff && m$brms$quadratic$cmp_vs_linear$KFOLD["linear", "elpd_diff"] <= -m$brms$quadratic$cmp_vs_linear$KFOLD["linear", "se_diff"]) || 
                                (abs(m$brms$quadratic$cmp_vs_linear$WAIC["linear", "elpd_diff"])  >= elpd.cutoff && m$brms$quadratic$cmp_vs_linear$WAIC["linear", "elpd_diff"]  <= -m$brms$quadratic$cmp_vs_linear$WAIC["linear", "se_diff"])) &&
                             (m$brms$quadratic$cmp_vs_0$BF <= BF.cutoff || 
                                (abs(m$brms$quadratic$cmp_vs_0$LOO["null", "elpd_diff"])   >= elpd.cutoff && m$brms$quadratic$cmp_vs_0$LOO["null", "elpd_diff"]   <= -m$brms$quadratic$cmp_vs_0$LOO["null", "se_diff"])   || 
                                (abs(m$brms$quadratic$cmp_vs_0$KFOLD["null", "elpd_diff"]) >= elpd.cutoff && m$brms$quadratic$cmp_vs_0$KFOLD["null", "elpd_diff"] <= -m$brms$quadratic$cmp_vs_0$KFOLD["null", "se_diff"]) || 
                                (abs(m$brms$quadratic$cmp_vs_0$WAIC["null", "elpd_diff"])  >= elpd.cutoff && m$brms$quadratic$cmp_vs_0$WAIC["null", "elpd_diff"]  <= -m$brms$quadratic$cmp_vs_0$WAIC["null", "se_diff"]))),
                        "quadratic",
                        ifelse( (m$brms$linear$hyps$hypothesis$Star[ m$brms$linear$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0") ] == "*" ||
                                  !(m$brms$linear$HDI$CI_low[ m$brms$linear$HDI$Parameter == paste0("b_",iv) ] < 0 && m$brms$linear$HDI$CI_high[ m$brms$linear$HDI$Parameter == paste0("b_",iv) ] > 0)) &&
                                  (m$brms$linear$cmp_vs_0$BF < BF.cutoff || 
                                     (abs(m$brms$linear$cmp_vs_0$LOO["null", "elpd_diff"])   >= elpd.cutoff && m$brms$linear$cmp_vs_0$LOO["null", "elpd_diff"]   <= -m$brms$linear$cmp_vs_0$LOO["null", "se_diff"])   || 
                                     (abs(m$brms$linear$cmp_vs_0$KFOLD["null", "elpd_diff"]) >= elpd.cutoff && m$brms$linear$cmp_vs_0$KFOLD["null", "elpd_diff"] <= -m$brms$linear$cmp_vs_0$KFOLD["null", "se_diff"]) || 
                                     (abs(m$brms$linear$cmp_vs_0$WAIC["null", "elpd_diff"])  >= elpd.cutoff && m$brms$linear$cmp_vs_0$WAIC["null", "elpd_diff"]  <= -m$brms$linear$cmp_vs_0$WAIC["null", "se_diff"])),
                                "linear",
                                "null"));
  
  ret.val <- data.frame("IV"=iv.name,
                        "glmer.model"=glmer.best,
                        "glmer.beta.2"=ifelse(glmer.best != "quadratic", 
                                              NA, 
                                              sprintf("%.2f ± %.2f, *p*=%s", m$glmer$quadratic$coefs[iv2, "Estimate"], m$glmer$quadratic$coefs[iv2, "Std. Error"], scinot(m$glmer$quadratic$coefs[iv2, "Pr(>|z|)"]))),
                        "glmer.beta.1"=ifelse(!show.linear.for.null && glmer.best == "null", 
                                              NA, 
                                              ifelse(glmer.best == "quadratic", 
                                                     sprintf("%.2f ± %.2f, *p*=%s", m$glmer$quadratic$coefs[iv, "Estimate"], m$glmer$quadratic$coefs[iv, "Std. Error"], scinot(m$glmer$quadratic$coefs[iv, "Pr(>|z|)"])),
                                                     sprintf("%s%.2f ± %.2f, *p*=%s%s", 
                                                             ifelse(glmer.best == "null", "{ ", ""), 
                                                             m$glmer$linear$coefs[iv, "Estimate"], m$glmer$linear$coefs[iv, "Std. Error"], scinot(m$glmer$linear$coefs[iv, "Pr(>|z|)"]),
                                                             ifelse(glmer.best == "null", " }", "")))),
                        "brms.model"=brms.best,
                        "brms.beta.2"=ifelse(brms.best != "quadratic", 
                                             NA, 
                                             sprintf("%.2f [%.2f, %.2f], *p*(=0) = %.3g", 
                                                     m$brms$quadratic$hyps$hypothesis$Estimate[ m$brms$quadratic$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0") ], 
                                                     m$brms$quadratic$HDI$CI_low[ m$brms$quadratic$HDI$Parameter == paste0("b_I",iv,"E2") ], 
                                                     m$brms$quadratic$HDI$CI_high[ m$brms$quadratic$HDI$Parameter == paste0("b_I",iv,"E2") ], 
                                                     m$brms$quadratic$hyps$hypothesis$Post.Prob[ m$brms$quadratic$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0") ])),
                        "brms.beta.1"=ifelse(!show.linear.for.null && brms.best == "null", 
                                             NA, 
                                             ifelse(brms.best == "quadratic", 
                                                    sprintf("%.2f [%.2f, %.2f], *p*(=0) = %.3g, *p*(<0) = %.3g,  *p*(>0) = %.3g", 
                                                            m$brms$quadratic$hyps$hypothesis$Estimate[ m$brms$quadratic$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0") ], 
                                                            m$brms$quadratic$HDI$CI_low[ m$brms$quadratic$HDI$Parameter == paste0("b_",iv) ], 
                                                            m$brms$quadratic$HDI$CI_high[ m$brms$quadratic$HDI$Parameter == paste0("b_",iv) ], 
                                                            m$brms$quadratic$hyps$hypothesis$Post.Prob[ m$brms$quadratic$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0") ],
                                                            m$brms$quadratic$hyps$hypothesis$Post.Prob[ m$brms$quadratic$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0") ],
                                                            m$brms$quadratic$hyps$hypothesis$Post.Prob[ m$brms$quadratic$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0") ]),
                                                    sprintf("%s%.2f [%.2f, %.2f], *p*(=0) = %.3g, *p*(<0) = %.3g,  *p*(>0) = %.3g%s", 
                                                            ifelse(brms.best == "null", "{ ", ""), 
                                                            m$brms$linear$hyps$hypothesis$Estimate[ m$brms$linear$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0") ], 
                                                            m$brms$linear$HDI$CI_low[ m$brms$linear$HDI$Parameter == paste0("b_",iv) ], 
                                                            m$brms$linear$HDI$CI_high[ m$brms$linear$HDI$Parameter == paste0("b_",iv) ], 
                                                            m$brms$linear$hyps$hypothesis$Post.Prob[ m$brms$linear$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0") ],
                                                            m$brms$linear$hyps$hypothesis$Post.Prob[ m$brms$linear$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0") ],
                                                            m$brms$linear$hyps$hypothesis$Post.Prob[ m$brms$linear$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0") ],
                                                            ifelse(brms.best == "null", " }", "")))),
                        "glmer.model.vs.null"=ifelse(glmer.best == "quadratic",
                                                     sprintf("%s, *R*^2^~marginal~ = %.1f%%", .print.model.comparison(a=m$glmer$quadratic$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), 100*m$glmer$quadratic$R2$R2_marginal),
                                                     sprintf("%s, *R*^2^~marginal~ = %.1f%%", .print.model.comparison(a=m$glmer$linear$anova_vs_0, a.names=c("m0"="null", "m1"="linear")), 100*m$glmer$linear$R2$R2_marginal)),
                        "brms.model.vs.null"=ifelse(brms.best == "null",
                                                    paste0("null is best: ", .print.model.comparison(b=m$brms$linear$cmp_vs_0)),
                                                    paste0(brms.best," > null: ", ifelse(brms.best == "quadratic",
                                                                                         .print.model.comparison(b=m$brms$quadratic$cmp_vs_0),
                                                                                         .print.model.comparison(b=m$brms$linear$cmp_vs_0))))
  );
  
  ret.val$glmer.model[ ret.val$glmer.model !="null"] <- paste0("***",ret.val$glmer.model[ ret.val$glmer.model !="null"],"***");
  ret.val$brms.model[ ret.val$brms.model !="null"]   <- paste0("***",ret.val$brms.model[ ret.val$brms.model !="null"],"***");
  
  return (ret.val);
}

# Which predictors seem to have an effect on 'blue'?
blue_predictors <- c();
# Given two best models (normally, as given by glmer and by brms), pick the most conservative one:
.agreed.model <- function(m1, m2)
{
  m1 <- gsub('*', '', m1, fixed=TRUE); m2 <- gsub('*', '', m2, fixed=TRUE); # remove any potential markdown highlighting
  if( m1 == m2 ) return (m1);
  if( m1 == "null" || m2 == "null" ) return ("null");
  if( m1 == "linear" || m2 == "linear" ) return ("linear");
  return ("quadratic");
}
```


### UV → 'blue' (*a priori* hypothesis)

```{r fig.cap=capFig("Probability of having a specific word for 'blue' function of UV-B incidence at the locations of the *languages*, showing the jittered data points, the densities (colored violins) and boxplots (black). Left: mean incidence, right: standard deviation of incidence; top: TOMS, bottom: WorldClim.", TRUE, c("ggplot2"), is_map=FALSE), fig.height=2*5, fig.width=2*4}
grid.arrange(ggplot(d_colors_ag, aes(y=UV_mean, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y=expression("Mean UV (TOMS; mW/m"^"2"~")")) +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=UV_sd, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y=expression("Std.dev. UV (TOMS; mW/m"^"2"~")")) +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,   
             ggplot(d_colors_ag, aes(y=UV_mean_wc, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y=expression("Mean UV (WorldClim; J/m"^"2"~")")) +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=UV_sd_wc, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y=expression("Std.dev. UV (WorldClim; J/m"^"2"~")")) +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,   
             ncol=2);
```

```{r fig.cap=capFig("Probability of having a specific word for 'blue' function of UV incidence at the *origins of language families*, showing the jittered data points, the densities (colored violins) and boxplots (black). Left: mean incidence, right: standard deviation of incidence; top: TOMS, bottom: WorldClim.", TRUE, c("ggplot2"), is_map=FALSE), fig.height=2*5, fig.width=2*4, eval=FALSE, include=FALSE}
grid.arrange(ggplot(d_colors_ag, aes(y=UV_mean_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y=expression("Mean UV (TOMS; mW/m"^"2"~")")) +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=UV_sd_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y=expression("Std.dev. UV (TOMS; mW/m"^"2"~")")) +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,   
             ggplot(d_colors_ag, aes(y=UV_mean_wc_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y=expression("Mean UV (WorldClim; J/m"^"2"~")")) +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=UV_sd_wc_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y=expression("Std.dev. UV (WorldClim; J/m"^"2"~")")) +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,   
             ncol=2);
```

```{r model the effects of UV incidence on blue individually, include=FALSE}
# UV incidence -> word for blue:
file_name <- "./cached_results/uv__blue_regressions.RData";
if( !all(file.exists(c(file_name))) )
{
  # Store the results:
  uv__blue <- list();
  
  ### For languages:
  ## TOMS:
  uv__blue$toms$mean <- .fit.iv.blue.models(uv__blue_0$toms, "UV_mean_r"); # mean
  uv__blue$toms$sd   <- .fit.iv.blue.models(uv__blue_0$toms, "UV_sd_r");   # sd
  ## WorldClim:
  uv__blue$wc$mean   <- .fit.iv.blue.models(uv__blue_0$wc,   "UV_mean_wc_r"); # mean
  uv__blue$wc$sd     <- .fit.iv.blue.models(uv__blue_0$wc,   "UV_sd_wc_r");   # sd
  
  
  ### For families:
  ## TOMS:
  uv__blue$toms$mean_fam <- .fit.iv.blue.models(uv__blue_0$toms, "UV_mean_family_r", refit.0=TRUE); # mean
  uv__blue$toms$sd_fam   <- .fit.iv.blue.models(uv__blue_0$toms, "UV_sd_family_r", refit.0=TRUE);   # sd
  ## WorldClim:
  uv__blue$wc$mean_fam   <- .fit.iv.blue.models(uv__blue_0$wc,   "UV_mean_wc_family_r", refit.0=TRUE); # mean
  uv__blue$wc$sd_fam     <- .fit.iv.blue.models(uv__blue_0$wc,   "UV_sd_wc_family_r", refit.0=TRUE);   # sd

  
  ## Compare TOMS and WorldClim for languages:
  # Using glmer:
  m_tw <- glmer(exists_blue ~ 1 + UV_mean_r + UV_mean_wc_r + (1 | glottocode_family) + (1 | macroarea),
                        family=binomial(), data=uv__blue_0$both$data);
  summary(m_tw);
  m_w <- update(m_tw, . ~ . - UV_mean_r);    # drop TOMS (= keep WorldClim)
  m_t <- update(m_tw, . ~ . - UV_mean_wc_r); # drop WorldClim (= keep TOMS)
  (uv__blue$toms_vs_wc$glmer <- anova(m_t, m_w)); # compare them
  # Using brms:
  m_tw <- brm(exists_blue ~ 1 + UV_mean_r + UV_mean_wc_r + (1 | glottocode_family) + (1 | macroarea),
              family=bernoulli(link="logit"), data=uv__blue_0$both$data, 
              prior=c(prior(student_t(3, 0, 2.5), class="Intercept"),
                      prior(student_t(3, 0, 2.5), class="b")), # pretty wide priors centered on 0
              save_pars=save_pars(all=TRUE), # needed for Bayes factors
              sample_prior=TRUE,  # needed for hypotheses tests
              cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
  summary(m_tw); mcmc_plot(m_tw, type="trace"); mcmc_plot(m_tw);
  m_tw <- brms_fit_indices(m_tw);
  (h_tw <- brms::hypothesis(m_tw, c("UV_mean_r = 0", "UV_mean_r < 0", "UV_mean_wc_r = 0", "UV_mean_wc_r < 0"))); # TOMS seems to win...
  (hdi_tw <- hdi(m_tw, ci=0.95));
  m_w <- update(m_tw, . ~ . - UV_mean_r, cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control); # drop TOMS (= keep WorldClim)
  m_w <- brms_fit_indices(m_w);
  m_t <- update(m_tw, . ~ . - UV_mean_wc_r, cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control); # drop WorldClim (= keep TOMS)
  m_t <- brms_fit_indices(m_t);
  # Compare them:
  uv__blue$toms_vs_wc$brms <- brms_compare_models(m_t, m_w, "TOMS", "WorldClim"); # TOMS seems to fit the data better!

  
  ## Compare TOMS and WorldClim for families:
  # Using glmer:
  m_tw <- glmer(exists_blue ~ 1 + UV_mean_family_r + UV_mean_wc_family_r + (1 | glottocode_family) + (1 | macroarea),
                        family=binomial(), data=uv__blue_0$both$data);
  summary(m_tw);
  m_w <- update(m_tw, . ~ . - UV_mean_family_r);    # drop TOMS (= keep WorldClim)
  m_t <- update(m_tw, . ~ . - UV_mean_wc_family_r); # drop WorldClim (= keep TOMS)
  (uv__blue$toms_vs_wc$glmer_fam <- anova(m_t, m_w)); # compare them
  # Using brms:
  m_tw <- brm(exists_blue ~ 1 + UV_mean_family_r + UV_mean_wc_family_r + (1 | glottocode_family) + (1 | macroarea),
              family=bernoulli(link="logit"), data=uv__blue_0$both$data, 
              prior=c(prior(student_t(3, 0, 2.5), class="Intercept"),
                      prior(student_t(3, 0, 2.5), class="b")), # pretty wide priors centered on 0
              save_pars=save_pars(all=TRUE), # needed for Bayes factors
              sample_prior=TRUE,  # needed for hypotheses tests
              cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
  summary(m_tw); mcmc_plot(m_tw, type="trace"); mcmc_plot(m_tw);
  m_tw <- brms_fit_indices(m_tw);
  (h_tw <- brms::hypothesis(m_tw, c("UV_mean_family_r = 0", "UV_mean_family_r < 0", "UV_mean_wc_family_r = 0", "UV_mean_wc_family_r < 0"))); # TOMS seems to be slightly better...
  (hdi_tw <- hdi(m_tw, ci=0.95));
  m_w <- update(m_tw, . ~ . - UV_mean_family_r, cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control); # drop TOMS (= keep WorldClim)
  m_w <- brms_fit_indices(m_w);
  m_t <- update(m_tw, . ~ . - UV_mean_wc_family_r, cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control); # drop WorldClim (= keep TOMS)
  m_t <- brms_fit_indices(m_t);
  # Compare them:
  uv__blue$toms_vs_wc$brms_fam <- brms_compare_models(m_t, m_w, "TOMS", "WorldClim"); # seem to fit equally well

  
  ### Check multicollinearity between UV measures:
  # As check_collinearity() does not currently work with brm, use glm:
  m_uv__blue <- glmer(exists_blue ~ 1 + UV_mean_r + UV_sd_r + UV_mean_wc_r + UV_sd_wc_r + (1 | glottocode_family) + (1 | macroarea),
                      family=binomial(), data=d_colors_ag);
  summary(m_uv__blue);
  (m_uv__blue_VIF <- performance::check_collinearity(m_uv__blue));
  # TOMS:
  m_uvt__blue <- glmer(exists_blue ~ 1 + UV_mean_r + UV_sd_r + (1 | glottocode_family) + (1 | macroarea),
                       family=binomial(), data=d_colors_ag);
  summary(m_uvt__blue);
  (m_uvt__blue_VIF <- performance::check_collinearity(m_uvt__blue));
  # WorldClim:
  m_uvw__blue <- glmer(exists_blue ~ 1 + UV_mean_wc_r + UV_sd_wc_r + (1 | glottocode_family) + (1 | macroarea),
                       family=binomial(), data=d_colors_ag);
  summary(m_uvw__blue);
  (m_uvw__blue_VIF <- performance::check_collinearity(m_uvw__blue));
  # TOMS - WolrdClim (means):
  m_uvtwm__blue <- glmer(exists_blue ~ 1 + UV_mean_r + UV_mean_wc_r + (1 | glottocode_family) + (1 | macroarea),
                         family=binomial(), data=d_colors_ag);
  summary(m_uvtwm__blue);
  (m_uvtwm__blue_VIF <- performance::check_collinearity(m_uvtwm__blue));
  # TOMS - WolrdClim (sd):
  m_uvtws__blue <- glmer(exists_blue ~ 1 + UV_sd_r + UV_sd_wc_r + (1 | glottocode_family) + (1 | macroarea),
                         family=binomial(), data=d_colors_ag);
  summary(m_uvtws__blue);
  (m_uvtws__blue_VIF <- performance::check_collinearity(m_uvtws__blue));
  ## -> keep the means only, as they are the focus of the a prioir hypothesis:
  m_uvtm__blue <- glmer(exists_blue ~ 1 + UV_mean_r + (1 | glottocode_family) + (1 | macroarea),
                        family=binomial(), data=d_colors_ag);
  summary(m_uvtm__blue);
  m_uvwm__blue <- glmer(exists_blue ~ 1 + UV_mean_wc_r + (1 | glottocode_family) + (1 | macroarea),
                        family=binomial(), data=d_colors_ag);
  summary(m_uvwm__blue);
  # TOMS (languages and families) together:
  ma_uvt__blue <- glmer(exists_blue ~ 1 + UV_mean_r + UV_sd_r + UV_mean_family_r + UV_sd_family_r + 
                         (1 | glottocode_family) + (1 | macroarea),
                       family=binomial(), data=d_colors_ag);
  summary(ma_uvt__blue);
  (ma_uvt__blue_VIF <- performance::check_collinearity(ma_uvt__blue));
  # WolrdClim (languages and families) together:
  ma_uvw__blue <- glmer(exists_blue ~ 1 + UV_mean_wc_r + UV_sd_wc_r + UV_mean_wc_family_r + UV_sd_wc_family_r + 
                         (1 | glottocode_family) + (1 | macroarea),
                       family=binomial(), data=d_colors_ag);
  summary(ma_uvw__blue);
  (ma_uvw__blue_VIF <- performance::check_collinearity(ma_uvw__blue));
  # Store the results:
  uv__blue$VIF$both <- m_uv__blue_VIF;
  uv__blue$VIF$toms <- ma_uvt__blue_VIF;
  uv__blue$VIF$wc   <- ma_uvw__blue_VIF;
  

  # Save results:
  save(uv__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

We fitted both frequentist (`glmer`) and Bayesian (`brms`) logistic regressions predicting the presence of a dedicated word for blue from the incidence of UB-B radiation while controlling for language family and macroarea (modeled as random effects).
We fitted separately models using UV-B incidence as given by the *TOMS* and by the *WorldClim* databases, at the location of the actual languages used or at the putative location of the proto-languages of the language families.
With these, we found that:

Comparing the two databases, TOMS seems to fit the data better when using the locations of the **languages**: 
  
  - `glmer`: `r .print.model.comparison(a=uv__blue$toms_vs_wc$glmer, a.names=c("m_t"="TOMS", "m_w"="WorldClim"))`
  - `brms`: `r .print.model.comparison(b=uv__blue$toms_vs_wc$brms)`

and equally well (or bad), with a possible slight advantage for TOMS, when using the **families**:
  
  - `glmer`: `r .print.model.comparison(a=uv__blue$toms_vs_wc$glmer_fam, a.names=c("m_t"="TOMS", "m_w"="WorldClim"))`
  - `brms`: `r .print.model.comparison(b=uv__blue$toms_vs_wc$brms_fam)`.

```{r}
# Summarize all these results:
mivs <- data.frame("m"      =c("uv__blue$toms$mean", "uv__blue$toms$sd", "uv__blue$wc$mean",      "uv__blue$wc$sd",      "uv__blue$toms$mean_fam",     "uv__blue$toms$sd_fam",     "uv__blue$wc$mean_fam",            "uv__blue$wc$sd_fam"),
                   "iv"     =c("UV_mean_r",          "UV_sd_r",          "UV_mean_wc_r",          "UV_sd_wc_r",          "UV_mean_family_r",           "UV_sd_family_r",           "UV_mean_wc_family_r",             "UV_sd_wc_family_r"),
                   "iv.name"=c("**TOMS** (mean)",    "**TOMS** (sd)",    "**WorldClim** (mean)",  "**WorldClim** (sd)",  "**TOMS** (mean; *family*)",  "**TOMS** (sd; *family*)",  "**WorldClim** (mean; *family*)",  "**WorldClim** (sd; *family*)"));
sdf <- do.call(rbind, lapply(1:nrow(mivs), function(i) .summarize.iv.blue.models.as.data.frame(eval(parse(text=mivs$m[i])), mivs$iv[i], mivs$iv.name[i])));
blue_predictors <- c(blue_predictors,
                     "UV.mean.TOMS"     =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "uv__blue$toms$mean") ], sdf$brms.model[s]),
                     "UV.sd.TOMS"       =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "uv__blue$toms$sd") ], sdf$brms.model[s]),
                     "UV.mean.WC"       =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "uv__blue$wc$mean") ], sdf$brms.model[s]),
                     "UV.sd.WC"         =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "uv__blue$wc$sd") ], sdf$brms.model[s]),
                     "UV.fams.mean.TOMS"=.agreed.model(sdf$glmer.model[ (s <- mivs$m == "uv__blue$toms$mean_fam") ], sdf$brms.model[s]),
                     "UV.fams.sd.TOMS"  =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "uv__blue$toms$sd_fam") ], sdf$brms.model[s]),
                     "UV.fams.mean.WC"  =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "uv__blue$wc$mean_fam") ], sdf$brms.model[s]),
                     "UV.fams.sd.WC"    =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "uv__blue$wc$sd_fam") ], sdf$brms.model[s]));
knitr::kable(sdf,
             row.names=FALSE,
             col.names=c("*IV* details", "`glmer`", "*β*^2^ ±std.err, *p*", "*β* ±std.err, *p*", "`brms`", "*β*^2^ [95%HDI], *p*(*β*^2^=0)", "*β* [95%HDI], *p*(*β*=0), *p*(*β*<0), *p*(*β*>0)", "`glmer` best vs 0", "`brms` best vs 0"),
             caption=capTab("Summary of the simple regressions involving *UV-B incidence* and *blue*, using both `glmer` and `brms`. *β*^2^ represents the quadratic term (if any), and *β* the linear term (if any). When the best model is the linear, there are no estimates for the quadratic terms, likewise, when the best model is the null, there are no estimates for any term (but we do show the estimates for the linear model between { and } nevertheless). The  last two columns give the full comparison between the best model and the null model; when the best model is the null, the last two columns show the comparison between linear and null."));
```

**multi-collinearity** between UV-B incidence measures:

- between databases using actual language locations: low VIF for TOMS, moderate and high for WorldClim:

```{r}
print(uv__blue$VIF$both);
```

- on TOMS: moderate for mean, high for sd and familiy:

```{r}
print(uv__blue$VIF$toms);
```

- on WorldClim: low between all measurements:

```{r}
print(uv__blue$VIF$wc);
```
  
→ seems **the best predictor is TOMS**, which is consistent with the *lens brunescence hypothesis*: indeed, TOMS database shows the erythemal UV (UV received by the human body), while Worldclim database just shows the top-of-atmosphere incident solar radiation.


### Latitude → 'blue'

```{r fig.cap=capFig("Probability of having a specific word for 'blue' function of latitude of the *languages*, showing the jittered data points, the densities (colored violins) and boxplots (black). From left to right: the linear effect of latitude and the quadratic effect of latitude (i.e., `latitude`^2^).", TRUE, c("ggplot2"), is_map=FALSE), fig.height=1*5, fig.width=3*4}
grid.arrange(ggplot(d_colors_ag, aes(y=latitude, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Latitude (°)") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL, 
             ggplot(d_colors_ag, aes(y=latitude^2, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y=expression("latitude"^"2"~" (°"^"2"~")")) +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ncol=2);
```


```{r fig.cap=capFig("Probability of having a specific word for 'blue' function of latitude of the *origins of the language families*, showing the jittered data points, the densities (colored violins) and boxplots (black). From left to right: the linear effect of latitude and the quadratic effect of latitude (i.e., `latitude`^2^).", TRUE, c("ggplot2"), is_map=FALSE), fig.height=1*5, fig.width=3*4, eval=FALSE, include=FALSE}
grid.arrange(ggplot(d_colors_ag, aes(y=latitude_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Latitude (°)") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL, 
             ggplot(d_colors_ag, aes(y=latitude_family^2, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y=expression("latitude"^"2"~" (°"^"2"~")")) +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ncol=2);
```

```{r include=FALSE}
# Latitude -> word for blue (using the data for TOMS as it is the largest):
file_name <- "./cached_results/lat__blue_regressions.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  lat__blue <- list();
  
  ### For languages:
  lat__blue$toms$langs <- .fit.iv.blue.models(uv__blue_0$toms, "latitude_r"); 

  ### For families:
  lat__blue$toms$fams <- .fit.iv.blue.models(uv__blue_0$toms, "latitude_family_r", refit.0=TRUE);

  # Save results:
  save(lat__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r}
# Summarize all these results:
mivs <- data.frame("m"      =c("lat__blue$toms$langs", "lat__blue$toms$fams"),
                   "iv"     =c("latitude_r",           "latitude_family_r"),
                   "iv.name"=c("**Latitude**",         "**Latitude** (*family*)"));
sdf <- do.call(rbind, lapply(1:nrow(mivs), function(i) .summarize.iv.blue.models.as.data.frame(eval(parse(text=mivs$m[i])), mivs$iv[i], mivs$iv.name[i])));
blue_predictors <- c(blue_predictors,
                     "latitude"    =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "lat__blue$toms$langs") ], sdf$brms.model[s]),
                     "latitude.fam"=.agreed.model(sdf$glmer.model[ (s <- mivs$m == "lat__blue$toms$fams") ], sdf$brms.model[s]));
knitr::kable(sdf,
             row.names=FALSE,
             col.names=c("*IV* details", "`glmer`", "*β*^2^ ±std.err, *p*", "*β* ±std.err, *p*", "`brms`", "*β*^2^ [95%HDI], *p*(*β*^2^=0)", "*β* [95%HDI], *p*(*β*=0), *p*(*β*<0), *p*(*β*>0)", "`glmer` best vs 0", "`brms` best vs 0"),
             caption=capTab("Summary of the simple regressions involving *latitude* and *blue*, using both `glmer` and `brms`. *β*^2^ represents the quadratic term (if any), and *β* the linear term (if any). When the best model is the linear, there are no estimates for the quadratic terms, likewise, when the best model is the null, there are no estimates for any term (but we do show the estimates for the linear model between { and } nevertheless). The last two columns give the full comparison between the best model and the null model; when the best model is the null, the last two columns show the comparison between linear and null."));
```


### Subsistence → 'blue'

There are `r sprintf("%d (%.1f%%)", sum(!is.na(d_colors_ag$subsistence)), 100*sum(!is.na(d_colors_ag$subsistence))/nrow(d_colors_ag))` languages with information about subsistence:

```{r}
pander(tmp <- table(d_colors_ag$subsistence, ifelse(d_colors_ag$exists_blue=="no", "no 'blue'", "has 'blue'")));
```

```{r fig.cap=capFig("The relationship between subsistence type and the existence of a specific word for 'blue'.", TRUE, c("ggplot2"), is_map=FALSE), fig.height=5, fig.width=4}
ggplot(as.data.frame(tmp) %>% mutate(Var2 = ifelse(Var2=="has 'blue'","Yes","No")), aes(x=Var1, y=Freq, fill=Var2)) +
  theme_bw() +
  geom_bar(stat="identity", color="black", alpha=0.25) + 
  geom_text(aes(label=Freq), color="black", position = position_stack(vjust = 0.5), size=3.0)+
  xlab("Subsistence") + ylab("Count") + 
  scale_fill_manual("Specific word for 'blue'?", values=c("No"="green", "Yes"="blue")) + 
  NULL;
```

```{r include=FALSE}
# Subsistence -> word for blue:
file_name <- "./cached_results/subsist__blue_regressions.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  subsist__blue <- list();
  
  ### For languages:
  subsist__blue$toms$langs <- .fit.iv.blue.models(uv__blue_0$toms, "subsistence", refit.0=TRUE, fit.quadratic=FALSE, iv_h="subsistenceAGR"); 

  # Save results:
  save(subsist__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r}
# Summarize all these results:
mivs <- data.frame("m"      =c("subsist__blue$toms$langs"),
                   "iv"     =c("subsistenceAGR"),
                   "iv.name"=c("**Subsistence**"));
sdf <- do.call(rbind, lapply(1:nrow(mivs), function(i) .summarize.iv.blue.models.as.data.frame(eval(parse(text=mivs$m[i])), mivs$iv[i], mivs$iv.name[i], no.quadratic=TRUE)));
blue_predictors <- c(blue_predictors,
                     "subsistence"=.agreed.model(sdf$glmer.model[ (s <- mivs$m == "subsist__blue$toms$langs") ], sdf$brms.model[s]));
knitr::kable(sdf,
             row.names=FALSE,
             col.names=c("*IV* details", "`glmer`", "*β*^2^ ±std.err, *p*", "*β* ±std.err, *p*", "`brms`", "*β*^2^ [95%HDI], *p*(*β*^2^=0)", "*β* [95%HDI], *p*(*β*=0), *p*(*β*<0), *p*(*β*>0)", "`glmer` best vs 0", "`brms` best vs 0"),
             caption=capTab("Summary of the simple regressions involving *subsistence* and *blue*, using both `glmer` and `brms`. *β*^2^ represents the quadratic term (if any), and *β* the linear term (if any). When the best model is the linear, there are no estimates for the quadratic terms, likewise, when the best model is the null, there are no estimates for any term (but we do show the estimates for the linear model between { and } nevertheless). The last two columns give the full comparison between the best model and the null model; when the best model is the null, the last two columns show the comparison between linear and null."));
```


### Elevation → 'blue'

```{r fig.cap=capFig("Probability of having a specific word for 'blue' function of elevation (altitude) of the *languages*, showing the jittered data points, the densities (colored violins) and boxplots (black). From left to right: the linear effect of elevation and the quadratic effect of elevation (i.e., `elevation`^2^).", TRUE, c("ggplot2"), is_map=FALSE), fig.height=1*5, fig.width=2*4}
grid.arrange(ggplot(d_colors_ag, aes(y=elevation, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="elevation (m)") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=elevation^2, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y=expression("elevation"^"2"~" (m"^"2"~")")) +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ncol=2);
```

```{r fig.cap=capFig("Probability of having a specific word for 'blue' function of elevation (altitude) of the *origins of language families*, showing the jittered data points, the densities (colored violins) and boxplots (black). From left to right: the linear effect of elevation and the quadratic effect of elevation (i.e., `elevation`^2^).", TRUE, c("ggplot2"), is_map=FALSE), fig.height=1*5, fig.width=2*4, eval=FALSE, include=FALSE}
grid.arrange(ggplot(d_colors_ag, aes(y=elevation_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="elevation (m)") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=elevation_family^2, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y=expression("elevation"^"2"~" (m"^"2"~")")) +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ncol=2);
```

```{r include=FALSE}
# Elevation -> word for blue:
file_name <- "./cached_results/elevation__blue_regressions.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  elevation__blue <- list();
  
  ### For languages:
  elevation__blue$toms$langs <- .fit.iv.blue.models(uv__blue_0$toms, "elevation_r"); 

  ### For families:
  elevation__blue$toms$fams <- .fit.iv.blue.models(uv__blue_0$toms, "elevation_family_r", refit.0=TRUE);

  # Save results:
  save(elevation__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r}
# Summarize all these results:
mivs <- data.frame("m"      =c("elevation__blue$toms$langs", "elevation__blue$toms$fams"),
                   "iv"     =c("elevation_r",                "elevation_family_r"),
                   "iv.name"=c("**Elevation**",              "**Elevation** (*family*)"));
sdf <- do.call(rbind, lapply(1:nrow(mivs), function(i) .summarize.iv.blue.models.as.data.frame(eval(parse(text=mivs$m[i])), mivs$iv[i], mivs$iv.name[i])));
blue_predictors <- c(blue_predictors,
                     "elevation"    =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "elevation__blue$toms$langs") ], sdf$brms.model[s]),
                     "elevation.fam"=.agreed.model(sdf$glmer.model[ (s <- mivs$m == "elevation__blue$toms$fams") ], sdf$brms.model[s]));
knitr::kable(sdf,
             row.names=FALSE,
             col.names=c("*IV* details", "`glmer`", "*β*^2^ ±std.err, *p*", "*β* ±std.err, *p*", "`brms`", "*β*^2^ [95%HDI], *p*(*β*^2^=0)", "*β* [95%HDI], *p*(*β*=0), *p*(*β*<0), *p*(*β*>0)", "`glmer` best vs 0", "`brms` best vs 0"),
             caption=capTab("Summary of the simple regressions involving *elevation* and *blue*, using both `glmer` and `brms`. *β*^2^ represents the quadratic term (if any), and *β* the linear term (if any). When the best model is the linear, there are no estimates for the quadratic terms, likewise, when the best model is the null, there are no estimates for any term (but we do show the estimates for the linear model between { and } nevertheless). The last two columns give the full comparison between the best model and the null model; when the best model is the null, the last two columns show the comparison between linear and null."));
```


### Climate, ecology and humidity → 'blue'

```{r fig.cap=capFig("Probability of having a specific word for 'blue' function of climate, ecology and humidity at the location of the *languages*, showing the jittered data points, the densities (colored violins) and boxplots (black). From left to right and top to bottom: climate PC1, PC2 and PC3, median and IQR of humidity.", TRUE, c("ggplot2"), is_map=FALSE), fig.height=2*5, fig.width=3*4}
grid.arrange(ggplot(d_colors_ag, aes(y=clim_PC1, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Climate PC1") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=clim_PC2, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Climate PC2") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=clim_PC3, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Climate PC3") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=hum_median, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Median humidity") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=hum_IQR, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="IQR humidity") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ncol=3);
```


```{r fig.cap=capFig("Probability of having a specific word for 'blue' function of climate, ecology and humidity at the location of the *origins of the language families*, showing the jittered data points, the densities (colored violins) and boxplots (black). From left to right and top to bottom: climate PC1, PC2 and PC3, median and IQR of humidity.", TRUE, c("ggplot2"), is_map=FALSE), fig.height=2*5, fig.width=3*4, eval=FALSE, include=FALSE}
grid.arrange(ggplot(d_colors_ag, aes(y=clim_PC1_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Climate PC1") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=clim_PC2_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Climate PC2") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=clim_PC3_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Climate PC3") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=hum_median_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Median humidity") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=hum_IQR_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="IQR humidity") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ncol=3);
```

```{r include=FALSE}
# Climate, ecology & humidity -> word for blue:
file_name <- "./cached_results/clim__blue_regressions.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  clim__blue <- list();
  
  ### For languages:
  # Check collinearity:
  m <- glmer(exists_blue ~ 1 + clim_PC1_r + clim_PC2_r + clim_PC3_r + hum_median + hum_IQR + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
  summary(m);
  clim__blue$toms$VIF <- performance::check_collinearity(m); # not much collinearity...
  # Fit the models individually:
  clim__blue$toms$climPC1 <- .fit.iv.blue.models(uv__blue_0$toms, "clim_PC1_r", refit.0=TRUE); 
  clim__blue$toms$climPC2 <- .fit.iv.blue.models(uv__blue_0$toms, "clim_PC2_r", refit.0=TRUE); 
  clim__blue$toms$climPC3 <- .fit.iv.blue.models(uv__blue_0$toms, "clim_PC3_r", refit.0=TRUE); 
  clim__blue$toms$hummed  <- .fit.iv.blue.models(uv__blue_0$toms, "hum_median", refit.0=TRUE); 
  clim__blue$toms$humiqr  <- .fit.iv.blue.models(uv__blue_0$toms, "hum_IQR",    refit.0=TRUE); 

  ### For families:
  # Check collinearity:
  m <- glmer(exists_blue ~ 1 + clim_PC1_family_r + clim_PC2_family_r + clim_PC3_family_r + hum_median_family + hum_IQR_family + (1 | macroarea), family=binomial(), data=d_colors_ag);
  summary(m);
  clim__blue$toms$VIF_fam <- performance::check_collinearity(m); # not much collinearity...
  # Fit the models individually:
  clim__blue$toms$climPC1_fam <- .fit.iv.blue.models(uv__blue_0$toms, "clim_PC1_family_r", refit.0=TRUE); 
  clim__blue$toms$climPC2_fam <- .fit.iv.blue.models(uv__blue_0$toms, "clim_PC2_family_r", refit.0=TRUE); 
  clim__blue$toms$climPC3_fam <- .fit.iv.blue.models(uv__blue_0$toms, "clim_PC3_family_r", refit.0=TRUE); 
  clim__blue$toms$hummed_fam  <- .fit.iv.blue.models(uv__blue_0$toms, "hum_median_family", refit.0=TRUE); 
  clim__blue$toms$humiqr_fam  <- .fit.iv.blue.models(uv__blue_0$toms, "hum_IQR_family",    refit.0=TRUE); 

  # Save results:
  save(clim__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r}
# Summarize all these results:
mivs <- data.frame("m"      =c("clim__blue$toms$climPC1", "clim__blue$toms$climPC2", "clim__blue$toms$climPC3", "clim__blue$toms$hummed", "clim__blue$toms$humiqr",
                               "clim__blue$toms$climPC1_fam", "clim__blue$toms$climPC2_fam", "clim__blue$toms$climPC3_fam", "clim__blue$toms$hummed_fam", "clim__blue$toms$humiqr_fam"),
                   "iv"     =c("clim_PC1_r",              "clim_PC2_r",              "clim_PC3_r",              "hum_median",             "hum_IQR",
                               "clim_PC1_family_r",           "clim_PC2_family_r",          "clim_PC3_family_r",            "hum_median_family",           "hum_IQR_family"),
                   "iv.name"=c("Climate **PC1**",         "Climate **PC2**",          "Climate **PC3**",         "**Humidity** (median)",  "**Humidity** (IQR)",
                               "Climate **PC1** (*family*)",  "Climate **PC2** (*family*)", "Climate **PC3** (*family*)", "**Humidity** (median; *family*)",  "**Humidity** (IQR; *family*)"));
sdf <- do.call(rbind, lapply(1:nrow(mivs), function(i) .summarize.iv.blue.models.as.data.frame(eval(parse(text=mivs$m[i])), mivs$iv[i], mivs$iv.name[i])));
blue_predictors <- c(blue_predictors,
                     "PC1"                =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "clim__blue$toms$climPC1") ], sdf$brms.model[s]),
                     "PC2"                =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "clim__blue$toms$climPC2") ], sdf$brms.model[s]),
                     "PC3"                =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "clim__blue$toms$climPC3") ], sdf$brms.model[s]),
                     "humidity.median"    =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "clim__blue$toms$hummed") ], sdf$brms.model[s]),
                     "humidity.iqr"       =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "clim__blue$toms$humiqr") ], sdf$brms.model[s]),
                     "PC1.fam"            =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "clim__blue$toms$climPC1_fam") ], sdf$brms.model[s]),
                     "PC2.fam"            =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "clim__blue$toms$climPC2_fam") ], sdf$brms.model[s]),
                     "PC3.fam"            =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "clim__blue$toms$climPC3_fam") ], sdf$brms.model[s]),
                     "humidity.median.fam"=.agreed.model(sdf$glmer.model[ (s <- mivs$m == "clim__blue$toms$hummed_fam") ], sdf$brms.model[s]),
                     "humidity.iqr.fam"   =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "clim__blue$toms$humiqr_fam") ], sdf$brms.model[s]));
knitr::kable(sdf,
             row.names=FALSE,
             col.names=c("*IV* details", "`glmer`", "*β*^2^ ±std.err, *p*", "*β* ±std.err, *p*", "`brms`", "*β*^2^ [95%HDI], *p*(*β*^2^=0)", "*β* [95%HDI], *p*(*β*=0), *p*(*β*<0), *p*(*β*>0)", "`glmer` best vs 0", "`brms` best vs 0"),
             caption=capTab("Summary of the simple regressions involving *climate*/*humidity* and *blue*, using both `glmer` and `brms`. *β*^2^ represents the quadratic term (if any), and *β* the linear term (if any). When the best model is the linear, there are no estimates for the quadratic terms, likewise, when the best model is the null, there are no estimates for any term (but we do show the estimates for the linear model between { and } nevertheless). The last two columns give the full comparison between the best model and the null model; when the best model is the null, the last two columns show the comparison between linear and null."));
```


### Distance to water → 'blue'

```{r fig.cap=capFig("Probability of having a specific word for 'blue' function of distance to large bodies of water from the locations of the *languages*, showing the jittered data points, the densities (colored violins) and boxplots (black). From left to right and top to bottom, distances to: lakes, rivers, seas/oceans, and any type of body of water.", TRUE, c("ggplot2"), is_map=FALSE), fig.height=2*5, fig.width=2*4}
grid.arrange(ggplot(d_colors_ag, aes(y=dist2lakes, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Distance to nearest lake (km)") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=dist2rivers, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Distance to nearest river (km)") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=dist2ocean, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Distance to nearest sea/ocean (km)") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=dist2water, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Distance to nearest large body of water (km)") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ncol=2);
```

```{r fig.cap=capFig("Probability of having a specific word for 'blue' function of distance to large bodies of water from the locations of the *origins of language families*, showing the jittered data points, the densities (colored violins) and boxplots (black). From left to right and top to bottom, distances to: lakes, rivers, seas/oceans, and any type of body of water.", TRUE, c("ggplot2"), is_map=FALSE), fig.height=2*5, fig.width=2*4, eval=FALSE, include=FALSE}
grid.arrange(ggplot(d_colors_ag, aes(y=dist2lakes_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Distance to nearest lake (km)") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=dist2rivers_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Distance to nearest river (km)") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=dist2ocean_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Distance to nearest sea/ocean (km)") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ggplot(d_colors_ag, aes(y=dist2water_family, x=exists_blue, fill=exists_blue)) + 
               geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
               theme_bw() +
               labs(x='Word for blue?', y="Distance to nearest large body of water (km)") +
               theme(axis.text.x = element_text(size =14, face = "bold"), 
                     axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
                     axis.title=element_text(size=14),
                     legend.title=element_text(size =16),
                     legend.text=element_text(size =16),
                     legend.position="bottom") +
               scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
               NULL,
             ncol=2);
```

```{r include=FALSE}
# Distance to large bodies of water -> word for blue:
file_name <- "./cached_results/water__blue_regressions.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  water__blue <- list();
  
  ### For languages:
  # Check collinearity:
  m <- glmer(exists_blue ~ 1 + dist2lakes_r + dist2rivers_r + dist2ocean_r + dist2water_r + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
  summary(m);
  water__blue$toms$VIF <- performance::check_collinearity(m); # not much collinearity...
  # Fit the models individually:
  water__blue$toms$lakes  <- .fit.iv.blue.models(uv__blue_0$toms, "dist2lakes_r"); 
  water__blue$toms$rivers <- .fit.iv.blue.models(uv__blue_0$toms, "dist2rivers_r"); 
  water__blue$toms$oceans <- .fit.iv.blue.models(uv__blue_0$toms, "dist2ocean_r"); 
  water__blue$toms$water  <- .fit.iv.blue.models(uv__blue_0$toms, "dist2water_r"); 

  ### For families:
  # Check collinearity:
  m <- glmer(exists_blue ~ 1 + dist2lakes_family_r + dist2rivers_family_r + dist2ocean_family_r + dist2water_family_r + (1 | macroarea), family=binomial(), data=d_colors_ag);
  summary(m);
  water__blue$toms$VIF_fam <- performance::check_collinearity(m); # not much collinearity...
  # Fit the models individually:
  water__blue$toms$lakes_fam  <- .fit.iv.blue.models(uv__blue_0$toms, "dist2lakes_family_r", refit.0=TRUE); 
  water__blue$toms$rivers_fam <- .fit.iv.blue.models(uv__blue_0$toms, "dist2rivers_family_r", refit.0=TRUE); 
  water__blue$toms$oceans_fam <- .fit.iv.blue.models(uv__blue_0$toms, "dist2ocean_family_r", refit.0=TRUE); 
  water__blue$toms$water_fam  <- .fit.iv.blue.models(uv__blue_0$toms, "dist2water_family_r", refit.0=TRUE); 

  # Save results:
  save(water__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r}
# Summarize all these results:
mivs <- data.frame("m"      =c("water__blue$toms$lakes", "water__blue$toms$rivers", "water__blue$toms$oceans", "water__blue$toms$water", "water__blue$toms$lakes_fam", "water__blue$toms$rivers_fam", "water__blue$toms$oceans_fam", "water__blue$toms$water_fam"),
                   "iv"     =c("dist2lakes_r",           "dist2rivers_r",           "dist2ocean_r",            "dist2water_r",           "dist2lakes_family_r",        "dist2rivers_family_r",        "dist2ocean_family_r",         "dist2water_family_r"),
                   "iv.name"=c("**lakes**",              "**rivers**",              "**ocean**",               "**water** in general",   "**lakes** (*family*)",       "**rivers** (*family*)",       "**ocean** (*family*)",        "**water** in general (*family*)"));
sdf <- do.call(rbind, lapply(1:nrow(mivs), function(i) .summarize.iv.blue.models.as.data.frame(eval(parse(text=mivs$m[i])), mivs$iv[i], mivs$iv.name[i])));
blue_predictors <- c(blue_predictors,
                     "lakes"    =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "water__blue$toms$lakes") ], sdf$brms.model[s]),
                     "rivers"   =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "water__blue$toms$rivers") ], sdf$brms.model[s]),
                     "oceans"   =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "water__blue$toms$oceans") ], sdf$brms.model[s]),
                     "water"    =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "water__blue$toms$water") ], sdf$brms.model[s]),
                     "lakes.fam"=.agreed.model(sdf$glmer.model[ (s <- mivs$m == "water__blue$toms$lakes_fam") ], sdf$brms.model[s]),
                     "rivers.fam"=.agreed.model(sdf$glmer.model[ (s <- mivs$m == "water__blue$toms$rivers_fam") ], sdf$brms.model[s]),
                     "oceans.fam"=.agreed.model(sdf$glmer.model[ (s <- mivs$m == "water__blue$toms$oceans_fam") ], sdf$brms.model[s]),
                     "water.fam" =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "water__blue$toms$water_fam") ], sdf$brms.model[s]));
knitr::kable(sdf,
             row.names=FALSE,
             col.names=c("*IV* details", "`glmer`", "*β*^2^ ±std.err, *p*", "*β* ±std.err, *p*", "`brms`", "*β*^2^ [95%HDI], *p*(*β*^2^=0)", "*β* [95%HDI], *p*(*β*=0), *p*(*β*<0), *p*(*β*>0)", "`glmer` best vs 0", "`brms` best vs 0"),
             caption=capTab("Summary of the simple regressions involving *distance to...* and *blue*, using both `glmer` and `brms`. *β*^2^ represents the quadratic term (if any), and *β* the linear term (if any). When the best model is the linear, there are no estimates for the quadratic terms, likewise, when the best model is the null, there are no estimates for any term (but we do show the estimates for the linear model between { and } nevertheless). The last two columns give the full comparison between the best model and the null model; when the best model is the null, the last two columns show the comparison between linear and null."));
```


### (log) population size → 'blue'

There are `r sprintf("%d (%.1f%%)", sum(!is.na(d_colors_ag$log_popSize_ethno)), 100*sum(!is.na(d_colors_ag$log_popSize_ethno))/nrow(d_colors_ag))` and `r sprintf("%d (%.1f%%)", sum(!is.na(d_colors_ag$log_popSize_wiki)), 100*sum(!is.na(d_colors_ag$log_popSize_wiki))/nrow(d_colors_ag))` data points with population size info for Ethnologue and Wikipedia, respectively.

```{r fig.cap=capFig("Probability of having a specific word for 'blue' function of (log) population size, showing the jittered data points, the densities (colored violins) and boxplots (black) for Ethnologue.", TRUE, c("ggplot2"), is_map=FALSE), fig.height=1*5, fig.width=1*4}
ggplot(d_colors_ag, aes(y=log_popSize_ethno, x=exists_blue, fill=exists_blue)) + 
  geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
  theme_bw() +
  labs(x='Word for blue?', y="log(population size)") +
  theme(axis.text.x = element_text(size =14, face = "bold"), 
        axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
        axis.title=element_text(size=14),
        legend.title=element_text(size =16),
        legend.text=element_text(size =16),
        legend.position="bottom") +
  scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
  NULL;
```

```{r fig.cap=capFig("Probability of having a specific word for 'blue' function of (log) population size, showing the jittered data points, the densities (colored violins) and boxplots (black) for Wikipedia.", TRUE, c("ggplot2"), is_map=FALSE), fig.height=1*5, fig.width=1*4}
ggplot(d_colors_ag, aes(y=log_popSize_wiki, x=exists_blue, fill=exists_blue)) + 
  geom_jitter(alpha=0.50, aes(color=exists_blue)) + geom_violin(alpha=0.25, aes(color=exists_blue)) + geom_boxplot(fill=alpha("gray80",0.30)) + 
  theme_bw() +
  labs(x='Word for blue?', y="log(population size)") +
  theme(axis.text.x = element_text(size =14, face = "bold"), 
        axis.text.y = element_text(hjust = 1, size =14, face = "bold"),
        axis.title=element_text(size=14),
        legend.title=element_text(size =16),
        legend.text=element_text(size =16),
        legend.position="bottom") +
  scale_fill_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + scale_color_manual('Word for blue?', values=c("yes"="blue", "no"="green")) + 
  NULL;
```

```{r include=FALSE}
# log population size -> word for blue:
file_name <- "./cached_results/popsize__blue_regressions.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  popsize__blue <- list();
  
  ### For languages:
  popsize__blue$toms$ethno  <- .fit.iv.blue.models(uv__blue_0$toms, "log_popSize_ethno", refit.0=TRUE); 
  popsize__blue$toms$wiki   <- .fit.iv.blue.models(uv__blue_0$toms, "log_popSize_wiki",  refit.0=TRUE); 

  # Save results:
  save(popsize__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```


```{r}
# Summarize all these results:
mivs <- data.frame("m"      =c("popsize__blue$toms$ethno", "popsize__blue$toms$wiki"),
                   "iv"     =c("log_popSize_ethno",        "log_popSize_wiki"),
                   "iv.name"=c("from **Ethnologue**",      "from **Wikipedia**"));
sdf <- do.call(rbind, lapply(1:nrow(mivs), function(i) .summarize.iv.blue.models.as.data.frame(eval(parse(text=mivs$m[i])), mivs$iv[i], mivs$iv.name[i])));
blue_predictors <- c(blue_predictors,
                     "popsize.ethno"=.agreed.model(sdf$glmer.model[ (s <- mivs$m == "popsize__blue$toms$ethno") ], sdf$brms.model[s]),
                     "popsize.wiki" =.agreed.model(sdf$glmer.model[ (s <- mivs$m == "popsize__blue$toms$wiki") ], sdf$brms.model[s]));
knitr::kable(sdf,
             row.names=FALSE,
             col.names=c("*IV* details", "`glmer`", "*β*^2^ ±std.err, *p*", "*β* ±std.err, *p*", "`brms`", "*β*^2^ [95%HDI], *p*(*β*^2^=0)", "*β* [95%HDI], *p*(*β*=0), *p*(*β*<0), *p*(*β*>0)", "`glmer` best vs 0", "`brms` best vs 0"),
             caption=capTab("Summary of the simple regressions involving *population size* and *blue*, using both `glmer` and `brms`. *β*^2^ represents the quadratic term (if any), and *β* the linear term (if any). When the best model is the linear, there are no estimates for the quadratic terms, likewise, when the best model is the null, there are no estimates for any term (but we do show the estimates for the linear model between { and } nevertheless). The last two columns give the full comparison between the best model and the null model; when the best model is the null, the last two columns show the comparison between linear and null."));
```


### Summary: which variables seem to influence 'blue'?

The following predictors were found to have an effect on 'blue': `r paste0("*",names(blue_predictors)[ blue_predictors != "null" ],"* (", blue_predictors[ blue_predictors != "null" ],")", collapse=", ")`. *Distance to lakes* might also  have a (small) effect on 'blue'. 

```{r}
if( !file.exists("./cached_results/blue_predictors_regressions.RData") )
{
  save(blue_predictors, file="./cached_results/blue_predictors_regressions.RData", compress="xz", compression_level=9);
} else
{
  load("./cached_results/blue_predictors_regressions.RData");
}
```



## Mediation analyses

There are several possible mediated pathways connecting various variables and the existence of a dedicated word for 'blue'.
We only test those potential predictors that either show a noticeable effect on 'blue' in isolation, or are *a priori* interesting, which are: *mean UV-B* incidence (as given by TOMS), *subsistence*, *climate PC1*, *distance to lakes*, and *population size* (as given by the Ethnologue).
Some of these do have a causal interpretation  and justification, but others are not to be interpreted causally but simply intended to clarify the relationships between variables: we marked these clearly in the subsections below.


```{r}
if( !exists("blue_predictors") || is.null(blue_predictors) )
{
  load("./cached_results/blue_predictors_regressions.RData");
}

# the a priori interesting predictors to include no matter their individual regression results:
blue_predictors_apriori <- c("latitude", # latitude
                             "UV.mean.TOMS", "UV.sd.TOMS", # mean and sd UV-B
                             "subsistence", "popsize.ethno", # subsistence and population size
                             "PC1", # climate PC1 
                             "lakes", # distance to lakes 
                             "latitude.fam", "UV.fams.mean.TOMS", "UV.fams.sd.TOMS" # latitude and UV-B at the family origins
                            );

.include.predictor <- function(s) (blue_predictors[s] != "null" || s %in% blue_predictors_apriori);

# Collect the mediation results:
med.res <- NULL;
.summarize.mediation <- function(m) data.frame("O"=m$outcome_name, "T"=m$treatment_name, "M"=m$mediator_name,
                                               "T2M"=sprintf("%.2g [%.2g, %.2g]%s", m$summary$fixed$Estimate[3], m$summary$fixed$`l-95% CI`[3], m$summary$fixed$`u-95% CI`[3], ifelse(m$summary$fixed$`l-95% CI`[3] < 0 & m$summary$fixed$`u-95% CI`[3] > 0, "", "*")),
                                               "M2O"=sprintf("%.2g [%.2g, %.2g]%s", m$summary$fixed$Estimate[4], m$summary$fixed$`l-95% CI`[4], m$summary$fixed$`u-95% CI`[4], ifelse(m$summary$fixed$`l-95% CI`[4] < 0 & m$summary$fixed$`u-95% CI`[4] > 0, "", "*")),
                                               "T2O"=sprintf("%.2g [%.2g, %.2g]%s", m$summary$fixed$Estimate[5], m$summary$fixed$`l-95% CI`[5], m$summary$fixed$`u-95% CI`[5], ifelse(m$summary$fixed$`l-95% CI`[5] < 0 & m$summary$fixed$`u-95% CI`[5] > 0, "", "*")),
                                               "Tot"=sprintf("%.2g [%.2g, %.2g]%s (%.3g)%s", m$mediation$estimate[1], m$mediation$estimate_HDI_low[1], m$mediation$estimate_HDI_high[1], ifelse(m$mediation$estimate_HDI_low[1] < 0 & m$mediation$estimate_HDI_high[1] > 0, "", "*"), m$mediation$p_ROPE[1], ifelse(m$mediation$p_ROPE[1] < 0.05, "*", "")),
                                               "Dir"=sprintf("%.2g [%.2g, %.2g]%s (%.3g)%s", m$mediation$estimate[2], m$mediation$estimate_HDI_low[2], m$mediation$estimate_HDI_high[2], ifelse(m$mediation$estimate_HDI_low[2] < 0 & m$mediation$estimate_HDI_high[2] > 0, "", "*"), m$mediation$p_ROPE[2], ifelse(m$mediation$p_ROPE[2] < 0.05, "*", "")),
                                               "Ind"=sprintf("%.2g [%.2g, %.2g]%s (%.3g)%s", m$mediation$estimate[3], m$mediation$estimate_HDI_low[3], m$mediation$estimate_HDI_high[3], ifelse(m$mediation$estimate_HDI_low[3] < 0 & m$mediation$estimate_HDI_high[3] > 0, "", "*"), m$mediation$p_ROPE[3], ifelse(m$mediation$p_ROPE[2] < 0.05, "*", "")));
```


### Latitude → UV-B → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"latitude" "Latitude"  "treatment"
"UV.mean.TOMS"  "UV-B (mean; TOMS)"  "mediator"
"UV.sd.TOMS"  "UV-B (sd; TOMS)"  "mediator"
#"UV.mean.WC"  "UV-B (mean; WorldClim)"  "mediator"
#"UV.sd.WC"  "UV-B (sd; WorldClim)"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_lat_uvb__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_lat_uvb__blue <- list();
  
  # Fit the mediation model:
  # TOMS:
  bmed_lat_uvb__blue$toms$mean <- if(TRUE && .include.predictor("latitude") && .include.predictor("UV.mean.TOMS")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="UV_mean_r", mediator_name="UV-B (mean; TOMS)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_lat_uvb__blue$toms$sd <- if(TRUE && .include.predictor("latitude") && .include.predictor("UV.sd.TOMS")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="UV_sd_r", mediator_name="UV-B (sd; TOMS)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # WorldClim:
  bmed_lat_uvb__blue$wc$mean <- if(TRUE && .include.predictor("latitude") && .include.predictor("UV.mean.WC")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="UV_mean_wc_r", mediator_name="UV-B (mean; WC)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_lat_uvb__blue$wc$sd <- if(TRUE && .include.predictor("latitude") && .include.predictor("UV.sd.WC")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="UV_sd_wc_r", mediator_name="UV-B (sd; WC)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;

  # Save results:
  save(bmed_lat_uvb__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_uvb__blue$toms$mean)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_uvbmt__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_uvb__blue$toms$sd)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_uvbst__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_uvb__blue$wc$mean) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_uvbmw__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_uvb__blue$wc$sd) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_uvbsw__blue"); }
```


### Latitude → climate → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"latitude" "Latitude"  "treatment"
"PC1"  "Climate PC1"  "mediator"
"PC2"  "Climate PC2"  "mediator"
"PC3"  "Climate PC3"  "mediator"
"humidity.median"  "Humidity (median)"  "mediator"
"humidity.iqr"  "Humidity (IQR)"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_lat_clim__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_lat_clim__blue <- list();
  
  # Fit the mediation model:
  # PC1:
  bmed_lat_clim__blue$PC1 <- if(TRUE && .include.predictor("latitude") && .include.predictor("PC1")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="clim_PC1_r", mediator_name="climate PC1", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # PC2:
  bmed_lat_clim__blue$PC2 <- if(TRUE && .include.predictor("latitude") && .include.predictor("PC2")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="clim_PC2_r", mediator_name="climate PC2", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # PC3:
  bmed_lat_clim__blue$PC3 <- if(TRUE && .include.predictor("latitude") && .include.predictor("PC3")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="clim_PC3_r", mediator_name="climate PC3", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Humidity:
  bmed_lat_clim__blue$hummed <- if(TRUE && .include.predictor("latitude") && .include.predictor("humidity.median")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="hum_median", mediator_name="humidity (median)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_lat_clim__blue$humiqr <- if(TRUE && .include.predictor("latitude") && .include.predictor("humidity.iqr")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="hum_IQR", mediator_name="humidity (IQR)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_lat_clim__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_clim__blue$PC1)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_pc1__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_clim__blue$PC2)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_pc2__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_clim__blue$PC3)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_pc3__blue"); }
```


```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_clim__blue$hummed)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_hummed__blue"); }
```


```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_clim__blue$humiqr)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_humiqr__blue"); }
```


### Latitude → subsistence → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"latitude" "Latitude"  "treatment"
"subsistence"  "Subsistence"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_lat_sub__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_lat_sub__blue <- list();
  
  # Fit the mediation model (just one model here!):
  bmed_lat_sub__blue <- if(TRUE && .include.predictor("latitude") && .include.predictor("subsistence")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="subsistence", mediator_name="subsistence",
                         family_mediator=bernoulli("logit"), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_lat_sub__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. UV-B incidence from TOMS. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_sub__blue)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_sub__blue"); }
```


### Latitude → population size → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"latitude" "Latitude"  "treatment"
"popsize.ethno"  "Population size (Ethnologue)"  "mediator"
"popsize.wiki"  "Population size (Wikipedia)"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_lat_psize__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_lat_psize__blue <- list();
  
  # Fit the mediation model:
  # Ethnologue:
  bmed_lat_psize__blue$ethno <- if(TRUE && .include.predictor("latitude") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Wikipedia:
  bmed_lat_psize__blue$wiki <- if(TRUE && .include.predictor("latitude") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_lat_psize__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_psize__blue$ethno)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_psizeetno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_psize__blue$wiki)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_psizewiki__blue"); }
```


### Climate → subsistence → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"PC1" "Climate PC1"  "treatment"
"PC2" "Climate PC2"  "treatment"
"PC3" "Climate PC3"  "treatment"
"humidity.median" "Humidity (median)"  "treatment"
"humidity.iqr" "Humidity (IQR)"  "treatment"
"subsistence"  "Subsistence"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_clim_sub__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_clim_sub__blue <- list();
  
  # Fit the mediation model:
  # Climate:
  bmed_clim_sub__blue$PC1 <- if(TRUE && .include.predictor("PC1") && .include.predictor("subsistence")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="clim_PC1_r", treatment_name="climate PC1", 
                         mediator="subsistence", mediator_name="subsistence", 
                         family_mediator=bernoulli("logit"), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_clim_sub__blue$PC2 <- if(TRUE && .include.predictor("PC2") && .include.predictor("subsistence")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="clim_PC2_r", treatment_name="climate PC2", 
                         mediator="subsistence", mediator_name="subsistence", 
                         family_mediator=bernoulli("logit"), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_clim_sub__blue$PC3 <- if(TRUE && .include.predictor("PC3") && .include.predictor("subsistence")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="clim_PC3_r", treatment_name="climate PC3", 
                         mediator="subsistence", mediator_name="subsistence", 
                         family_mediator=bernoulli("logit"), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Humidity:
  bmed_clim_sub__blue$hummed <- if(TRUE && .include.predictor("humidity.median") && .include.predictor("subsistence")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="hum_median", treatment_name="humidity (median)", 
                         mediator="subsistence", mediator_name="subsistence", 
                         family_mediator=bernoulli("logit"), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_clim_sub__blue$humiqr <- if(TRUE && .include.predictor("humidity.iqr") && .include.predictor("subsistence")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="hum_IQR", treatment_name="humidity (median)", 
                         mediator="subsistence", mediator_name="subsistence", 
                         family_mediator=bernoulli("logit"), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_clim_sub__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_sub__blue$PC1)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_pc1_sub__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_sub__blue$PC2)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_pc2_sub__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_sub__blue$PC3)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_pc3_sub__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_sub__blue$hummed)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_hummed_sub__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_sub__blue$humiqr)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_humiqr_sub__blue"); }
```


### Climate → population size → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"PC1" "Climate PC1"  "treatment"
"PC2" "Climate PC2"  "treatment"
"PC3" "Climate PC3"  "treatment"
"humidity.median" "Humidity (median)"  "treatment"
"humidity.iqr" "Humidity (IQR)"  "treatment"
"popsize.ethno"  "Population size (Ethnologue)"  "mediator"
"popsize.wiki"  "Population size (Wikipedia)"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_clim_psiz__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_clim_psiz__blue <- list();
  
  # Fit the mediation model:
  # PC1:
  bmed_clim_psiz__blue$PC1 <- list();
  bmed_clim_psiz__blue$PC1$ethno <- if(TRUE && .include.predictor("PC1") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="clim_PC1_r", treatment_name="climate PC1", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)",  
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_clim_psiz__blue$PC1$wiki <- if(TRUE && .include.predictor("PC1") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="clim_PC1_r", treatment_name="climate PC1", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)",  
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # PC2:
  bmed_clim_psiz__blue$PC2 <- list();
  bmed_clim_psiz__blue$PC2$ethno <- if(TRUE && .include.predictor("PC2") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="clim_PC2_r", treatment_name="climate PC2", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)",  
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_clim_psiz__blue$PC2$wiki <- if(TRUE && .include.predictor("PC2") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="clim_PC2_r", treatment_name="climate PC2", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)",  
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # PC3:
  bmed_clim_psiz__blue$PC3 <- list();
  bmed_clim_psiz__blue$PC3$ethno <- if(TRUE && .include.predictor("PC3") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="clim_PC3_r", treatment_name="climate PC3", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)",  
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_clim_psiz__blue$PC3$wiki <- if(TRUE && .include.predictor("PC3") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="clim_PC3_r", treatment_name="climate PC3", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)",  
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Humidity (median):
  bmed_clim_psiz__blue$hummed <- list();
  bmed_clim_psiz__blue$hummed$ethno <- if(TRUE && .include.predictor("humidity.median") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="hum_median", treatment_name="Humidity (median)", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)",  
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_clim_psiz__blue$hummed$wiki <- if(TRUE && .include.predictor("humidity.median") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="hum_median", treatment_name="Humidity (median)", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)",  
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Humidity (IQR):
  bmed_clim_psiz__blue$humiqr <- list();
  bmed_clim_psiz__blue$humiqr$ethno <- if(TRUE && .include.predictor("humidity.iqr") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="hum_IQR", treatment_name="Humidity (IQR)", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)",  
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_clim_psiz__blue$humiqr$wiki <- if(TRUE && .include.predictor("humidity.iqr") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="hum_IQR", treatment_name="Humidity (IQR)", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)",  
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_clim_psiz__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_psiz__blue$PC1$ethno)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_pc1_psizethno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_psiz__blue$PC1$wiki)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_pc1_psizwiki__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_psiz__blue$PC2$ethno)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_pc2_psizethno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_psiz__blue$PC2$wiki)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_pc2_psizwiki__blue"); }
```


```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_psiz__blue$PC3$ethno)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_pc3_psizethno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_psiz__blue$PC3$wiki)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_pc3_psizwiki__blue"); }
```


```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_psiz__blue$hummed$ethno)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_hummed_psizethno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_psiz__blue$hummed$wiki)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_hummed_psizwiki__blue"); }
```


```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_psiz__blue$humiqr$ethno)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_humiqr_psizethno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_clim_psiz__blue$humiqr$wiki)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_humiqr_psizwiki__blue"); }
```


### UV-B → subsistence → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"UV.mean.TOMS" "UV-B (mean; TOMS)"  "treatment"
"UV.sd.TOMS" "UV-B (sd; TOMS)"  "treatment"
#"UV.mean.WC" "UV-B (mean; WorldClim)"  "treatment"
#"UV.sd.WC" "UV-B (sd; WorldClim)"  "treatment"
"subsistence"  "Subsistence"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_uvb_sub__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_uvb_sub__blue <- list();
  
  # Fit the mediation model:
  # TOMS:
  bmed_uvb_sub__blue$toms$mean <- if(TRUE && .include.predictor("UV.mean.TOMS") && .include.predictor("subsistence")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="UV_mean_r", treatment_name="UV-B (mean; TOMS)", 
                         mediator="subsistence", mediator_name="subsistence", 
                         family_mediator=bernoulli("logit"), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_uvb_sub__blue$toms$sd <- if(TRUE && .include.predictor("UV.sd.TOMS") && .include.predictor("subsistence")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="UV_sd_r", treatment_name="UV-B (sd; TOMS)", 
                         mediator="subsistence", mediator_name="subsistence", 
                         family_mediator=bernoulli("logit"), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # WolrdClim:
  bmed_uvb_sub__blue$wc$mean <- if(TRUE && .include.predictor("UV.mean.WC") && .include.predictor("subsistence")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="UV_mean_wc_r", treatment_name="UV-B (mean; WC)", 
                         mediator="subsistence", mediator_name="subsistence", 
                         family_mediator=bernoulli("logit"), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_uvb_sub__blue$wc$sd <- if(TRUE && .include.predictor("UV.sd.WC") && .include.predictor("subsistence")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="UV_sd_wc_r", treatment_name="UV-B (sd; WC)", 
                         mediator="subsistence", mediator_name="subsistence", 
                         family_mediator=bernoulli("logit"), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_uvb_sub__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_uvb_sub__blue$toms$mean)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_uvbmt_sub__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_uvb_sub__blue$toms$sd)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_uvbst_sub__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_uvb_sub__blue$wc$mean) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_uvbmw_sub__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_uvb_sub__blue$wc$sd) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_uvbsw_sub__blue"); }
```


### UV-B → population size → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"UV.mean.TOMS" "UV-B (mean; TOMS)"  "treatment"
"UV.sd.TOMS" "UV-B (sd; TOMS)"  "treatment"
#"UV.mean.WC" "UV-B (mean; WorldClim)"  "treatment"
#"UV.sd.WC" "UV-B (sd; WorldClim)"  "treatment"
"popsize.ethno"  "Population size (Ethnologue)"  "mediator"
"popsize.wiki"  "Population size (Wikipedia)"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_uvb_psiz__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_uvb_psize__blue <- list();
  
  # Fit the mediation model:
  # TOMS:
  bmed_uvb_psize__blue$toms <- list();
  bmed_uvb_psize__blue$toms$mean <- list();
  bmed_uvb_psize__blue$toms$sd <- list();
  # Ethnologue:
  bmed_uvb_psize__blue$toms$mean$ethno <- if(TRUE && .include.predictor("UV.mean.TOMS") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="UV_mean_r", treatment_name="UV-B (mean; TOMS)", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_uvb_psize__blue$toms$sd$ethno <- if(TRUE && .include.predictor("UV.sd.TOMS") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="UV_sd_r", treatment_name="UV-B (sd; TOMS)", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Wikipedia:
  bmed_uvb_psize__blue$toms$mean$wiki <- if(TRUE && .include.predictor("UV.mean.TOMS") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="UV_mean_r", treatment_name="UV-B (mean; TOMS)", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_uvb_psize__blue$toms$sd$wiki <- if(TRUE && .include.predictor("UV.sd.TOMS") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="UV_sd_r", treatment_name="UV-B (sd; TOMS)", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # WorldClim:
  bmed_uvb_psize__blue$wc <- list();
  bmed_uvb_psize__blue$wc$mean <- list();
  bmed_uvb_psize__blue$wc$sd <- list();
  # Ethnologue:
  bmed_uvb_psize__blue$wc$mean$ethno <- if(TRUE && .include.predictor("UV.mean.WC") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="UV_mean_wc_r", treatment_name="UV-B (mean; WC)", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_uvb_psize__blue$wc$sd$ethno <- if(TRUE && .include.predictor("UV.sd.WC") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="UV_sd_wc_r", treatment_name="UV-B (sd; WC)", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Wikipedia:
  bmed_uvb_psize__blue$wc$mean$wiki <- if(TRUE && .include.predictor("UV.mean.WC") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="UV_mean_wc_r", treatment_name="UV-B (mean; WC)", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_uvb_psize__blue$wc$sd$wiki <- if(TRUE && .include.predictor("UV.sd.WC") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="UV_sd_wc_r", treatment_name="UV-B (sd; WC)", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_uvb_psize__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_uvb_psize__blue$toms$mean$ethno)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_uvbmt_psizeethno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_uvb_psize__blue$toms$sd$ethno)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_uvbst_psizeethno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_uvb_psize__blue$toms$mean$wiki)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_uvbmt_psizewiki__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_uvb_psize__blue$toms$sd$wiki)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_uvbst_psizewiki__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_uvb_psize__blue$wc$mean$ethno) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_uvbmw_psizeethno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_uvb_psize__blue$wc$sd$ethno) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_uvbsw_psizeethno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_uvb_psize__blue$wc$mean$wiki) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_uvbmw_psizewiki__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_uvb_psize__blue$wc$sd$wiki) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_uvbsw_psizewiki__blue"); }
```


### Subsistence → population size → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"subsistence" "Subsistence"  "treatment"
"popsize.ethno"  "Population size (Ethnologue)"  "mediator"
"popsize.wiki"  "Population size (Wikipedia)"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_subs_psize__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_subs_psize__blue <- list();
  
  # Fit the mediation model:
  # Ethnologue:
  bmed_subs_psize__blue$ethno <- if(TRUE && .include.predictor("subsistence") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="subsistence", treatment_name="subsistence", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Wikipedia:
  bmed_subs_psize__blue$wiki <- if(TRUE && .include.predictor("subsistence") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="subsistence", treatment_name="subsistence", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_subs_psize__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_subs_psize__blue$ethno)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_subs_psizeethno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_subs_psize__blue$wiki)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_subs_psizewiki__blue"); }
```


### Dist2 waters → latitude → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"lakes" "Distance to lakes"  "treatment"
"rivers" "Distance to rivers"  "treatment"
"oceans" "Distance to oceans"  "treatment"
"water" "Distance to water in general"  "treatment"
"latitude"  "Latitude"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_d2w_lat__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_d2w_lat__blue <- list();
  
  # Fit the mediation models:
  bmed_d2w_lat__blue$lakes <- if(TRUE && .include.predictor("lakes") && .include.predictor("latitude")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2lakes_r", treatment_name="dist. to lakes", 
                         mediator="latitude_r", mediator_name="latitude", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_lat__blue$rivers <- if(TRUE && .include.predictor("rivers") && .include.predictor("latitude")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2rivers_r", treatment_name="dist. to rivers", 
                         mediator="latitude_r", mediator_name="latitude", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_lat__blue$oceans <- if(TRUE && .include.predictor("oceans") && .include.predictor("latitude")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2ocean_r", treatment_name="dist. to oceans", 
                         mediator="latitude_r", mediator_name="latitude", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_lat__blue$water <- if(TRUE && .include.predictor("water") && .include.predictor("latitude")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2water_r", treatment_name="dist. to water", 
                         mediator="latitude_r", mediator_name="latitude", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_d2w_lat__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_lat__blue$lakes)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_lat__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_lat__blue$rivers)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2r_lat__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_lat__blue$oceans)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2o_lat__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_lat__blue$water)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2w_lat__blue"); }
```


### Latitude → dist2 waters → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"latitude"  "Latitude"  "treatment"
"lakes" "Distance to lakes"  "mediator"
"rivers" "Distance to rivers"  "mediator"
"oceans" "Distance to oceans"  "mediator"
"water" "Distance to water in general"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_lat_d2w__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_lat_d2w__blue <- list();
  
  # Fit the mediation models:
  bmed_lat_d2w__blue$lakes <- if(TRUE && .include.predictor("lakes") && .include.predictor("latitude")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="dist2lakes_r", mediator_name="dist. to lakes", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_lat_d2w__blue$rivers <- if(TRUE && .include.predictor("rivers") && .include.predictor("latitude")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="dist2rivers_r", mediator_name="dist. to rivers", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_lat_d2w__blue$oceans <- if(TRUE && .include.predictor("oceans") && .include.predictor("latitude")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="dist2ocean_r", mediator_name="dist. to oceans", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_lat_d2w__blue$water <- if(TRUE && .include.predictor("water") && .include.predictor("latitude")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_r", treatment_name="latitude", 
                         mediator="dist2water_r", mediator_name="dist. to water", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_lat_d2w__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_d2w__blue$lakes)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_d2l__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_d2w__blue$rivers)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_d2r__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_d2w__blue$oceans)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_d2o__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_d2w__blue$water)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_d2w__blue"); }
```


### Dist2 waters → UV-B → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"lakes" "Distance to lakes"  "treatment"
"rivers" "Distance to rivers"  "treatment"
"oceans" "Distance to oceans"  "treatment"
"water" "Distance to water in general"  "treatment"
"UV.mean.TOMS"  "UV-B (mean; TOMS)"  "mediator"
"UV.sd.TOMS"  "UV-B (sd; TOMS)"  "mediator"
#"UV.mean.WC"  "UV-B (mean; WorldClim)"  "mediator"
#"UV.sd.WC"  "UV-B (sd; WorldClim)"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_d2w_uvb__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_d2w_uvb__blue <- list();
  
  # Fit the mediation models:
  # TOMS:
  # mean:
  bmed_d2w_uvb__blue$lakes$toms$mean <- if(TRUE && .include.predictor("lakes") && .include.predictor("UV.mean.TOMS")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2lakes_r", treatment_name="dist. to lakes", 
                         mediator="UV_mean_r", mediator_name="UV-B (mean; TOMS)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_uvb__blue$rivers$toms$mean <- if(TRUE && .include.predictor("rivers") && .include.predictor("UV.mean.TOMS")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2rivers_r", treatment_name="dist. to rivers", 
                         mediator="UV_mean_r", mediator_name="UV-B (mean; TOMS)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_uvb__blue$oceans$toms$mean <- if(TRUE && .include.predictor("oceans") && .include.predictor("UV.mean.TOMS")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2ocean_r", treatment_name="dist. to oceans", 
                         mediator="UV_mean_r", mediator_name="UV-B (mean; TOMS)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_uvb__blue$water$toms$mean <- if(TRUE && .include.predictor("water") && .include.predictor("UV.mean.TOMS")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2water_r", treatment_name="dist. to water", 
                         mediator="UV_mean_r", mediator_name="UV-B (mean; TOMS)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  # sd:
  bmed_d2w_uvb__blue$lakes$toms$sd <- if(TRUE && .include.predictor("lakes") && .include.predictor("UV.sd.TOMS")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2lakes_r", treatment_name="dist. to lakes", 
                         mediator="UV_sd_r", mediator_name="UV-B (sd; TOMS)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_uvb__blue$rivers$toms$sd <- if(TRUE && .include.predictor("rivers") && .include.predictor("UV.sd.TOMS")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2rivers_r", treatment_name="dist. to rivers", 
                         mediator="UV_sd_r", mediator_name="UV-B (sd; TOMS)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_uvb__blue$oceans$toms$sd <- if(TRUE && .include.predictor("oceans") && .include.predictor("UV.sd.TOMS")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2ocean_r", treatment_name="dist. to oceans", 
                         mediator="UV_sd_r", mediator_name="UV-B (sd; TOMS)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_uvb__blue$water$toms$sd <- if(TRUE && .include.predictor("water") && .include.predictor("UV.sd.TOMS")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2water_r", treatment_name="dist. to water", 
                         mediator="UV_sd_r", mediator_name="UV-B (sd; TOMS)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # WorldClim:
  # mean:
  bmed_d2w_uvb__blue$lakes$wc$mean <- if(TRUE && .include.predictor("lakes") && .include.predictor("UV.mean.WC")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2lakes_r", treatment_name="dist. to lakes", 
                         mediator="UV_mean_wc_r", mediator_name="UV-B (mean; WC)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_uvb__blue$rivers$wc$mean <- if(TRUE && .include.predictor("rivers") && .include.predictor("UV.mean.WC")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2rivers_r", treatment_name="dist. to rivers", 
                         mediator="UV_mean_wc_r", mediator_name="UV-B (mean; WC)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_uvb__blue$oceans$wc$mean <- if(TRUE && .include.predictor("oceans") && .include.predictor("UV.mean.WC")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2ocean_r", treatment_name="dist. to oceans", 
                         mediator="UV_mean_wc_r", mediator_name="UV-B (mean; WC)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_uvb__blue$water$wc$mean <- if(TRUE && .include.predictor("water") && .include.predictor("UV.mean.WC")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2water_r", treatment_name="dist. to water", 
                         mediator="UV_mean_wc_r", mediator_name="UV-B (mean; WC)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  # sd:
  bmed_d2w_uvb__blue$lakes$wc$sd <- if(TRUE && .include.predictor("lakes") && .include.predictor("UV.sd.WC")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2lakes_r", treatment_name="dist. to lakes", 
                         mediator="UV_sd_wc_r", mediator_name="UV-B (sd; WC)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_uvb__blue$rivers$wc$sd <- if(TRUE && .include.predictor("rivers") && .include.predictor("UV.sd.WC")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2rivers_r", treatment_name="dist. to rivers", 
                         mediator="UV_sd_wc_r", mediator_name="UV-B (sd; WC)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_uvb__blue$oceans$wc$sd <- if(TRUE && .include.predictor("oceans") && .include.predictor("UV.sd.WC")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2ocean_r", treatment_name="dist. to oceans", 
                         mediator="UV_sd_wc_r", mediator_name="UV-B (sd; WC)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_uvb__blue$water$wc$sd <- if(TRUE && .include.predictor("water") && .include.predictor("UV.sd.WC")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2water_r", treatment_name="dist. to water", 
                         mediator="UV_sd_wc_r", mediator_name="UV-B (sd; WC)",
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_d2w_uvb__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$lakes$toms$mean)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_uvbmt__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$rivers$toms$mean)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2r_uvbmt__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$oceans$toms$mean)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2o_uvbmt__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$water$toms$mean)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2w_uvbmt__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$lakes$toms$sd)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_uvbst__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$rivers$toms$sd)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2r_uvbst__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$oceans$toms$sd)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2o_uvbst__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$water$toms$sd)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2w_uvbst__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$lakes$wc$mean) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_uvbmw__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$rivers$wc$mean) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2r_uvbmw__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$oceans$wc$mean) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2o_uvbmw__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$water$wc$mean) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2w_uvbmw__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$lakes$wc$sd) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_uvbsw__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$rivers$wc$sd) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2r_uvbsw__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$oceans$wc$sd) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2o_uvbsw__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_uvb__blue$water$wc$sd) && FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2w_uvbsw__blue"); }
```


### Dist2 waters → climate → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"lakes" "Distance to lakes"  "treatment"
"rivers" "Distance to rivers"  "treatment"
"oceans" "Distance to oceans"  "treatment"
"water" "Distance to water in general"  "treatment"
"PC1"  "Climate PC1"  "mediator"
"PC2"  "Climate PC2"  "mediator"
"PC3"  "Climate PC3"  "mediator"
"humidity.median"  "Humidity (median)"  "mediator"
"humidity.iqr"  "Humidity (IQR)"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_d2w_clim__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_d2w_clim__blue <- list();
  
  # Fit the mediation models:
  # PC1:
  bmed_d2w_clim__blue$lakes$PC1 <- if(TRUE && .include.predictor("lakes") && .include.predictor("PC1")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2lakes_r", treatment_name="dist. to lakes", 
                         mediator="clim_PC1_r", mediator_name="climate PC1", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$rivers$PC1 <- if(TRUE && .include.predictor("rivers") && .include.predictor("PC1")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2rivers_r", treatment_name="dist. to rivers", 
                         mediator="clim_PC1_r", mediator_name="climate PC1", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$oceans$PC1 <- if(TRUE && .include.predictor("oceans") && .include.predictor("PC1")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2ocean_r", treatment_name="dist. to oceans", 
                         mediator="clim_PC1_r", mediator_name="climate PC1", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$water$PC1 <- if(TRUE && .include.predictor("water") && .include.predictor("PC1")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2water_r", treatment_name="dist. to water", 
                         mediator="clim_PC1_r", mediator_name="climate PC1", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # PC2:
  bmed_d2w_clim__blue$lakes$PC2 <- if(TRUE && .include.predictor("lakes") && .include.predictor("PC2")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2lakes_r", treatment_name="dist. to lakes", 
                         mediator="clim_PC2_r", mediator_name="climate PC2", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$rivers$PC2 <- if(TRUE && .include.predictor("rivers") && .include.predictor("PC2")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2rivers_r", treatment_name="dist. to rivers", 
                         mediator="clim_PC2_r", mediator_name="climate PC2", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$oceans$PC2 <- if(TRUE && .include.predictor("oceans") && .include.predictor("PC2")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2ocean_r", treatment_name="dist. to oceans", 
                         mediator="clim_PC2_r", mediator_name="climate PC2", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$water$PC2 <- if(TRUE && .include.predictor("water") && .include.predictor("PC2")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2water_r", treatment_name="dist. to water", 
                         mediator="clim_PC2_r", mediator_name="climate PC2", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # PC3:
  bmed_d2w_clim__blue$lakes$PC3 <- if(TRUE && .include.predictor("lakes") && .include.predictor("PC3")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2lakes_r", treatment_name="dist. to lakes", 
                         mediator="clim_PC3_r", mediator_name="climate PC3", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$rivers$PC3 <- if(TRUE && .include.predictor("rivers") && .include.predictor("PC3")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2rivers_r", treatment_name="dist. to rivers", 
                         mediator="clim_PC3_r", mediator_name="climate PC3", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$oceans$PC3 <- if(TRUE && .include.predictor("oceans") && .include.predictor("PC3")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2ocean_r", treatment_name="dist. to oceans", 
                         mediator="clim_PC3_r", mediator_name="climate PC3", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$water$PC3 <- if(TRUE && .include.predictor("water") && .include.predictor("PC3")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2water_r", treatment_name="dist. to water", 
                         mediator="clim_PC3_r", mediator_name="climate PC3", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Humidity (median):
  bmed_d2w_clim__blue$lakes$hummed <- if(TRUE && .include.predictor("lakes") && .include.predictor("humidity.median")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2lakes_r", treatment_name="dist. to lakes", 
                         mediator="hum_median", mediator_name="humidity (median)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$rivers$hummed <- if(TRUE && .include.predictor("rivers") && .include.predictor("humidity.median")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2rivers_r", treatment_name="dist. to rivers", 
                         mediator="hum_median", mediator_name="humidity (median)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$oceans$hummed <- if(TRUE && .include.predictor("oceans") && .include.predictor("humidity.median")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2ocean_r", treatment_name="dist. to oceans", 
                         mediator="hum_median", mediator_name="humidity (median)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$water$hummed <- if(TRUE && .include.predictor("water") && .include.predictor("humidity.median")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2water_r", treatment_name="dist. to water", 
                         mediator="hum_median", mediator_name="humidity (median)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Humidity (IQR):
  bmed_d2w_clim__blue$lakes$humiqr <- if(TRUE && .include.predictor("lakes") && .include.predictor("humidity.iqr")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2lakes_r", treatment_name="dist. to lakes", 
                         mediator="hum_IQR", mediator_name="humidity (IQR)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$rivers$humiqr <- if(TRUE && .include.predictor("rivers") && .include.predictor("humidity.iqr")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2rivers_r", treatment_name="dist. to rivers", 
                         mediator="hum_IQR", mediator_name="humidity (IQR)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$oceans$humiqr <- if(TRUE && .include.predictor("oceans") && .include.predictor("humidity.iqr")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2ocean_r", treatment_name="dist. to oceans", 
                         mediator="hum_IQR", mediator_name="humidity (IQR)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_clim__blue$water$humiqr <- if(TRUE && .include.predictor("water") && .include.predictor("humidity.iqr")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2water_r", treatment_name="dist. to water", 
                         mediator="hum_IQR", mediator_name="humidity (IQR)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_d2w_clim__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$lakes$PC1)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_pc1__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$lakes$PC2)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_pc2__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$lakes$PC3)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_pc3__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$lakes$hummed)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_hummed__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$lakes$humiqr)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_humiqr__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$rivers$PC1)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2r_pc1__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$rivers$PC2)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2r_pc2__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$rivers$PC3)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2r_pc3__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$rivers$hummed)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2r_hummed__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$rivers$humiqr)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2r_humiqr__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$oceans$PC1)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2o_pc1__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$oceans$PC2)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2o_pc2__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$oceans$PC3)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2o_pc3__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$oceans$hummed)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2o_hummed__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$oceans$humiqr)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2o_humiqr__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$water$PC1)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2w_pc1__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$water$PC2)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2w_pc2__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$water$PC3)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2w_pc3__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$water$hummed)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2w_hummed__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_clim__blue$water$humiqr)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2w_humiqr__blue"); }
```


### Dist2 waters → subsistence → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"lakes" "Distance to lakes"  "treatment"
"rivers" "Distance to rivers"  "treatment"
"oceans" "Distance to oceans"  "treatment"
"water" "Distance to water in general"  "treatment"
"subsistence"  "Subsistence"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_d2w_subs__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_d2w_subs__blue <- list();
  
  # Fit the mediation models:
  bmed_d2w_subs__blue$lakes <- if(TRUE && .include.predictor("lakes") && .include.predictor("subsistence")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2lakes_r", treatment_name="dist. to lakes", 
                         mediator="subsistence", mediator_name="subsistence", 
                         family_mediator=bernoulli("logit"), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_subs__blue$rivers <- if(TRUE && .include.predictor("rivers") && .include.predictor("subsistence")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2rivers_r", treatment_name="dist. to rivers", 
                         mediator="subsistence", mediator_name="subsistence", 
                         family_mediator=bernoulli("logit"), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_subs__blue$oceans <- if(TRUE && .include.predictor("oceans") && .include.predictor("subsistence")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2ocean_r", treatment_name="dist. to oceans", 
                         mediator="subsistence", mediator_name="subsistence", 
                         family_mediator=bernoulli("logit"), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_subs__blue$water <- if(TRUE && .include.predictor("water") && .include.predictor("subsistence")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2water_r", treatment_name="dist. to water", 
                         mediator="subsistence", mediator_name="subsistence", 
                         family_mediator=bernoulli("logit"), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_d2w_subs__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_subs__blue$lakes)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_subs__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_subs__blue$rivers)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2r_subs__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_subs__blue$oceans)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2o_subs__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_subs__blue$water)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2w_subs__blue"); }
```


### Dist2 waters → population size → 'blue'

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"lakes" "Distance to lakes"  "treatment"
"rivers" "Distance to rivers"  "treatment"
"oceans" "Distance to oceans"  "treatment"
"water" "Distance to water in general"  "treatment"
"popsize.ethno"  "Population size (Ethnologue)"  "mediator"
"popsize.wiki"  "Population size (Wikipedia)"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

```{r include=FALSE}
file_name <- "./cached_results/bmed_d2w_psiz__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_d2w_psiz__blue <- list();
  
  # Fit the mediation models:
  # Ethnologue:
  bmed_d2w_psiz__blue$lakes$ethno <- if(TRUE && .include.predictor("lakes") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2lakes_r", treatment_name="dist. to lakes", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_psiz__blue$rivers$ethno <- if(TRUE && .include.predictor("rivers") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2rivers_r", treatment_name="dist. to rivers", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_psiz__blue$oceans$ethno <- if(TRUE && .include.predictor("oceans") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2ocean_r", treatment_name="dist. to oceans", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_psiz__blue$water$ethno <- if(TRUE && .include.predictor("water") && .include.predictor("popsize.ethno")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2water_r", treatment_name="dist. to water", 
                         mediator="log_popSize_ethno", mediator_name="pop. size (Ethnologue)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Wikipedia:
  bmed_d2w_psiz__blue$lakes$wiki <- if(TRUE && .include.predictor("lakes") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2lakes_r", treatment_name="dist. to lakes", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_psiz__blue$rivers$wiki <- if(TRUE && .include.predictor("rivers") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2rivers_r", treatment_name="dist. to rivers", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_psiz__blue$oceans$wiki <- if(TRUE && .include.predictor("oceans") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2ocean_r", treatment_name="dist. to oceans", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_d2w_psiz__blue$water$wiki <- if(TRUE && .include.predictor("water") && .include.predictor("popsize.wiki")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="dist2water_r", treatment_name="dist. to water", 
                         mediator="log_popSize_wiki", mediator_name="pop. size (Wikipedia)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_d2w_psiz__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_psiz__blue$lakes$ethno)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_psizethno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_psiz__blue$rivers$ethno)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2r_psizethno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_psiz__blue$oceans$ethno)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2o_psizethno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_psiz__blue$water$ethno)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_psizethno__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_psiz__blue$lakes$wiki)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_psizwiki__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_psiz__blue$rivers$wiki)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2r_psizwiki__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_psiz__blue$oceans$wiki)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2o_psizwiki__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_d2w_psiz__blue$water$wiki)}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_d2l_psizwiki__blue"); }
```

<!--
### Family: latitude → UV-B → 'blue'

This tests if, *at the family level*, the a priori hypothesis still holds.

Variable effects: 

```{r}
df <- read.table(text=
'"var" "name" "type"
"latitude.fam" "Latitude (family)"  "treatment"
"UV.fams.mean.TOMS"  "UV-B (mean family; TOMS)"  "mediator"
"UV.fams.sd.TOMS"  "UV-B (sd family; TOMS)"  "mediator"
', header=TRUE, quote='"');
df$include <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**&#9745;**", ""), character(1));
df$name <- paste0((x <- vapply(df$var, function(x) ifelse(.include.predictor(x), "**", ""), character(1))), df$name, x);
knitr::kable(df[,c("type", "name", "var", "include")], 
             row.names=FALSE, 
             col.names=c("Type", "Variable", "Variable ID", "Include?"), 
             caption="Variables to include (or not) in the mediation model, either because they have an individual effect on 'blue' (i.e., the regression of 'blue' on them is 'significant') and/or because they are *a priori* judged to be relevant.");
```

It is **extremely** slow to run and we don't really expect anything interesting, so we skip it for now...

```{r include=FALSE, eval=FALSE}
file_name <- "./cached_results/bmed_lat_uvb__blue_fam.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_lat_uvb__blue_fam <- list();
  
  # Fit the mediation model:
  # TOMS:
  bmed_lat_uvb__blue_fam$toms$mean <- if(TRUE && .include.predictor("latitude.fam") && .include.predictor("UV.fams.mean.TOMS")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_family_r", treatment_name="latitude (family)", 
                         mediator="UV_mean_family_r", mediator_name="UV-B (mean family; TOMS)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  bmed_lat_uvb__blue_fam$toms$sd <- if(TRUE && .include.predictor("latitude.fam") && .include.predictor("UV.fams.sd.TOMS")) 
    .fit_mediation_model(d=d_colors_ag, 
                         outcome="exists_blue", outcome_name="blue", 
                         treatment="latitude_family_r", treatment_name="latitude (family)", 
                         mediator="UV_sd_family_r", mediator_name="UV-B (sd family; TOMS)", 
                         family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                         cores=brms_ncores, iter=med_iter, warmup=med_warmup, thin=med_thin, control=med_control,
                         save_model=FALSE, show_results=TRUE) else NULL;
  
  # Save results:
  save(bmed_lat_uvb__blue_fam, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=FALSE && !is.null(m <- bmed_lat_uvb__blue_fam$toms$mean), eval=FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_uvbmt__blue"); }
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=FALSE && !is.null(m <- bmed_lat_uvb__blue_fam$toms$sd), eval=FALSE}
if( !is.null(m) ){ med.res <- rbind(med.res, .summarize.mediation(m)); .plot_mediation(m, save_to_pdf="med_lat_uvbst__blue"); }
```
-->


### Summary

In summary, we have found the following:

```{r}
kable(med.res[,-1], row.names=FALSE, 
      col.names=c("treatment (T)", "mediator (M)", "T → M", "M → O", "T → O", "Total", "Direct", "Indirect"), 
      caption=capTab("Summary of the mediation models, showing the three variables involved (the outcome ) is always 'blue' and is not shown to save space), the individual regression conefficients between them (with their 95% HDIs), as well as the effect decomposition (estimate, 95% HDI and p(ROPE))."));
```

Thus, the data supports the following mediation pathways:

```{r fig.cap=capFig("The links supported by the mediation and regression analyses. Edges: solid blue = negative effects, solid red = positive effects, solid magenta represents the partial effect of latitude which is sometimes positive and sometimes negative, and dashed gray = null effects; for dist2lakes → blue, the dashing represents the fact that sometimes it is significiant and sometimes it is almost so (but always negative). Nodes: 'blue' in blue is the outcome, 'UV-B' in green is of particular interest here, light yellow have an effect on 'blue', while light gray do not. This should *not* be interpreted as a path diagram!", TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=12, fig.height=10}

DiagrammeR::grViz(paste0('
  digraph full_blue_a {

  # the graph:
  graph [overlap = true]
  rankdir="LR";

  # the nodes:
  node [shape = box, style = "filled", fillcolor = "lightyellow"];
  blue [label = "blue", tooltip = "blue", fillcolor="deepskyblue"]; 
  UVBm [label = "UV-B (mean)", tooltip = "UV-B (mean)", fillcolor="seagreen1"]; 
  UVBs [label = "UV-B (sd)", tooltip = "UV-B (sd)", fillcolor="seagreen1"]; 
  lat  [label = "latitude", tooltip = "latitude"]; 
  clim [label = "climate PC1", tooltip = "climate PC1", fillcolor = "grey90"]; 
  subs [label = "subsistence", tooltip = "subsistence"]; 
  psiz [label = "pop_size", tooltip = "pop size (Ethnologue)", fillcolor = "grey90"]; 
  d2l  [label = "dist2lakes", tooltip = "dist2lakes", fillcolor = "floralwhite"]; 
  #d2w  [label = "dist2water", tooltip = "dist2water", fillcolor = "grey90"]; 

  # the edges:
  edge [style = "solid", color = "black"];
  
  lat  -> UVBm  [label="-", color="blue", fontcolor="blue"]
  lat  -> UVBs  [label="+", color="red", fontcolor="red"]
  lat  -> d2l   [label="-", color="blue", fontcolor="blue"]
  #lat  -> d2w   [label="-", color="blue", fontcolor="blue"]
  UVBm -> blue  [label="-", color="blue", fontcolor="blue"]
  UVBs -> blue  [label="+", color="red", fontcolor="red"]
  lat  -> subs  [label="-", color="blue", fontcolor="blue"]
  clim -> subs  [label="+", color="red", fontcolor="red"]
  clim -> psiz  [label="0", color="gray80", fontcolor="gray80", style="dashed"]
  lat  -> psiz  [label="-", color="blue", fontcolor="blue"]
  UVBm -> psiz  [label="+", color="red", fontcolor="red"]
  UVBs -> psiz  [label="-", color="blue", fontcolor="blue"]
  d2l  -> lat   [label="-", color="blue", fontcolor="blue"]
  d2l  -> UVBm  [label="+", color="red", fontcolor="red"]
  d2l  -> UVBs  [label="-", color="blue", fontcolor="blue"]
  d2l  -> clim  [label="+", color="red", fontcolor="red"]
  d2l  -> subs  [label="0", color="gray80", fontcolor="gray80", style="dashed"]
  d2l  -> psiz  [label="-", color="blue", fontcolor="blue"]
  #d2w  -> lat   [label="-", color="blue", fontcolor="blue"]
  #d2w  -> UVBm  [label="+", color="red", fontcolor="red"]
  #d2w  -> UVBs  [label="-", color="blue", fontcolor="blue"]
  #d2w  -> clim  [label="0", color="gray80", fontcolor="gray80", style="dashed"]
  #d2w  -> subs  [label="0", color="gray80", fontcolor="gray80", style="dashed"]
  #d2w  -> psiz  [label="-", color="blue", fontcolor="blue"]
  #d2w  -> psiz  [label="-", color="blue", fontcolor="blue"]
  UVBm -> subs  [label="+", color="red", fontcolor="red"]
  UVBs -> subs  [label="-", color="blue", fontcolor="blue"]
  
  lat  -> clim  [label="-", color="blue", fontcolor="blue"]
  subs -> psiz  [label="+", color="red", fontcolor="red"]
  
  lat  -> blue  [label="±", color="magenta", fontcolor="magenta"]
  clim -> blue  [label="0", color="gray80", fontcolor="gray80", style="dashed"]
  subs -> blue  [label="+", color="red", fontcolor="red"]
  psiz -> blue  [label="0", color="gray80", fontcolor="gray80", style="dashed"]
  d2l  -> blue  [label="-", color="blue", fontcolor="blue", style="dashed"]
  #d2w  -> blue  [label="0", color="gray80", fontcolor="gray80", style="dashed"]
}
'))
```


## Path analysis

Please note that:

- we coded the endogenous variables *blue* and *subsistence* as `ordered` (as "no" < "yes", and 'HG' <  'AGR', respectively) as per https://lavaan.ugent.be/tutorial/cat.html;
- by default, `lavaan` does not estimate the residual variances of categorical endogenous variables (here, *blue* and *subsistence*), and we did not change this behaviour.

For details about interpreting the results of a path analysis or SEM model, please see [here](https://www.statisticssolutions.com/factor-analysis-sem-path-analysis/), [here](http://davidakenny.net/cm/fit.htm), [here](https://methodenlehre.github.io/SGSCLM-R-course/cfa-and-sem-with-lavaan.html) or [here](https://ninamclean.weebly.com/statistics-and-other-bits-and-pieces/interpreting-results-from-path-analysis), but the main ideas are that the *&chi;*^2^ test should **not** be significant, that the various *fit indices* (such as the Comparative Fit Index (CFI), the Tucker-Lewis Index (TLI), and the Non-normed Fit Index (NNFI)) should be as close to 1.0 as possible (ok if ≥ 0.90), and that the Root Mean Square Error of Approximation (RMSEA) should be as small as possible (≤ 0.05) with a narrow 90% confidence interval (ideally with the lower limit very close to 0.0 and the upper limit ≤ 0.08).


```{r include=FALSE}
file_name <- "./cached_results/sem_blue.RData";
if( !all(file.exists(file_name)) )
{
  # The data:
  d_colors_lavaan <- d_colors_ag[,c("glottocode", "glottocode_family", "macroarea", 
                                 "exists_blue", "UV_mean_r", "UV_sd_r", "latitude_r", "dist2lakes_r", "clim_PC1_r", "log_popSize_ethno", "subsistence",
                                 "clim_PC1_r", "clim_PC2_r", "clim_PC3_r")];
  names(d_colors_lavaan) <- c("glottocode", "glottocode_family", "macroarea", 
                                 "blue", "uvbm", "uvbs", "lat", "d2l", "clim", "psiz", "subs", "cpc1", "cpc2", "cpc3");
  # Binary variables recoding (as per https://lavaan.ugent.be/tutorial/cat.html):
  d_colors_lavaan$blue <- ordered(d_colors_lavaan$blue, levels=c("no","yes")); # this is an endogenous (dependent) variable -> make it ordered
  d_colors_lavaan$subs <- ordered(d_colors_lavaan$subs, levels=c("HG","AGR")); # this is an endogenous (dependent) variable -> make it ordered
  # z-score psiz as well:
  d_colors_lavaan$psiz <- scale(d_colors_lavaan$psiz, center=TRUE, scale=TRUE);
  
  # The full SEM model with all potential predictors (basically, the previous model of Josserand et al, 2021):
  # 1. using mean UV-B incidence (exactly as in Josserand et al, 2021):
  sem_blue_j21_full_UVm <- '
    # blue:
    blue ~ b_bum * uvbm  # uvbm ---> blue 
         #+ b_bus * uvbs  # uvbs ---> blue 
         + b_bdl * d2l   # d2l  ---> blue 
         + b_bsu * subs  # subs ---> blue 
         + b_bcl * clim  # clim ---> blue
         + b_bla * lat   # lat  ---> blue
         + b_bps * psiz  # psiz ---> blue

    # UV-B incidence:   
    uvbm  ~ b_uml * lat  # lat  ---> uvbm  
    #uvbs  ~ b_usl * lat  # lat  ---> uvbs  
    #uvbm ~~ uvbs
    uvbm ~~ clim
    #uvbs ~~ clim
    uvbm ~~ d2l
    #uvbs ~~ d2l
    
    # Climate:
    clim ~ b_cla * lat  # lat  ---> clim

    # Distance to lakes:  
    d2l  ~ b_dla * lat  # lat  ---> d2l
    
    # Subsistence:
    subs ~ b_sla * lat  # lat  ---> subs 
         + b_sdl * d2l  # d2l  ---> subs
         + b_sum * uvbm # uvbm ---> subs
         #+ b_sus * uvbs # uvbs ---> subs
         + b_scl * clim # clim ---> subs
         
    # Population size:
    psiz ~ b_psu * subs # subs ---> psiz 
         + b_pla * lat  # lat  ---> psiz 
         + b_pdl * d2l  # d2l  ---> psiz
         + b_pum * uvbm # uvbm ---> psiz
         #+ b_pus * uvbs # uvbs ---> psiz
         + b_pcl * clim # clim ---> psiz

  ';
  semfit_blue_j21_full_UVm <- sem(sem_blue_j21_full_UVm, data=d_colors_lavaan, se="robust.sem"); # convergence ok; p=0.033
  summary(semfit_blue_j21_full_UVm, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE);
  lavaanPlot(model=semfit_blue_j21_full_UVm, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
  #semPaths(semfit_blue_j21_full_UVm, what="est", edge.label.cex = 1.5, fade = FALSE)
  fitMeasures(semfit_blue_j21_full_UVm, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")); # not bad but not amazing either
  mi <- modindices(semfit_blue_j21_full_UVm, sort=TRUE); mi; # no meaningful suggestions...

  # 2. using sd UV-B incidence:
  sem_blue_j21_full_UVs <- '
    # blue:
    blue ~ #b_bum * uvbm  # uvbm ---> blue 
         + b_bus * uvbs  # uvbs ---> blue 
         + b_bdl * d2l   # d2l  ---> blue 
         + b_bsu * subs  # subs ---> blue 
         + b_bcl * clim  # clim ---> blue
         + b_bla * lat   # lat  ---> blue
         + b_bps * psiz  # psiz ---> blue

    # UV-B incidence:   
    #uvbm  ~ b_uml * lat  # lat  ---> uvbm  
    uvbs  ~ b_usl * lat  # lat  ---> uvbs  
    #uvbm ~~ uvbs
    #uvbm ~~ clim
    uvbs ~~ clim
    #uvbm ~~ d2l
    uvbs ~~ d2l
    
    # Climate:
    clim ~ b_cla * lat  # lat  ---> clim
       
    # Distance to lakes:  
    d2l  ~ b_dla * lat  # lat  ---> d2l
    
    # Subsistence:
    subs ~ b_sla * lat  # lat  ---> subs 
         + b_sdl * d2l  # d2l  ---> subs
         #+ b_sum * uvbm # uvbm ---> subs
         + b_sus * uvbs # uvbs ---> subs
         + b_scl * clim # clim ---> subs
         
    # Population size:
    psiz ~ b_psu * subs # subs ---> psiz 
         + b_pla * lat  # lat  ---> psiz 
         + b_pdl * d2l  # d2l  ---> psiz
         #+ b_pum * uvbm # uvbm ---> psiz
         + b_pus * uvbs # uvbs ---> psiz
         + b_pcl * clim # clim ---> psiz

  ';
  semfit_blue_j21_full_UVs <- sem(sem_blue_j21_full_UVs, data=d_colors_lavaan, se="robust.sem"); # convergence ok; p=0.033
  summary(semfit_blue_j21_full_UVs, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE);
  lavaanPlot(model=semfit_blue_j21_full_UVs, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
  #semPaths(semfit_blue_j21_full_UVs, what="est", edge.label.cex = 1.5, fade = FALSE)
  fitMeasures(semfit_blue_j21_full_UVs, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")); # not bad but not amazing either
  mi <- modindices(semfit_blue_j21_full_UVs); mi;

  # 3. using both mean and sd UV-B incidence:
  sem_blue_j21_full_UVb <- '
    # blue:
    blue ~ b_bum * uvbm  # uvbm ---> blue 
         + b_bus * uvbs  # uvbs ---> blue 
         + b_bdl * d2l   # d2l  ---> blue 
         + b_bsu * subs  # subs ---> blue 
         + b_bcl * clim  # clim ---> blue
         + b_bla * lat   # lat  ---> blue
         + b_bps * psiz  # psiz ---> blue

    # UV-B incidence:   
    uvbm  ~ b_uml * lat  # lat  ---> uvbm  
    uvbs  ~ b_usl * lat  # lat  ---> uvbs  
    uvbm ~~ uvbs
    uvbm ~~ clim
    uvbs ~~ clim
    uvbm ~~ d2l
    uvbs ~~ d2l
    
    # Climate:
    clim ~ b_cla * lat  # lat  ---> clim
       
    # Distance to lakes:  
    d2l  ~ b_dla * lat  # lat  ---> d2l
    
    # Subsistence:
    subs ~ b_sla * lat  # lat  ---> subs 
         + b_sdl * d2l  # d2l  ---> subs
         + b_sum * uvbm # uvbm ---> subs
         + b_sus * uvbs # uvbs ---> subs
         + b_scl * clim # clim ---> subs
         
    # Population size:
    psiz ~ b_psu * subs # subs ---> psiz 
         + b_pla * lat  # lat  ---> psiz 
         + b_pdl * d2l  # d2l  ---> psiz
         + b_pum * uvbm # uvbm ---> psiz
         + b_pus * uvbs # uvbs ---> psiz
         + b_pcl * clim # clim ---> psiz

  ';
  semfit_blue_j21_full_UVb <- sem(sem_blue_j21_full_UVb, data=d_colors_lavaan, se="robust.sem"); # convergence ok; p=0.033
  summary(semfit_blue_j21_full_UVb, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE);
  lavaanPlot(model=semfit_blue_j21_full_UVb, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
  #semPaths(semfit_blue_j21_full_UVb, what="est", edge.label.cex = 1.5, fade = FALSE)
  fitMeasures(semfit_blue_j21_full_UVb, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")); # not bad but not amazing either
  mi <- modindices(semfit_blue_j21_full_UVb); mi;
  
  # Let's compare (1), (2) and (3):
  cat("mean(UV-B):\n");              fitMeasures(semfit_blue_j21_full_UVm, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi"));
  cat("sd(UV-B):\n");                fitMeasures(semfit_blue_j21_full_UVs, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi"));
  cat("mean(UV-B) and sd(UV-B):\n"); fitMeasures(semfit_blue_j21_full_UVb, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi"));
  # -> the highest fit indices (but by very little) are for mean(UV-B); 
  #    the mean and sd models are virtually identical; 
  #    when modeling both, mean is "kicked out" by sd;
  #    so, the overall story of Josserand et al (2021) holds, namely that high UV-B (or, equivalently, low UV-B variation) negatively influence 'blue'.
  # However these full models don't fit the data well enough, but trying to remove variables and/or links does not seem to really improve it....

  
  # Now, as per Josserand et al (2021), really keep as causal only those that make a priori sense and make the others a correlations:
  # 4. derived from (1), i.e., using mean(UV-B):
  sem_blue_j21_corr_UVm <- '
    # blue:
    blue ~ b_bum * uvbm  # uvbm ---> blue 
         #+ b_bus * uvbs  # uvbs ---> blue 
         + b_bdl * d2l   # d2l  ---> blue 
         + b_bsu * subs  # subs ---> blue 
         + b_bcl * clim  # clim ---> blue
         + b_bps * psiz  # psiz ---> blue

    # UV-B incidence:   
    uvbm  ~ b_uml * lat  # lat  ---> uvbm  
    #uvbs  ~ b_usl * lat  # lat  ---> uvbs  
    #uvbm ~~ uvbs
    uvbm ~~ clim
    #uvbs ~~ clim

    # Climate:
    clim ~ b_cla * lat  # lat  ---> clim

    # Distance to lakes:  
    d2l ~~ lat
    d2l ~~ clim
    
    # Subsistence:
    subs ~ b_sla * lat  # lat  ---> subs 
    subs ~~ clim
    subs ~~ psiz
    subs ~~ uvbm
    #subs ~~ uvbs
    subs ~~ d2l

    # Population size:
    psiz ~ b_pls * lat  # lat  ---> psiz 
         + b_pcl * clim  # clim  ---> psiz
    psiz ~~ d2l

  ';
  semfit_blue_j21_corr_UVm <- sem(sem_blue_j21_corr_UVm, data=d_colors_lavaan, se="robust.sem"); # convergence ok; p=0.954
  summary(semfit_blue_j21_corr_UVm, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE);
  lavaanPlot(model=semfit_blue_j21_corr_UVm, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
  #semPaths(semfit_blue_j21_corr_UVm, what="est", edge.label.cex = 1.5, fade = FALSE)
  fitMeasures(semfit_blue_j21_corr_UVm, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")); # much better!
  mi <- modindices(semfit_blue_j21_corr_UVm, sort=TRUE); mi;

  # 5. derived from (2), i.e., using sd(UV-B):
  sem_blue_j21_corr_UVs <- '
    # blue:
    blue ~ #b_bum * uvbm  # uvbm ---> blue 
         + b_bus * uvbs  # uvbs ---> blue 
         + b_bdl * d2l   # d2l  ---> blue 
         + b_bsu * subs  # subs ---> blue 
         + b_bcl * clim  # clim ---> blue
         + b_bps * psiz  # psiz ---> blue

    # UV-B incidence:   
    #uvbm  ~ b_uml * lat  # lat  ---> uvbm  
    uvbs  ~ b_usl * lat  # lat  ---> uvbs  
    #uvbm ~~ uvbs
    #uvbm ~~ clim
    uvbs ~~ clim

    # Climate:
    clim ~ b_cla * lat  # lat  ---> clim

    # Distance to lakes:  
    d2l ~~ lat
    d2l ~~ clim
    
    # Subsistence:
    subs ~ b_sla * lat  # lat  ---> subs 
    subs ~~ clim
    subs ~~ psiz
    #subs ~~ uvbm
    subs ~~ uvbs
    subs ~~ d2l

    # Population size:
    psiz ~ b_pls * lat  # lat  ---> psiz 
         + b_pcl * clim  # clim  ---> psiz
    psiz ~~ d2l

  ';
  semfit_blue_j21_corr_UVs <- sem(sem_blue_j21_corr_UVs, data=d_colors_lavaan, se="robust.sem"); # convergence ok; p=0.999
  summary(semfit_blue_j21_corr_UVs, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE);
  lavaanPlot(model=semfit_blue_j21_corr_UVs, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
  #semPaths(semfit_blue_j21_corr_UVs, what="est", edge.label.cex = 1.5, fade = FALSE)
  fitMeasures(semfit_blue_j21_corr_UVs, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")); # much better!
  mi <- modindices(semfit_blue_j21_corr_UVs, sort=TRUE); mi;

  # 6. derived from (3), i.e., using both mean(UV-B) and sd(UV-B):
  sem_blue_j21_corr_UVb <- '
    # blue:
    blue ~ b_bum * uvbm  # uvbm ---> blue 
         + b_bus * uvbs  # uvbs ---> blue 
         + b_bdl * d2l   # d2l  ---> blue 
         + b_bsu * subs  # subs ---> blue 
         + b_bcl * clim  # clim ---> blue
         + b_bps * psiz  # psiz ---> blue

    # UV-B incidence:   
    uvbm  ~ b_uml * lat  # lat  ---> uvbm  
    uvbs  ~ b_usl * lat  # lat  ---> uvbs  
    uvbm ~~ uvbs
    uvbm ~~ clim
    uvbs ~~ clim

    # Climate:
    clim ~ b_cla * lat  # lat  ---> clim

    # Distance to lakes:  
    d2l ~~ lat
    d2l ~~ clim
    
    # Subsistence:
    subs ~ b_sla * lat  # lat  ---> subs 
    subs ~~ clim
    subs ~~ psiz
    subs ~~ uvbm
    subs ~~ uvbs
    subs ~~ d2l

    # Population size:
    psiz ~ b_pls * lat  # lat  ---> psiz 
         + b_pcl * clim  # clim  ---> psiz
    psiz ~~ d2l

  ';
  semfit_blue_j21_corr_UVb <- sem(sem_blue_j21_corr_UVb, data=d_colors_lavaan, se="robust.sem"); # convergence ok; p=0.996
  summary(semfit_blue_j21_corr_UVb, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE);
  lavaanPlot(model=semfit_blue_j21_corr_UVb, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
  #semPaths(semfit_blue_j21_corr_UVb, what="est", edge.label.cex = 1.5, fade = FALSE)
  fitMeasures(semfit_blue_j21_corr_UVb, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")); # much better!
  mi <- modindices(semfit_blue_j21_corr_UVb, sort=TRUE); mi;
  
  # Let's compare (4), (5) and (6):
  cat("mean(UV-B):\n");              fitMeasures(semfit_blue_j21_corr_UVm, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi"));
  cat("sd(UV-B):\n");                fitMeasures(semfit_blue_j21_corr_UVs, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi"));
  cat("mean(UV-B) and sd(UV-B):\n"); fitMeasures(semfit_blue_j21_corr_UVb, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi"));
  # -> the highest fit indices (but by very little) are for sd(UV-B); 
  #    the mean and sd models are virtually identical; 
  #    when modeling both, they kick each other out;
  #    so, the overall story of Josserand et al (2021) holds, namely that high UV-B (or, equivalently, low UV-B variation) negatively influence 'blue'.
  # Moreover these full models fit the data very well....

  
  # Let's compare (1) and (4), (2) and (5) and (4) and (6), respectively:
  cat("mean(UV-B) - full:\n");   fitMeasures(semfit_blue_j21_full_UVm, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi"));
  cat("mean(UV-B) - strict:\n"); fitMeasures(semfit_blue_j21_corr_UVm, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi"));
  cat("sd(UV-B) - full:\n");   fitMeasures(semfit_blue_j21_full_UVs, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi"));
  cat("sd(UV-B) - strict:\n"); fitMeasures(semfit_blue_j21_corr_UVs, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi"));
  cat("both - full:\n");   fitMeasures(semfit_blue_j21_full_UVb, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi"));
  cat("both - strict:\n"); fitMeasures(semfit_blue_j21_corr_UVb, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi"));
  # -> the "strict" are much much better than the "full" models across the board!
  
  
  
  # Let's look at d2l:
  sem_d2l <- '
    d2l ~ lat + cpc1 + cpc2 + cpc3
    #d2l ~~ lat + cpc1 + cpc2 + cpc3
          
    cpc1 + cpc2 + cpc3 ~~ lat

  ';
  semfit_d2l <- sem(sem_d2l, data=d_colors_lavaan, se="robust.sem"); # convergence ok; p=0.002
  summary(semfit_d2l, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE);
  lavaanPlot(model=semfit_d2l, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
  #semPaths(semfit_d2l, what="est", edge.label.cex = 1.5, fade = FALSE)
  fitMeasures(semfit_d2l, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")); # pretty good exceot for the p-value
  mi <- modindices(semfit_d2l, sort=TRUE); mi;
  
  
  # Save to file:
  sem_blue <- list("data"=d_colors_lavaan,
                   "full"  =list("UV_mean"=semfit_blue_j21_full_UVm, "UV_sd"=semfit_blue_j21_full_UVs, "UV_both"=semfit_blue_j21_full_UVb),
                   "strict"=list("UV_mean"=semfit_blue_j21_corr_UVm, "UV_sd"=semfit_blue_j21_corr_UVs, "UV_both"=semfit_blue_j21_corr_UVb),
                   "d2l"   =semfit_d2l);
  save(sem_blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
} 
```

### The "full" path models

First, as in @josserand_environment_2021, we fitted the full model, with the twist that we now have both the mean and the standard deviation of the UV-B incidence (from TOMS) as variables:

#### Using mean UV-B incidence

```{r fig.cap=capFig('The path model using mean(UV) incidence (as given by TOMS) with non-standardized coefficients, showing all path estimates with significance. Single-headed arrows represent regressions, while double-headed arrows represent covariance.', TRUE, c("lavaanPlot"), is_map=FALSE)}
p <- lavaanPlot(model=sem_blue$full$UV_mean, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"), 
                labels=c("lat"="latitude", "d2l"="dist. to lakes", "clim"="climate PC1", "uvbm"="UV-B (mean)", "subs"="subsistence", "psiz"="pop. size", "blue"="blue"));
p; # plot
```
```{r include=FALSE}
embed_plot_pdf(p, "./paper/fig_path_full_mean.pdf");
```

```{r fig.cap=capFig('The path model using mean(UV) incidence (as given by TOMS) with standardized coefficients.', TRUE, c("lavaanPlot"), is_map=FALSE), include=FALSE, eval=FALSE}
semPaths(sem_blue$full$UV_mean, what="est", edge.label.cex = 1.5, fade = FALSE)
```

The fit indices are: `r m <- sem_blue$full$UV_mean; sprintf("*&chi;*^2^(%d) = %.1f, *p* = %.3g; CFI = %.3f, TLI = %.3f, NNFI = %.3f, RMSEA = %.3f 90%%CI [%.3f, %.3f]", fitMeasures(m, c("df")), fitMeasures(m, c("chisq")), fitMeasures(m, c("pvalue")), fitMeasures(m, c("cfi")), fitMeasures(m, c("tli")), fitMeasures(m, c("nnfi")), fitMeasures(m, c("rmsea")), fitMeasures(m, c("rmsea.ci.lower")), fitMeasures(m, c("rmsea.ci.upper")))`.

#### Using sd UV-B incidence

```{r fig.cap=capFig('The path model using sd(UV) incidence (as given by TOMS) with non-standardized coefficients, showing all path estimates with significance. Single-headed arrows represent regressions, while double-headed arrows represent covariance.', TRUE, c("lavaanPlot"), is_map=FALSE)}
p <- lavaanPlot(model=sem_blue$full$UV_sd, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"), 
                labels=c("lat"="latitude", "d2l"="dist. to lakes", "clim"="climate PC1", "uvbs"="UV-B (sd)", "subs"="subsistence", "psiz"="pop. size", "blue"="blue"));
p; # plot
```
```{r include=FALSE}
embed_plot_pdf(p, "./paper/fig_path_full_sd.pdf");
```

```{r fig.cap=capFig('The path model using sd(UV) incidence (as given by TOMS) with standardized coefficients.', TRUE, c("lavaanPlot"), is_map=FALSE), include=FALSE, eval=FALSE}
semPaths(sem_blue$full$UV_sd, what="est", edge.label.cex = 1.5, fade = FALSE)
```

The fit indices are: `r m <- sem_blue$full$UV_sd; sprintf("*&chi;*^2^(%d) = %.1f, *p* = %.3g; CFI = %.3f, TLI = %.3f, NNFI = %.3f, RMSEA = %.3f 90%%CI [%.3f, %.3f]", fitMeasures(m, c("df")), fitMeasures(m, c("chisq")), fitMeasures(m, c("pvalue")), fitMeasures(m, c("cfi")), fitMeasures(m, c("tli")), fitMeasures(m, c("nnfi")), fitMeasures(m, c("rmsea")), fitMeasures(m, c("rmsea.ci.lower")), fitMeasures(m, c("rmsea.ci.upper")))`.

#### Using both mean and sd UV-B incidence

```{r fig.cap=capFig('The path model using both mean(UB) and sd(UV) incidence (as given by TOMS) with non-standardized coefficients, showing all path estimates with significance. Single-headed arrows represent regressions, while double-headed arrows represent covariance.', TRUE, c("lavaanPlot"), is_map=FALSE)}
p <- lavaanPlot(model=sem_blue$full$UV_both, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"), 
                labels=c("lat"="latitude", "d2l"="dist. to lakes", "clim"="climate PC1", "uvbm"="UV-B (mean)", "uvbs"="UV-B (sd)", "subs"="subsistence", "psiz"="pop. size", "blue"="blue"));
p; # plot
```
```{r include=FALSE}
embed_plot_pdf(p, "./paper/fig_path_full_mean_sd.pdf");
```

```{r fig.cap=capFig('The path model using both mean(UB) and sd(UV) incidence (as given by TOMS) with standardized coefficients.', TRUE, c("lavaanPlot"), is_map=FALSE), include=FALSE, eval=FALSE}
semPaths(sem_blue$full$UV_both, what="est", edge.label.cex = 1.5, fade = FALSE)
```

The fit indices are: `r m <- sem_blue$full$UV_both; sprintf("*&chi;*^2^(%d) = %.1f, *p* = %.3g; CFI = %.3f, TLI = %.3f, NNFI = %.3f, RMSEA = %.3f 90%%CI [%.3f, %.3f]", fitMeasures(m, c("df")), fitMeasures(m, c("chisq")), fitMeasures(m, c("pvalue")), fitMeasures(m, c("cfi")), fitMeasures(m, c("tli")), fitMeasures(m, c("nnfi")), fitMeasures(m, c("rmsea")), fitMeasures(m, c("rmsea.ci.lower")), fitMeasures(m, c("rmsea.ci.upper")))`.


### The "relaxed" path models

Second, also as in @josserand_environment_2021, we also created a path analysis model keeping only causal arrows where causality is fully assumed, either by our world's knowledge (such as the impact of latitude on UV-B radiation) or by our hypothesis, other more "uncertain" assumed causal arrows being replaced by correlation links.

#### Using mean UV-B incidence

```{r fig.cap=capFig('The path model using mean(UV) incidence (as given by TOMS) with non-standardized coefficients, showing all path estimates with significance. Single-headed arrows represent regressions, while double-headed arrows represent covariance.', TRUE, c("lavaanPlot"), is_map=FALSE)}
p <- lavaanPlot(model=sem_blue$strict$UV_mean, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"), 
                labels=c("lat"="latitude", "d2l"="dist. to lakes", "clim"="climate PC1", "uvbm"="UV-B (mean)", "subs"="subsistence", "psiz"="pop. size", "blue"="blue"));
p; # plot
```
```{r include=FALSE}
embed_plot_pdf(p, "./paper/fig_path_relax_mean.pdf");
```

```{r fig.cap=capFig('The path model using mean(UV) incidence (as given by TOMS) with standardized coefficients.', TRUE, c("lavaanPlot"), is_map=FALSE), include=FALSE, eval=FALSE}
semPaths(sem_blue$strict$UV_mean, what="est", edge.label.cex = 1.5, fade = FALSE)
```

The fit indices are: `r m <- sem_blue$strict$UV_mean; sprintf("*&chi;*^2^(%d) = %.1f, *p* = %.3g; CFI = %.3f, TLI = %.3f, NNFI = %.3f, RMSEA = %.3f 90%%CI [%.3f, %.3f]", fitMeasures(m, c("df")), fitMeasures(m, c("chisq")), fitMeasures(m, c("pvalue")), fitMeasures(m, c("cfi")), fitMeasures(m, c("tli")), fitMeasures(m, c("nnfi")), fitMeasures(m, c("rmsea")), fitMeasures(m, c("rmsea.ci.lower")), fitMeasures(m, c("rmsea.ci.upper")))`.

#### Using sd UV-B incidence

```{r fig.cap=capFig('The path model using sd(UV) incidence (as given by TOMS) with non-standardized coefficients, showing all path estimates with significance. Single-headed arrows represent regressions, while double-headed arrows represent covariance.', TRUE, c("lavaanPlot"), is_map=FALSE)}
p <- lavaanPlot(model=sem_blue$strict$UV_sd, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"), 
                labels=c("lat"="latitude", "d2l"="dist. to lakes", "clim"="climate PC1", "uvbs"="UV-B (sd)", "subs"="subsistence", "psiz"="pop. size", "blue"="blue"));
p; # plot
```
```{r include=FALSE}
embed_plot_pdf(p, "./paper/fig_path_relax_sd.pdf");
```

```{r fig.cap=capFig('The path model using sd(UV) incidence (as given by TOMS) with standardized coefficients.', TRUE, c("lavaanPlot"), is_map=FALSE), include=FALSE, eval=FALSE}
semPaths(sem_blue$strict$UV_sd, what="est", edge.label.cex = 1.5, fade = FALSE)
```

The fit indices are: `r m <- sem_blue$strict$UV_sd; sprintf("*&chi;*^2^(%d) = %.1f, *p* = %.3g; CFI = %.3f, TLI = %.3f, NNFI = %.3f, RMSEA = %.3f 90%%CI [%.3f, %.3f]", fitMeasures(m, c("df")), fitMeasures(m, c("chisq")), fitMeasures(m, c("pvalue")), fitMeasures(m, c("cfi")), fitMeasures(m, c("tli")), fitMeasures(m, c("nnfi")), fitMeasures(m, c("rmsea")), fitMeasures(m, c("rmsea.ci.lower")), fitMeasures(m, c("rmsea.ci.upper")))`.

#### Using both mean and sd UV-B incidence

```{r fig.cap=capFig('The path model using both mean(UB) and sd(UV) incidence (as given by TOMS) with non-standardized coefficients, showing all path estimates with significance. Single-headed arrows represent regressions, while double-headed arrows represent covariance.', TRUE, c("lavaanPlot"), is_map=FALSE)}
p <- lavaanPlot(model=sem_blue$strict$UV_both, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"), 
                labels=c("lat"="latitude", "d2l"="dist. to lakes", "clim"="climate PC1", "uvbm"="UV-B (mean)", "subs"="subsistence", "psiz"="pop. size", "blue"="blue"));
p; # plot
```
```{r include=FALSE}
embed_plot_pdf(p, "./paper/fig_path_relax_mean_sd.pdf");
```

```{r fig.cap=capFig('The path model using both mean(UB) and sd(UV) incidence (as given by TOMS) with standardized coefficients.', TRUE, c("lavaanPlot"), is_map=FALSE), include=FALSE, eval=FALSE}
semPaths(sem_blue$strict$UV_both, what="est", edge.label.cex = 1.5, fade = FALSE)
```

The fit indices are: `r m <- sem_blue$strict$UV_both; sprintf("*&chi;*^2^(%d) = %.1f, *p* = %.3g; CFI = %.3f, TLI = %.3f, NNFI = %.3f, RMSEA = %.3f 90%%CI [%.3f, %.3f]", fitMeasures(m, c("df")), fitMeasures(m, c("chisq")), fitMeasures(m, c("pvalue")), fitMeasures(m, c("cfi")), fitMeasures(m, c("tli")), fitMeasures(m, c("nnfi")), fitMeasures(m, c("rmsea")), fitMeasures(m, c("rmsea.ci.lower")), fitMeasures(m, c("rmsea.ci.upper")))`.

#### *dist2lakes*

These models also seem to help clarifying *dist2lakes*, in that we also fitted a path model for this variable:

```{r fig.cap=capFig('The path model of *dist2lakes* with non-standardized coefficients, showing all path estimates with significance. Single-headed arrows represent regressions, while double-headed arrows represent covariance.', TRUE, c("lavaanPlot"), is_map=FALSE)}
lavaanPlot(model=sem_blue$d2l, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
```

```{r fig.cap=capFig('The path model *dist2lakes* with standardized coefficients.', TRUE, c("lavaanPlot"), is_map=FALSE), include=FALSE, eval=FALSE}
semPaths(sem_blue$d2l, what="est", edge.label.cex = 1.5, fade = FALSE)
```

The fit indices are: `r m <- sem_blue$d2l; sprintf("*&chi;*^2^(%d) = %.1f, *p* = %.3g; CFI = %.3f, TLI = %.3f, NNFI = %.3f, RMSEA = %.3f 90%%CI [%.3f, %.3f]", fitMeasures(m, c("df")), fitMeasures(m, c("chisq")), fitMeasures(m, c("pvalue")), fitMeasures(m, c("cfi")), fitMeasures(m, c("tli")), fitMeasures(m, c("nnfi")), fitMeasures(m, c("rmsea")), fitMeasures(m, c("rmsea.ci.lower")), fitMeasures(m, c("rmsea.ci.upper")))`.



## Predicting 'blue'

We check how good are various techniques at predicting the existence of a dedicated word for 'blue' from a collection of potential predictors.
On the one hand, we estimate this when using the full dataset (i.e., we use the full data both for fitting the model and for computing various measures of goodness of prediction), but also on how well these models generalize by repeatedly generating random training and testing subsets (containing 80% and 20% of the data, respectively; we stratify by macroarea and, except for Bayesian mixed-effects regressions, we do not use the language family; please note that random forests automatically sample the data).

```{r include=FALSE}
file_name <- "./cached_results/traning-testing-splits.RData";
if( !all(file.exists(file_name)) )
{
  ## Use all the methods on all the data as well as on training/testing subsets
  
  # The data:
  d <- d_colors_ag; d$macroarea <- as.factor(d$macroarea); d$glottocode_family <- as.factor(d$glottocode_family);
  
  # Generate the training/testing splits into a training (80%) and a testing (20%) set stratified by macroarea:
  n_train <- 100; # the number of training/testing splits
  train_test_splits <- lapply(1:n_train, function(i) rsample::initial_split(d, prop=0.80, strata="macroarea"));
  
  # Save:
  save(d, n_train, train_test_splits, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
} 

```


### Multiple regression

We used Bayesian mixed-effects logistic regression to predict the existence of a specific word for 'blue' (*blue*) from all the potential predictors.

```{r include=FALSE}
file_name <- "./cached_results/brms_blue.RData";
if( !all(file.exists(file_name)) )
{
  # Save to file:
  brms_blue <- list("data"=d);
      
  ## On the full data:

  # With all potential predictors:
  brms_blue__full <- brm(exists_blue ~ 1 + 
                           # the languages:
                         + UV_mean_r + UV_sd_r +                                       # UV-B incidence (both mean and sd) from TOMS
                         + longitude_r + latitude_r                                    # geographic location
                         + subsistence  + log_popSize_ethno                            # subsistence strategy and population size from Ethnologue
                         + clim_PC1_r + clim_PC2_r + clim_PC3_r + hum_median + hum_IQR # climate, ecology and humidity
                         + elevation_r                                                 # altitude 
                         + dist2water_r + dist2ocean_r + dist2lakes_r + dist2rivers_r  # distances to large bodies of water 
                         # the language family origins:
                         + UV_mean_family_r + UV_sd_family_r                                                              # UV incidence (both mean and sd) from TOMS
                         + longitude_family_r + latitude_family_r                                                         # geographic location
                         + clim_PC1_family_r + clim_PC2_family_r + clim_PC3_family_r + hum_median_family + hum_IQR_family # climate, ecology and humidity 
                         + elevation_family_r                                                                             # altitude 
                         + dist2water_family_r + dist2ocean_family_r + dist2lakes_family_r + dist2rivers_family_r         # distances to large bodies of water 
                         + (1 | glottocode_family) + (1 | macroarea),                  # random factors
                         data = d, 
                         family=bernoulli(link="logit"), 
                         prior=c(prior(student_t(3, 0, 2.5), class="Intercept"),
                                 prior(student_t(3, 0, 2.5), class="b")), # pretty wide priors centered on 0
                         save_pars=save_pars(all=TRUE), # needed for Bayes factors
                         sample_prior=TRUE,  # needed for hypotheses tests
                         cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9999, max_treedepth=15));
  summary(brms_blue__full); mcmc_plot(brms_blue__full, type="trace"); mcmc_plot(brms_blue__full);
  (hdi_full <- hdi(brms_blue__full, ci=0.95)); (rope_full <- rope(brms_blue__full, ci=0.95));
  brms_blue__full <- brms_fit_indices(brms_blue__full);
  # Fit the null model to the same data as m1:
  brms_blue__0 <- update(brms_blue__full, . ~ . - UV_mean_r - UV_sd_r - longitude_r - latitude_r - subsistence - log_popSize_ethno - clim_PC1_r - clim_PC2_r - clim_PC3_r - hum_median - hum_IQR - elevation_r 
                         - dist2water_r - dist2ocean_r - dist2lakes_r - dist2rivers_r 
                         - UV_mean_family_r - UV_sd_family_r - longitude_family_r - latitude_family_r - clim_PC1_family_r - clim_PC2_family_r - clim_PC3_family_r - hum_median_family - hum_IQR_family - elevation_family_r 
                         - dist2water_family_r - dist2ocean_family_r - dist2lakes_family_r - dist2rivers_family_r, 
                         cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9999, max_treedepth=15));
  brms_blue__0 <- brms_fit_indices(brms_blue__0);
  cmp_null_full <- brms_compare_models(brms_blue__0, brms_blue__full, "null", "full"); # they seem equivalent
  
  # Simplified model (manually, starting from full):
  brms_blue__reduced <- update(brms_blue__full, . ~ . - hum_median_family - hum_IQR_family - dist2rivers_r - dist2water_r - dist2ocean_r - dist2lakes_family_r - dist2rivers_family_r - clim_PC2_family_r - clim_PC3_family_r - 
                                 hum_median - hum_IQR - latitude_family_r - elevation_family_r - log_popSize_ethno - latitude_r - UV_mean_r - UV_mean_family_r - longitude_family_r - dist2water_family_r - dist2ocean_family_r -
                                 longitude_r - clim_PC2_r - subsistence - clim_PC3_r - dist2lakes_r, 
                         cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9999, max_treedepth=15));
  summary(brms_blue__reduced); mcmc_plot(brms_blue__reduced, type="trace"); mcmc_plot(brms_blue__reduced);
  (hdi_reduced <- hdi(brms_blue__reduced, ci=0.95)); (rope_reduced <- rope(brms_blue__reduced, ci=0.95)); (fixef_reduced <- fixef(brms_blue__reduced));
  brms_blue__reduced <- brms_fit_indices(brms_blue__reduced);

  # Model comparison and performance:
  cmp_full_reduced <- brms_compare_models(brms_blue__full, brms_blue__reduced, "full", "reduced"); # reduced seems better
  cmp_null_reduced <- brms_compare_models(brms_blue__0, brms_blue__reduced, "null", "reduced"); # reduced is better
  (cm_full    <- confusionMatrix(brms_blue__full$data$exists_blue, factor(ifelse(predict(brms_blue__full)[,"Estimate"] < 0.5, "no", "yes"), levels=c("no", "yes")), positive="yes"));
  (cm_reduced <- confusionMatrix(brms_blue__reduced$data$exists_blue, factor(ifelse(predict(brms_blue__reduced)[,"Estimate"] < 0.5, "no", "yes"), levels=c("no", "yes")), positive="yes"));
  
  # Save:
  brms_blue$both <- list("full"   =list("cmp_2_null"=cmp_null_full, 
                                        "HDI"=hdi_full, "ROPE"=rope_full, "confusionMatrix"=cm_full), 
                         "reduced"=list("cmp_2_null"=cmp_null_reduced, "cmp_2_full"=cmp_full_reduced, 
                                        "fixef"=fixef_reduced, "HDI"=hdi_reduced, "ROPE"=rope_reduced, "confusionMatrix"=cm_reduced));
  

  ## On the training/testing sets:
  results <- pblapply(1:n_train, function(i) # very computationally expensive (~3h on a Ryzen 3700X)
    {
      # split the data:
      data_train <- training(train_test_splits[[i]]);
      data_test  <- testing(train_test_splits[[i]]);

      # fit the models: avoid recompiling the model by "updating" the data it is fit on:
      invisible(capture.output(brms_1   <- update(brms_blue__full, newdata=data_train, refresh=0, 
                                                      save_pars=save_pars(all=TRUE), sample_prior=TRUE, cores=brms_ncores, 
                                                      iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9999, max_treedepth=15)),
                               type="message")); # capture the messages printed by Stan
      
      # confusion matrices:
      cm_brms_full <- confusionMatrix(data_test$exists_blue, factor(ifelse(predict(brms_1,   newdata=data_test, allow_new_levels=TRUE)[,"Estimate"] < 0.5, "no", "yes"), levels=c("no", "yes")), positive="yes");
      # predictors:
      hdi_full <- hdi(brms_1, ci=0.95); rope_full <- rope(brms_1,   ci=0.95, verbose=FALSE);

      # return the results:
      success_full <- data.frame("replication"  =i, # replication
                                 "accuracy"     =cm_brms_full$overall["Accuracy"],
                                 "sensitivity"  =cm_brms_full$byClass["Sensitivity"], 
                                 "specificity"  =cm_brms_full$byClass["Specificity"],
                                 "precision"    =cm_brms_full$byClass["Precision"],
                                 "recall"       =cm_brms_full$byClass["Recall"],
                                 row.names=NULL);
      preds_full <- data.frame("replication"=i, # replication,
                               "predictor"  =rownames(fixef(brms_1)), 
                               "estimate"   =fixef(brms_1)[,"Estimate"],
                               as.data.frame(hdi_full)[,c("CI_low", "CI_high")],
                               as.data.frame(rope_full)[,c("ROPE_low", "ROPE_high", "ROPE_Percentage")],
                               row.names=NULL);

      return (list("replication"       =i,
                   "data_train_indices"=train_test_splits[[i]]$in_id, 
                   "data_test_indices" =setdiff(1:nrow(train_test_splits[[i]]$data), train_test_splits[[i]]$in_id),
                   "full"              =list("success"=success_full, "predictors"=preds_full)));
    });
  
  # Assemble the various results and save them:
  brms_blue$training_testing <- list("replications"=n_train,
                                     "both"=list("success"=do.call(rbind, lapply(results, function(x) x$full$success)),   
                                                 "predictors"=do.call(rbind, lapply(results, function(x) x$full$predictors))));
  
  # Save:
  save(brms_blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
} 


```

On the full dataset: 

```{r}
tmp_allpred <- data.frame("Predictors" =c("All predictors"),
                 "Accuracy"   =100*c(brms_blue$both$full$confusionMatrix$overall["Accuracy"]),
                 "Sensitivity"=100*c(brms_blue$both$full$confusionMatrix$byClass["Sensitivity"]), 
                 "Specificity"=100*c(brms_blue$both$full$confusionMatrix$byClass["Specificity"]),
                 "Precision"  =100*c(brms_blue$both$full$confusionMatrix$byClass["Precision"]),
                 "Recall"     =100*c(brms_blue$both$full$confusionMatrix$byClass["Recall"]))

kable(tmp_allpred,
      row.names=FALSE, digits=c(NA, 1, 1, 1, 1, 1), 
      caption=capTab("Success (as %) on the full dataset using Bayesian mixed effects logistic regressions with all potential predictors."));
```

After iterative manual simplification: 

```{r}
kable(data.frame("Predictors" =c("Set of predictors"),
                 "Accuracy"   =100*c(brms_blue$both$reduced$confusionMatrix$overall["Accuracy"]),
                 "Sensitivity"=100*c(brms_blue$both$reduced$confusionMatrix$byClass["Sensitivity"]), 
                 "Specificity"=100*c(brms_blue$both$reduced$confusionMatrix$byClass["Specificity"]),
                 "Precision"  =100*c(brms_blue$both$reduced$confusionMatrix$byClass["Precision"]),
                 "Recall"     =100*c(brms_blue$both$reduced$confusionMatrix$byClass["Recall"])),
      row.names=FALSE, digits=c(NA, 1, 1, 1, 1, 1), 
      caption=capTab("Success (as %) on the full dataset using Bayesian mixed effects logistic regressions with keeping only the predictors significantly contributing."));
```

The retained predictors are:

```{r}
kable(data.frame("predictor"  =rownames(brms_blue$both$reduced$fixef), 
                 "estimate"   =round(brms_blue$both$reduced$fixef[,"Estimate"],2),
                 "hdi"=paste0("[", round(brms_blue$both$reduced$HDI[,"CI_low"],2), ",", round(brms_blue$both$reduced$HDI[,"CI_high"],2), "]"),
                 "p.rope"=sprintf("%.2g",brms_blue$both$reduced$ROPE[,"ROPE_Percentage"]),
                 row.names=NULL), 
      row.names=FALSE, col.names=c("Predictor", "*&beta;* (estimate)", "*&beta;* (95% HDI)", "*p*~ROPE~"),
      caption=capTab(paste0("Retained predictors for Bayesian mixed effects logistic regressions following iterative maual simplification on the full dataset. The ROPE is [", round(brms_blue$both$reduced$ROPE[1,"ROPE_low"],2), ",", round(brms_blue$both$reduced$ROPE[1,"ROPE_high"],2), "].")));
```

When randomly splitting the dataset into 80% training/20% testing subsets `r brms_blue$training_testing$replications` times, using all the potential predictors, we see that:

```{r}
tmp_full <- vapply(brms_blue$training_testing$both$success[,-1],    function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1));

tmp <- data.frame("Predictors" =c("All predictors"),
                  "accuracy"   =c(tmp_full[ grep("accuracy",    names(tmp_full), fixed=TRUE) ]),
                  "sensitivity"=c(tmp_full[ grep("sensitivity", names(tmp_full), fixed=TRUE) ]),
                  "specificity"=c(tmp_full[ grep("specificity", names(tmp_full), fixed=TRUE) ]),
                  "precision"  =c(tmp_full[ grep("precision",   names(tmp_full), fixed=TRUE) ]),
                  "recall"     =c(tmp_full[ grep("recall",      names(tmp_full), fixed=TRUE) ]));
kable(tmp, row.names=FALSE, col.names=c("Predictors", "Accuracy", "Sensitivity", "Specificity", "Precision", "Recall"),
      caption=capTab(paste0("Various measures of success at predicting *blue* using Bayesian mixed effects logistic regressions splitting the dataset randomly into 80% training/20% testing subsets, ",brms_blue$training_testing$replications," times")));

```

```{r fig.cap=capFig(paste0("Various measures of success using Bayesian mixed effects logistic regressions splitting the dataset randomly into 80% training/20% testing subsets, ",brms_blue$training_testing$replications," times. Boxplots show the spread of the training/testing values, while the solid horizontal red lines show the values when using the full dataset."), TRUE, c("ggplot2"), is_map=FALSE), fig.width=1*7, fig.height=5}
ggplot(brms_blue$training_testing$both$success %>% 
         reshape2::melt(id.vars=c("replication"), variable.name="measure", value.name="value") %>% 
         mutate("measure"=factor(measure, levels=c("accuracy", "sensitivity", "specificity", "precision", "recall")), "value"=value*100), 
       aes(x=measure, y=value)) + 
  ylim(c(0,100)) + xlab("Measures of success") + ylab("Value (%)") +
  theme_bw() +
  geom_boxplot(show.legend=FALSE) + 
  # draw alternating vertical bands:
  new_scale_fill() + 
  geom_rect(aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=0, ymax=100, fill=as.factor(as.numeric(measure) %% 2 == 0)), show.legend=FALSE) + 
  scale_fill_manual("", values=c("white", "gray95")) +
  # draw the actual boxplots:
  new_scale_fill() + 
  geom_boxplot(aes(x=measure, y=value)) + 
  # measures on the full dataset:
  geom_rect(data=tmp_allpred %>% 
               reshape2::melt(measure.vars=c("Accuracy", "Sensitivity", "Specificity", "Precision", "Recall"), variable.name="measure", value.name="value") %>% 
               mutate("measure"=factor(measure, levels=c("Accuracy", "Sensitivity", "Specificity", "Precision", "Recall"), labels=c("accuracy", "sensitivity", "specificity", "precision", "recall"))), 
             aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=value, ymax=value), fill=NA, color="red") + 
theme(legend.position="right");
```



### Conditional inference trees

We used conditional inference trees (as implemented by `ctree()` in package `partykit`) to predict the existence of a specific word for 'blue' (*blue*) from all the potential predictors.

```{r include=FALSE}
file_name <- "./cached_results/ctree_blue.RData";
if( !all(file.exists(file_name)) )
{
  # Decision tree with all potential predictors:
  ctree_blue__full <- ctree(exists_blue ~ 
                              # the languages:
                              macroarea                                                   # macroarea
                            + UV_mean_r + UV_sd_r                                         # UV-B incidence
                            + longitude_r + latitude_r                                    # geographic location
                            + subsistence  + log_popSize_ethno                            # subsistence strategy and population size
                            + clim_PC1_r + clim_PC2_r + clim_PC3_r + hum_median + hum_IQR # climate, ecology and humidity
                            + elevation_r                                                 # altitude 
                            + dist2water_r + dist2ocean_r + dist2lakes_r + dist2rivers_r  # distances to large bodies of water 
                            # the language family origins:
                            + UV_mean_family_r + UV_sd_family_r                                                              # UV incidence
                            + longitude_family_r + latitude_family_r                                                         # geographic location
                            + clim_PC1_family_r + clim_PC2_family_r + clim_PC3_family_r + hum_median_family + hum_IQR_family # climate, ecology and humidity 
                            + elevation_family_r                                                                             # altitude 
                            + dist2water_family_r + dist2ocean_family_r + dist2lakes_family_r + dist2rivers_family_r,        # distances to large bodies of water
                            data = d, 
                            control = ctree_control(testtype = c("MonteCarlo"), maxvar=4, maxdepth=3));

  ## On the training/testing sets:
  results <- pblapply(1:n_train, function(i) # very computationally expensive
    {
      # split the data:
      data_train <- training(train_test_splits[[i]]);
      data_test  <- testing(train_test_splits[[i]]);

      # fit the models:
      tryCatch({ctree_1   <- ctree(exists_blue ~ 
                                     # the languages:
                                     macroarea                                                   # macroarea
                                   + UV_mean_r + UV_sd_r                                         # UV-B incidence
                                   + longitude_r + latitude_r                                    # geographic location
                                   + subsistence  + log_popSize_ethno                            # subsistence strategy and population size
                                   + clim_PC1_r + clim_PC2_r + clim_PC3_r + hum_median + hum_IQR # climate, ecology and humidity
                                   + elevation_r                                                 # altitude 
                                   + dist2water_r + dist2ocean_r + dist2lakes_r + dist2rivers_r  # distances to large bodies of water 
                                   # the language family origins:
                                   + UV_mean_family_r + UV_sd_family_r                                                              # UV incidence
                                   + longitude_family_r + latitude_family_r                                                         # geographic location
                                   + clim_PC1_family_r + clim_PC2_family_r + clim_PC3_family_r + hum_median_family + hum_IQR_family # climate, ecology and humidity 
                                   + elevation_family_r                                                                             # altitude 
                                   + dist2water_family_r + dist2ocean_family_r + dist2lakes_family_r + dist2rivers_family_r,        # distances to large bodies of water  
                                   data = data_train, 
                                   control = ctree_control(testtype = c("MonteCarlo")));
      
      
      
      # confusion matrices:
      cm_ctree_1   <- confusionMatrix(data_test$exists_blue, predict(ctree_1,  newdata=data_test, allow_new_levels=TRUE), positive="yes");

      # return the results:
      success_1 <- data.frame("replication"  =i, # replication
                                 "accuracy"     =cm_ctree_1$overall["Accuracy"],
                                 "sensitivity"  =cm_ctree_1$byClass["Sensitivity"], 
                                 "specificity"  =cm_ctree_1$byClass["Specificity"],
                                 "precision"    =cm_ctree_1$byClass["Precision"],
                                 "recall"       =cm_ctree_1$byClass["Recall"],
                                 row.names=NULL);

      return (list("replication"       =i,
                   "data_train_indices"=train_test_splits[[i]]$in_id, 
                   "data_test_indices" =setdiff(1:nrow(train_test_splits[[i]]$data), train_test_splits[[i]]$in_id),
                   "all"         =list("success"=success_1)));
      
       }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
    });
  
  
  # Save to file:
  ctree_blue <- list("data"=d,
                     "all"=ctree_blue__full, 
                     "training_testing"=list("replications"=n_train,
                                             "all"=list("success"=do.call(rbind, lapply(results, function(x) x$all$success)))));
  save(ctree_blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
} 
```

When using the full dataset:

```{r fig.cap=capFig('Conditional inference trees for predicting *blue* using all the potential predictors. Please note that some predictors are transformed (the "_r" suffix), and that, for interpretability, we allowed a maximum of 4 predictors and a maximum depth of 3, the most important here being *macroarea*.', TRUE, c("partykit"), is_map=FALSE), fig.width=12, fig.height=7, fig.show='hold', out.height="50%"}
plot(ctree_blue$all,    gp=gpar(fontsize = 11));
```
```{r include=FALSE}
file_name <- "fig_citree";
#png(paste0("./paper/",file_name,".png"), width=10, height=5, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=10, height=5, units="in", res=300, quality=85); # for SI
plot(ctree_blue$all,    gp=gpar(fontsize = 11));
dev.off();
```

```{r}
cm1 <- confusionMatrix(ctree_blue$data$exists_blue, predict(ctree_blue$all), positive="yes");

tmp_all <- data.frame("Predictors" =c("All predictors"),
                 "Accuracy"   =100*c(cm1$overall["Accuracy"]),
                 "Sensitivity"=100*c(cm1$byClass["Sensitivity"]), 
                 "Specificity"=100*c(cm1$byClass["Specificity"]),
                 "Precision"  =100*c(cm1$byClass["Precision"]),
                 "Recall"     =100*c(cm1$byClass["Recall"]))
kable(tmp_all,
      row.names=FALSE, digits=c(NA, 1, 1, 1, 1, 1), 
      caption=capTab("Success (as %) on the full dataset using conditional inference trees with all potential predictors."));
```

When randomly splitting the dataset into 80% training/20% testing subsets `r ctree_blue$training_testing$replications` times, using all the potential predictors, we see that:

```{r}
tmp_ncol   <- vapply(ctree_blue$training_testing$all$success[,-1],    function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1));

tmp <- data.frame("Predictors" =c("All predictors"),
                  "accuracy"   =c(tmp_ncol[ grep("accuracy",    names(tmp_ncol), fixed=TRUE) ]),
                  "sensitivity"=c(tmp_ncol[ grep("sensitivity", names(tmp_ncol), fixed=TRUE) ]),
                  "specificity"=c(tmp_ncol[ grep("specificity", names(tmp_ncol), fixed=TRUE) ]),
                  "precision"  =c(tmp_ncol[ grep("precision",   names(tmp_ncol), fixed=TRUE) ]),
                  "recall"     =c(tmp_ncol[ grep("recall",      names(tmp_ncol), fixed=TRUE) ]));
kable(tmp, row.names=FALSE, col.names=c("Predictors", "Accuracy", "Sensitivity", "Specificity", "Precision", "Recall"),
      caption=capTab(paste0("Various measures of success at predicting *blue* using conditional inference trees splitting the dataset randomly into 80% training/20% testing subsets, ",ctree_blue$training_testing$replications," times.")));
```

```{r fig.cap=capFig(paste0("Various measures of success using conditional inference trees splitting the dataset randomly into 80% training/20% testing subsets, ",ctree_blue$training_testing$replications," times. Boxplots show the spread of the training/testing values, while the solid horizontal red lines show the values when using the full dataset."), TRUE, c("ggplot2"), is_map=FALSE), fig.width=1*7, fig.height=5}
ggplot(ctree_blue$training_testing$all$success %>% 
        reshape2::melt(id.vars=c("replication"), variable.name="measure", value.name="value") %>% 
         mutate("measure"=factor(measure, levels=c("accuracy", "sensitivity", "specificity", "precision", "recall")), "value"=value*100), 
       aes(x=measure, y=value)) +
  ylim(c(0,100)) + xlab("Measures of success") + ylab("Value (%)") +
  theme_bw() +
  geom_boxplot(show.legend=FALSE) + 
  # draw alternating vertical bands:
  new_scale_fill() + 
  scale_fill_manual("", values=c("white", "gray95")) +
  geom_rect(aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=0, ymax=100, fill=as.factor(as.numeric(measure) %% 2 == 0)), show.legend=FALSE) + 
  # draw the actual boxplots:
  new_scale_fill() + 
  geom_boxplot(aes(x=measure, y=value)) + 
  # measures on the full dataset:
  geom_rect(data=tmp_all %>% 
               reshape2::melt(measure.vars=c("Accuracy", "Sensitivity", "Specificity", "Precision", "Recall"), 
                              variable.name="measure", value.name="value") %>% 
               mutate("measure"=factor(measure, 
                                       levels=c("Accuracy", "Sensitivity", "Specificity", "Precision", "Recall"), 
                                       labels=c("accuracy", "sensitivity", "specificity", "precision", "recall"))), 
             aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=value, ymax=value), color="red", fill=NA) +
  theme(legend.position="right");
```


### Random forests

We used random forests (as implemented by `randomForest()` in package `randomForest`) and conditional random forests (as implemented by `cforest()` in package `partykit`) to predict the existence of a specific word for 'blue' (*blue*) from all the potential predictors.

```{r include=FALSE}
file_name <- "./cached_results/rforest_blue.RData";
if( !all(file.exists(file_name)) )
{
  # The potential predictors:
  list_predictors <- c(# the languages:
    "macroarea",                                                       # macroarea
    "UV_mean_r", "UV_sd_r",                                            # UV-B incidence
    "longitude_r", "latitude_r",                                       # geographic location
    "subsistence", "log_popSize_ethno",                                # subsistence strategy and population size
    "clim_PC1_r", "clim_PC2_r", "clim_PC3_r", "hum_median", "hum_IQR", # climate, ecology and humidity
    "elevation_r",                                                     # altitude 
    "dist2water_r", "dist2ocean_r", "dist2lakes_r", "dist2rivers_r",   # distances to large bodies of water 
    # the language family origins:
    "UV_mean_family_r", "UV_sd_family_r",                                                                 # UV incidence
    "longitude_family_r", "latitude_family_r",                                                            # geographic location
    "clim_PC1_family_r", "clim_PC2_family_r", "clim_PC3_family_r", "hum_median_family", "hum_IQR_family", # climate, ecology and humidity 
    "elevation_family_r",                                                                                 # altitude 
    "dist2water_family_r", "dist2ocean_family_r", "dist2lakes_family_r", "dist2rivers_family_r"           # distances to large bodies of water 
  );
  
  # Collect the success measures and the predictor importance based on the gini index (randomForest) and the accuracy indices (randomForest and cForest):
  n_replications <- n_train; # the number of replications
  cf_ntree       <- 500; # the number of trees for cforest
  cf_nperm       <- 10;  # number of permutations for cforest:varimp
  f_full         <- formula(paste0("exists_blue ~ ", paste0(list_predictors,collapse=" + "))); 
  results <- mclapply(1:n_replications, function(i) # very computationally expensive # pblapply
    {
      # fit the random forests:
      rf_full   <- randomForest(f_full, data=d, importance=TRUE, na.action=na.omit);
      cf_full   <- cforest(f_full, data=d, ntree=cf_ntree);
      
      # confusion matrices:
      cm_rf_full   <- confusionMatrix(rf_full$y,     rf_full$predicted,   positive="yes"); 
      cm_cf_full   <- confusionMatrix(d$exists_blue, predict(cf_full),    positive="yes");
      
      # predictor importance:
      pia_rf_full   <- importance(rf_full,   type=1); # accuracy-based
      pig_rf_full   <- importance(rf_full,   type=2); # gini-based
      piu_cf_full   <- varimp(cf_full, conditional=FALSE, nperm=cf_nperm); # unconditional

      # return the results:
      success_full <- data.frame("replication"     =i,                               # replication
                                 "rf_accuracy"     =cm_rf_full$overall["Accuracy"],  # randomForest
                                 "rf_sensitivity"  =cm_rf_full$byClass["Sensitivity"], 
                                 "rf_specificity"  =cm_rf_full$byClass["Specificity"],
                                 "rf_precision"    =cm_rf_full$byClass["Precision"],
                                 "rf_recall"       =cm_rf_full$byClass["Recall"],
                                 "cf_accuracy"     =cm_cf_full$overall["Accuracy"],  # cforest
                                 "cf_sensitivity"  =cm_cf_full$byClass["Sensitivity"], 
                                 "cf_specificity"  =cm_cf_full$byClass["Specificity"],
                                 "cf_precision"    =cm_cf_full$byClass["Precision"],
                                 "cf_recall"       =cm_cf_full$byClass["Recall"], 
                                 row.names=NULL);
      pi_df_full  <- data.frame("replication"      =i,                    # replication
                                "predictor"        =list_predictors,      # predictors
                                "rf_accuracy_based"=pia_rf_full,          # randomForest accuracy-based
                                "rf_gini_based"    =pig_rf_full,          # randomForest gini-based
                                "cf_unconditional" =piu_cf_full,          # cforest unconditional
                                row.names=NULL);
      
      return (list("replication"=i,
                   "full"=list("success"=success_full,
                               "pred_importance"=pi_df_full)));
    }, mc.cores=10); #, mc.cores=max(detectCores(all.tests=TRUE, logical=FALSE), 1, na.rm=TRUE)); # try to use multiple cores, if present (limited to a maximum of 10)
  
  # Assemble the various results and save them:
  rforest_blue <- list("data"           =d,
                       "replications"   =n_replications,
                       "full"   =list("success"=do.call(rbind, lapply(results, function(x) x$full$success)),  "pred_importance"=do.call(rbind, lapply(results, function(x) x$full$pred_importance))));
  save(rforest_blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
} 
```

The (conditional) random forests:

```{r}
tmp_full <- vapply(rforest_blue$full$success[,-1], function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1));

tmp <- data.frame("method"     =rep(c("random forest", "conditional random forest"), times=1),
                  "accuracy"   =c(tmp_full[ grep("accuracy",    names(tmp_full), fixed=TRUE) ]),
                  "sensitivity"=c(tmp_full[ grep("sensitivity", names(tmp_full), fixed=TRUE) ]),
                  "specificity"=c(tmp_full[ grep("specificity", names(tmp_full), fixed=TRUE) ]),
                  "precision"  =c(tmp_full[ grep("precision",   names(tmp_full), fixed=TRUE) ]),
                  "recall"     =c(tmp_full[ grep("recall",      names(tmp_full), fixed=TRUE) ]));
kable(tmp, row.names=FALSE, col.names=c("Method", "Accuracy", "Sensitivity", "Specificity", "Precision", "Recall"),
      caption=capTab(paste0("Various measures of success at predicting *blue* using two random forest methods, ",rforest_blue$replications," replications.")));
```

```{r fig.cap=capFig(paste0("Various measures of success using (conditional) random forests with ",rforest_blue$replications," replications."), TRUE, c("ggplot2"), is_map=FALSE), fig.width=2*4, fig.height=5}
ggplot(rbind(cbind(rforest_blue$full$success, "full"="yes")) %>% 
         reshape2::melt(id.vars=c("replication", "full"), variable.name="measure", value.name="value") %>% 
         mutate("method"=factor(if_else(substring(measure,1,2) == "rf", "random forest", "conditional random forest"), levels=c("random forest", "conditional random forest")), 
                "measure"=factor(substring(measure,4), levels=c("accuracy", "sensitivity", "specificity", "precision", "recall")), 
                "value"=value*100), 
       aes(x=measure, y=value)) + 
  ylim(c(0,100)) + xlab("Measures of success") + ylab("Value (%)") +
  theme_bw() +
  geom_boxplot(show.legend=FALSE) + 
  # draw alternating vertical bands:
  new_scale_fill() + 
  geom_rect(aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=0, ymax=100, fill=as.factor(as.numeric(measure) %% 2 == 0)), show.legend=FALSE) + 
  scale_fill_manual("", values=c("white", "gray95")) +
  # draw the actual boxplots:
  new_scale_fill() + 
  geom_boxplot(aes(x=measure, y=value)) + 
  theme(legend.position="bottom") +
  facet_grid(. ~ method);
```

The importance of the predictors is:

```{r fig.cap=capFig(paste0("Different measures of predictor importance using ",rforest_blue$replications," replications. Left column: Accuracy-based predictor importance from random forests; this is a measure of the amount by which removing a variable decreases the accuracy thus higher values point to more relevant predictors. Column in the center: Gini-index-based predictor importance from random forests; this measures by how much the Gini impurity decrease when a variable is chosen to split a node (please note that only the relative values matter, and that there is a bias towards using numeric variables to split nodes). Right column: Unconditional predictor importance from conditional random forests; this is similar to the accuracy-based importance from random forests."), TRUE, c("ggplot2"), is_map=FALSE), fig.width=4*3, fig.height=7*1}
grid.arrange(ggplot(rforest_blue$full$pred_importance, 
                    aes(x=reorder(predictor, MeanDecreaseAccuracy, median), y=MeanDecreaseAccuracy)) +
               theme_bw() +
               geom_boxplot(fill="gold", color="black") +
               labs(x="Predictors (sorted by decreasing importance)", y="Mean decrease accuracy") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="none") +
               ggtitle("Accuracy-based") + 
               coord_flip() + 
               NULL,
             ggplot(rforest_blue$full$pred_importance, 
                    aes(x=reorder(predictor, MeanDecreaseGini, median), y=MeanDecreaseGini)) +
               theme_bw() +
               geom_boxplot(fill="gold", color="black") +
               labs(x="Predictors (sorted by decreasing importance)", y="Mean decrease Gini index") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="none") +
               ggtitle("Gini-based") + 
               coord_flip() + 
               NULL,
             ggplot(rforest_blue$full$pred_importance, 
                    aes(x=reorder(predictor, cf_unconditional, median), y=cf_unconditional)) +
               theme_bw() +
               geom_boxplot(fill="gold", color="black") +
               labs(x="Predictors (sorted by decreasing importance)", y="Unconditional importance") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="none") +
               ggtitle("Unconditional importance") + 
               coord_flip() + 
               NULL,
             ncol=3);
```


### Support Vector Machines (SVM)

We used Support Vector Machines (SVMs, as implemented by `fit(...,model="svm")` in the `rminer` package) to predict the existence of a specific word for 'blue' (*blue*) from all the potential predictors.
Here, we randomly split the dataset into a training (80% of the data points) and a testing (the remaining 20%) set (stratified on *blue*), repeated multiple times.

```{r include=FALSE}
file_name <- "./cached_results/svm_blue.RData";
if( !all(file.exists(file_name)) )
{
  # The potential predictors:
  list_predictors <- c(# the languages:
    "macroarea",                                                       # macroarea
    "UV_mean_r", "UV_sd_r",                                            # UV-B incidence
    "longitude_r", "latitude_r",                                       # geographic location
    "subsistence", "log_popSize_ethno",                                # subsistence strategy and population size
    "clim_PC1_r", "clim_PC2_r", "clim_PC3_r", "hum_median", "hum_IQR", # climate, ecology and humidity
    "elevation_r",                                                     # altitude 
    "dist2water_r", "dist2ocean_r", "dist2lakes_r", "dist2rivers_r",   # distances to large bodies of water 
    # the language family origins:
    "UV_mean_family_r", "UV_sd_family_r",                                                                 # UV incidence
    "longitude_family_r", "latitude_family_r",                                                            # geographic location
    "clim_PC1_family_r", "clim_PC2_family_r", "clim_PC3_family_r", "hum_median_family", "hum_IQR_family", # climate, ecology and humidity 
    "elevation_family_r",                                                                                 # altitude 
    "dist2water_family_r", "dist2ocean_family_r", "dist2lakes_family_r", "dist2rivers_family_r"           # distances to large bodies of water 
  );
  # remove the NAs in the relevant variables as SVM complains...
  #d <- d[ complete.cases(d[,c("exists_blue", list_predictors)])];
  d_nona <- as.data.frame(d[ complete.cases(d[,c("exists_blue", list_predictors)]), c("exists_blue", list_predictors)]);

  # Save:
  svm_blue <- list("data"=d_nona);
  
  
  # On all the data:
  f_full <- formula(paste0("exists_blue ~ ", paste0(list_predictors,collapse=" + "))); 
  
  # fit the SVMs:
  svm_fit_full <- rminer::fit(f_full, d_nona, model="svm", task="class");

  # confusion matrices on the test data:
  cm_svm_full <- confusionMatrix(d_nona$exists_blue, predict(svm_fit_full, d_nona, type='class'), positive="yes");

  # predictor importance (based on sensitivity analysis):
  tmp          <- rminer::Importance(svm_fit_full, d_nona, method="CSA"); 
  pia_svm_full <- tmp$imp; names(pia_svm_full) <- names(d_nona); pia_svm_full <- pia_svm_full[names(pia_svm_full) %in% list_predictors];

  # Save:
  svm_blue$full <- list("success"=data.frame("accuracy"   =cm_svm_full$overall["Accuracy"],
                                             "sensitivity"=cm_svm_full$byClass["Sensitivity"], 
                                             "specificity"=cm_svm_full$byClass["Specificity"],
                                             "precision"  =cm_svm_full$byClass["Precision"],
                                             "recall"     =cm_svm_full$byClass["Recall"],
                                             row.names=NULL),   
                        "pred_importance"=data.frame("predictor"  =list_predictors,                # predictors
                                                     "importance" =pia_svm_full[list_predictors], # sensitivity-based
                                                     row.names=NULL));
  
  # Using traning/testing subsets:
  results <- pblapply(1:n_train, function(i)
    {
      # split the dataset into a training (80%) and a testing (20%) set stratified by exists_blue:
      data_train <- training(train_test_splits[[i]]);
      data_test  <- testing(train_test_splits[[i]]);
      # keep only the relevant columns and no NAs:
      data_train <- as.data.frame(data_train[ complete.cases(data_train[,c("exists_blue", list_predictors)]), c("exists_blue", list_predictors)]);
      data_test  <- as.data.frame(data_test [ complete.cases(data_test [,c("exists_blue", list_predictors)]), c("exists_blue", list_predictors)]);
      
      # fit the SVMs:
      svm_fit_full <- rminer::fit(f_full, data_train, model="svm", task="class");

      # confusion matrices on the test data:
      cm_svm_full <- confusionMatrix(data_test$exists_blue, predict(svm_fit_full, data_test, type='class'), positive="yes");

      # predictor importance (based on sensitivity analysis):
      tmp <- rminer::Importance(svm_fit_full, data_train, method="CSA"); 
      pia_svm_full <- tmp$imp; names(pia_svm_full) <- names(data_train); pia_svm_full <- pia_svm_full[names(pia_svm_full) %in% list_predictors];

      # return the results:
      success_full <- data.frame("replication"    =i, # replication
                                 "accuracy"   =cm_svm_full$overall["Accuracy"],
                                 "sensitivity"=cm_svm_full$byClass["Sensitivity"], 
                                 "specificity"=cm_svm_full$byClass["Specificity"],
                                 "precision"  =cm_svm_full$byClass["Precision"],
                                 "recall"     =cm_svm_full$byClass["Recall"],
                                 row.names=NULL);
      pi_df_full   <- data.frame("replication"=i,                                   # replication
                                 "predictor"  =list_predictors,                # predictors
                                 "importance" =pia_svm_full[list_predictors], # sensitivity-based
                                 row.names=NULL);

      return (list("replication"       =i,
                   "data_train_indices"=train_test_splits[[i]]$in_id, 
                   "data_test_indices" =setdiff(1:nrow(train_test_splits[[i]]$data), train_test_splits[[i]]$in_id),
                   "full"         =list("success"=success_full,   "pred_importance"=pi_df_full)));
    });
  
  # Assemble the various results and save them:
  svm_blue$training_testing <- list("replications"=n_train,
                                    "full"=list("success"=do.call(rbind, lapply(results, function(x) x$full$success)), 
                                                "pred_importance"=do.call(rbind, lapply(results, function(x) x$full$pred_importance))));
  save(svm_blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
} 
```

On the full data:

```{r}
kable((tmp_all <- data.frame("Predictors" =c("All predictors"),
                 rbind(100*svm_blue$full$success))),
      row.names=FALSE, digits=c(NA, 1, 1, 1, 1, 1), 
      caption=capTab("Success (as %) on the full dataset using SVMs with all potential predictors."));
```

The predictors ordered by their importance (only those with importance > 0):

```{r results='asis'}
tmp <- svm_blue$full$pred_importance[ order(svm_blue$full$pred_importance$importance, decreasing=TRUE), ];
tmp <- tmp[ tmp$importance > 0, ];
cat(paste0("- with all predictors: ", paste0("*",tmp$predictor,"*", " (", round(tmp$importance,2), ")", collapse=", ")));
```

When using `r svm_blue$training_testing$replications` random training/testing subsets:

```{r}
tmp_full   <- vapply(svm_blue$training_testing$full$success[,-1],    function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1));
tmp <- data.frame("Predictors" =rep(c("All predictors")),
                  "accuracy"   =c(tmp_full[ grep("accuracy",    names(tmp_full), fixed=TRUE) ]),
                  "sensitivity"=c(tmp_full[ grep("sensitivity", names(tmp_full), fixed=TRUE) ]),
                  "specificity"=c(tmp_full[ grep("specificity", names(tmp_full), fixed=TRUE) ]),
                  "precision"  =c(tmp_full[ grep("precision",   names(tmp_full), fixed=TRUE) ]),
                  "recall"     =c(tmp_full[ grep("recall",      names(tmp_full), fixed=TRUE) ]));
kable(tmp, row.names=FALSE, col.names=c("Predictors", "Accuracy", "Sensitivity", "Specificity", "Precision", "Recall"),
      caption=capTab(paste0("Various measures of success at predicting *blue* using SVMs with ",svm_blue$training_testing$replications," training/testing sets.")));
```

```{r fig.cap=capFig(paste0("Various measures of success using SVMs with ",svm_blue$replications," training/testing sets. Boxplots show the spread of the training/testing values, while the solid horizontal red lines show the values when using the full dataset."), TRUE, c("ggplot2"), is_map=FALSE), fig.width=1*6, fig.height=5}
ggplot(svm_blue$training_testing$full$success %>% 
         reshape2::melt(id.vars=c("replication"), variable.name="measure", value.name="value") %>% 
         mutate("measure"=factor(measure, levels=c("accuracy", "sensitivity", "specificity", "precision", "recall")), "value"=value*100), 
       aes(x=measure, y=value)) + 
  ylim(c(0,100)) + xlab("Measures of success") + ylab("Value (%)") +
  theme_bw() +
  geom_boxplot(show.legend=FALSE) + 
  # draw alternating vertical bands:
  new_scale_fill() + 
  scale_fill_manual("", values=c("white", "gray95")) +
  geom_rect(aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=0, ymax=100, fill=as.factor(as.numeric(measure) %% 2 == 0)), show.legend=FALSE) + 
  # draw the actual boxplots:
  new_scale_fill() + 
  geom_boxplot(aes(x=measure, y=value)) + 
  # measures on the full dataset:
  geom_rect(data=tmp_all %>%
               reshape2::melt(measure.vars=c("accuracy", "sensitivity", "specificity", "precision", "recall"), variable.name="measure", value.name="value") %>% 
               mutate("measure"=factor(measure, 
                                       levels=c("accuracy", "sensitivity", "specificity", "precision", "recall"))), 
             aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=value, ymax=value), color="red", fill=NA) +  theme(legend.position="right");
```

The importance of the predictors is:

```{r fig.cap=capFig(paste0("Specificity-based predictor importance from SVMs using ",svm_blue$training_testing$replications," training/testing sets."), TRUE, c("ggplot2"), is_map=FALSE), fig.width=4*1, fig.height=7*1}
grid.arrange(ggplot(svm_blue$training_testing$full$pred_importance, 
                    aes(x=reorder(predictor, importance, median), y=importance)) +
               theme_bw() +
               geom_boxplot(fill="gold", color="black") + ylim(NA, 0.1) +
               labs(x="Predictors (sorted by decreasing importance)", y="Importance") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="none") +
               ggtitle("Sorted by importance") + 
               coord_flip() + 
               NULL,
             ncol=1);
```



## The shape of the effect of UV-B incidence on 'blue'

Here we use different approaches to try to find the shape of this relationship which might provide hints about the causal mechanisms involved, and we focus on the TOMS measurements.

In the following, we'll use the *z*-scored values of UV-B incidence (mean and sd), so we need to provide the back-mapping to their raw values:

- for mean(UV-B): 0 → `r round(mean(d_colors_ag$UV_mean),1)`mW/m^2^, `r round(min(d_colors_ag$UV_mean_r),2)` → `r round(min(d_colors_ag$UV_mean),2)`mW/m^2^, `r round(max(d_colors_ag$UV_mean_r),2)` → `r round(max(d_colors_ag$UV_mean),1)`mW/m^2^; in general: UV~raw~[mW/m^2^] = `r round(mean(d_colors_ag$UV_mean),1)`[mW/m^2^] + UV~z~∙`r round(sd(d_colors_ag$UV_mean),1)`[mW/m^2^]. As an example, the mean UV incidence in England is `r round(d_colors_ag$UV_mean[d_colors_ag$glottocode=="stan1293"])` [mW/m^2^]; the maximum UV incidence belongs to the population `r d_colors_ag$glottocode[which((d_colors_ag$UV_mean)==max(d_colors_ag$UV_mean))]` (Central Aymara, a language spoken very high in altitude in Bolivia) with a mean UV incidence of `r gg <- d_colors_ag$glottocode[which((d_colors_ag$UV_mean)==max(d_colors_ag$UV_mean))]; round(d_colors_ag$UV_mean[d_colors_ag$glottocode==gg],2)` mW/m^2^ while the minimum UV incidence belongs to the population `r d_colors_ag$glottocode[which((d_colors_ag$UV_mean)==min(d_colors_ag$UV_mean))]` (Nganasan, in northern Siberia) with a mean UV incidence of `r gg <- d_colors_ag$glottocode[which((d_colors_ag$UV_mean)==min(d_colors_ag$UV_mean))]; round(d_colors_ag$UV_mean[d_colors_ag$glottocode==gg],2)` mW/m^2^

- for sd(UV-B): 0 → `r round(mean(d_colors_ag$UV_sd),1)`mW/m^2^, `r round(min(d_colors_ag$UV_sd_r),2)` → `r round(min(d_colors_ag$UV_sd),2)`mW/m^2^, `r round(max(d_colors_ag$UV_sd_r),2)` → `r round(max(d_colors_ag$UV_sd),1)`mW/m^2^; in general: UV~raw~[mW/m^2^] = `r round(mean(d_colors_ag$UV_sd),1)`[mW/m^2^] + UV~z~∙`r round(sd(d_colors_ag$UV_sd),1)`[mW/m^2^].As an example, the sd UV incidence in England is `r round(d_colors_ag$UV_sd[d_colors_ag$glottocode=="stan1293"])` [mW/m^2^]; the maximum standard deviation of UV incidence belongs to the population `r d_colors_ag$glottocode[which((d_colors_ag$UV_sd)==max(d_colors_ag$UV_sd))]` (Southern Yukaghir, a language spoken in China not too far from North Korea) with an sd UV incidence of `r gg <- d_colors_ag$glottocode[which((d_colors_ag$UV_sd)==max(d_colors_ag$UV_sd))]; round(d_colors_ag$UV_sd[d_colors_ag$glottocode==gg],2)` mW/m^2^ while the minimum belongs to the population `r d_colors_ag$glottocode[which((d_colors_ag$UV_sd)==min(d_colors_ag$UV_sd))]` (Kayapo, in Amazonia) with an sd UV incidence of `r gg <- d_colors_ag$glottocode[which((d_colors_ag$UV_sd)==min(d_colors_ag$UV_sd))]; round(d_colors_ag$UV_sd[d_colors_ag$glottocode==gg],2)` mW/m^2^

```{r fig.cap=capFig("Linear relationship between raw and *z*-scored values for the mean (left) and standard deviation (right) of UV-B incidence."), fig.width=4, fig.height=4, fig.show="hold", out.width="50%"}
ggplot(d_colors_ag, aes(x=UV_mean_r, y=UV_mean)) + 
  geom_smooth(method="lm", color="skyblue", alpha=0.5) + 
  geom_point(color="blue") +
  xlab("mean z-scored UV") + ylab("mean raw UV [mW/m"^"2"~"]") + 
  NULL;
ggplot(d_colors_ag, aes(x=UV_sd_r, y=UV_sd)) + 
  geom_smooth(method="lm", color="salmon", alpha=0.5) + 
  geom_point(color="red") +
  xlab("sd z-scored UV") + ylab("sd raw UV [mW/m"^"2"~"]") + 
  NULL;
```

```{r fig.cap=capFig("Relationship between the existence of a word for 'blue' and mean UV-B incidence (left column) and the standard deviation of UV-B incidence (right column), showing the actual values (top row) and the histogram and density (bottom row)."), fig.width=6*2, fig.height=3*2}
grid.arrange(ggplot(d_colors_ag, aes(x=UV_mean, y=exists_blue, color=exists_blue)) +
               geom_jitter(width=0.0, height=0.2, alpha=0.5) + 
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("mean(UV-B) [mW/m"^"2"~"]") + ylab("Is there 'blue'?") +
               NULL,
             ggplot(d_colors_ag, aes(x=UV_sd, y=exists_blue, color=exists_blue)) +
               geom_jitter(width=0.0, height=0.2, alpha=0.5) + 
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("sd(UV-B) [mW/m"^"2"~"]") + ylab("Is there 'blue'?") +
               NULL,
             ggplot(d_colors_ag, aes(x=UV_mean, color=exists_blue)) +
               geom_histogram(aes(y=..density..), alpha=0.25, position="identity", binwidth=5, fill="white")+
               geom_density(alpha=0.75, size = 1) +
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("mean(UV-B) [mW/m"^"2"~"]") + 
               NULL,
             ggplot(d_colors_ag, aes(x=UV_sd, color=exists_blue)) +
               geom_histogram(aes(y=..density..), alpha=0.25, position="identity", binwidth=5, fill="white")+
               geom_density(alpha=0.75, size = 1) +
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("sd(UV-B) [mW/m"^"2"~"]") +
               NULL,
             ncol=2);
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_shape_global";
#png(paste0("./paper/",file_name,".png"), width=6*2, height=3*2, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=6*2, height=3*2, units="in", res=300, quality=85); # for SI
grid.arrange(ggplot(d_colors_ag, aes(x=UV_mean, y=exists_blue, color=exists_blue)) +
               geom_jitter(width=0.0, height=0.2, alpha=0.5) + 
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("mean(UV-B) [mW/m"^"2"~"]") + ylab("Is there 'blue'?") +
               NULL,
             ggplot(d_colors_ag, aes(x=UV_sd, y=exists_blue, color=exists_blue)) +
               geom_jitter(width=0.0, height=0.2, alpha=0.5) + 
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("sd(UV-B) [mW/m"^"2"~"]") + ylab("Is there 'blue'?") +
               NULL,
             ggplot(d_colors_ag, aes(x=UV_mean, color=exists_blue)) +
               geom_histogram(aes(y=..density..), alpha=0.25, position="identity", binwidth=5, fill="white")+
               geom_density(alpha=0.75, size = 1) +
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("mean(UV-B) [mW/m"^"2"~"]") + 
               NULL,
             ggplot(d_colors_ag, aes(x=UV_sd, color=exists_blue)) +
               geom_histogram(aes(y=..density..), alpha=0.25, position="identity", binwidth=5, fill="white")+
               geom_density(alpha=0.75, size = 1) +
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("sd(UV-B) [mW/m"^"2"~"]") +
               NULL,
             ncol=2);
dev.off();
```

```{r fig.cap=capFig("Same plot as above for mean UV-B incidence, but split by macroareas. The axes are free to vary between macroareas."), fig.width=8*2, fig.height=3*2}
grid.arrange(ggplot(d_colors_ag, aes(x=UV_mean, y=exists_blue, color=exists_blue)) +
               geom_jitter(width=0.0, height=0.2, alpha=0.5) + 
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("mean(UV-B) [mW/m"^"2"~"]") + ylab("Is there 'blue'?") +
               facet_wrap(. ~ macroarea, ncol=length(unique(d_colors_ag$macroarea)), scales="free") +
               NULL,
             ggplot(d_colors_ag, aes(x=UV_mean, color=exists_blue)) +
               geom_histogram(aes(y=..density..), alpha=0.25, position="identity", binwidth=5, fill="white")+
               geom_density(alpha=0.75, size = 1) +
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("mean(UV-B) [mW/m"^"2"~"]") +
               facet_wrap(. ~ macroarea, ncol=length(unique(d_colors_ag$macroarea)), scales="free") +
               NULL,
             ncol=1);
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_shape_macroareas_mean";
#png(paste0("./paper/",file_name,".png"), width=6*2, height=3*2, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=6*2, height=3*2, units="in", res=300, quality=85); # for SI
grid.arrange(ggplot(d_colors_ag, aes(x=UV_mean, y=exists_blue, color=exists_blue)) +
               geom_jitter(width=0.0, height=0.2, alpha=0.5) + 
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("mean(UV-B) [mW/m"^"2"~"]") + ylab("Is there 'blue'?") +
               facet_wrap(. ~ macroarea, ncol=length(unique(d_colors_ag$macroarea)), scales="free") +
               NULL,
             ggplot(d_colors_ag, aes(x=UV_mean, color=exists_blue)) +
               geom_histogram(aes(y=..density..), alpha=0.25, position="identity", binwidth=5, fill="white")+
               geom_density(alpha=0.75, size = 1) +
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("mean(UV-B) [mW/m"^"2"~"]") +
               facet_wrap(. ~ macroarea, ncol=length(unique(d_colors_ag$macroarea)), scales="free") +
               NULL,
             ncol=1);
dev.off();
```

```{r fig.cap=capFig("Same plot as above for sd UV-B incidence, but split by macroareas. The axes are free to vary between macroareas."), fig.width=8*2, fig.height=3*2}
grid.arrange(ggplot(d_colors_ag, aes(x=UV_sd, y=exists_blue, color=exists_blue)) +
               geom_jitter(width=0.0, height=0.2, alpha=0.5) + 
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("sd(UV-B) [mW/m"^"2"~"]") + ylab("Is there 'blue'?") +
               facet_wrap(. ~ macroarea, ncol=length(unique(d_colors_ag$macroarea)), scales="free") +
               NULL,
             ggplot(d_colors_ag, aes(x=UV_sd, color=exists_blue)) +
               geom_histogram(aes(y=..density..), alpha=0.25, position="identity", binwidth=5, fill="white")+
               geom_density(alpha=0.75, size = 1) +
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("sd(UV-B) [mW/m"^"2"~"]") +
               facet_wrap(. ~ macroarea, ncol=length(unique(d_colors_ag$macroarea)), scales="free") +
               NULL,
             ncol=1);
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_shape_macroareas_sd";
#png(paste0("./paper/",file_name,".png"), width=6*2, height=3*2, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=6*2, height=3*2, units="in", res=300, quality=85); # for SI
grid.arrange(ggplot(d_colors_ag, aes(x=UV_sd, y=exists_blue, color=exists_blue)) +
               geom_jitter(width=0.0, height=0.2, alpha=0.5) + 
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("sd(UV-B) [mW/m"^"2"~"]") + ylab("Is there 'blue'?") +
               facet_wrap(. ~ macroarea, ncol=length(unique(d_colors_ag$macroarea)), scales="free") +
               NULL,
             ggplot(d_colors_ag, aes(x=UV_sd, color=exists_blue)) +
               geom_histogram(aes(y=..density..), alpha=0.25, position="identity", binwidth=5, fill="white")+
               geom_density(alpha=0.75, size = 1) +
               scale_color_manual("Blue?", values = c("#868686FF", "#EFC000FF")) +
               theme_bw() + xlab("sd(UV-B) [mW/m"^"2"~"]") +
               facet_wrap(. ~ macroarea, ncol=length(unique(d_colors_ag$macroarea)), scales="free") +
               NULL,
             ncol=1);
dev.off();
```


### Regression

```{r include=FALSE}
file_name <- "./cached_results/shape_uvb__blue_reg.RData";
if( !file.exists(file_name) )
{
  ### mean UV-B:
  
  ## Use glmer:
  
  # N=3:
  m_sh_uvbm_n3 <- glmer(exists_blue ~ 1 + UV_mean_r + I(UV_mean_r^2) + I(UV_mean_r^3) + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
  summary(m_sh_uvbm_n3);
  
  # N=2:
  m_sh_uvbm_n2 <- update(m_sh_uvbm_n3, . ~ . - I(UV_mean_r^3));
  summary(m_sh_uvbm_n2);
  anova(m_sh_uvbm_n2, m_sh_uvbm_n3); # N=3 can be dropped
  
  # N=1:
  m_sh_uvbm_n1 <- update(m_sh_uvbm_n2, . ~ . - I(UV_mean_r^2));
  summary(m_sh_uvbm_n1);
  anova(m_sh_uvbm_n1, m_sh_uvbm_n2); # N=2 makes a difference
  # ---> N=2 seems best

  plot_model(m_sh_uvbm_n1, type="pred", terms="UV_mean_r [all]", axis.lim=c(0,1));
  plot_model(m_sh_uvbm_n2, type="pred", terms="UV_mean_r [all]", axis.lim=c(0,1));
  plot_model(m_sh_uvbm_n2, type="re")[[2]]; # macroarea
  
  
  ## Use brms:
  
  # N=3:
  b_sh_uvbm_n3 <- brm(exists_blue ~ 1 + UV_mean_r + I(UV_mean_r^2) + I(UV_mean_r^3) + (1 | glottocode_family) + (1 | macroarea),
                      family=bernoulli(link="logit"), data=d_colors_ag, 
                      prior=c(prior(student_t(3, 0, 2.5), class="Intercept"),
                              prior(student_t(3, 0, 2.5), class="b")), # pretty wide priors centered on 0
                      sample_prior=TRUE,  # needed for hypotheses tests
                      cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
  summary(b_sh_uvbm_n3); mcmc_plot(b_sh_uvbm_n3, type="trace"); mcmc_plot(b_sh_uvbm_n3);
  hdi(b_sh_uvbm_n3, ci=0.95);
  brms::hypothesis(b_sh_uvbm_n3, c("UV_mean_r = 0", "IUV_mean_rE2 = 0", "IUV_mean_rE3 = 0")); # N=3 can be dropped
  
  # N=2:
  b_sh_uvbm_n2 <- update(b_sh_uvbm_n3, . ~ . - I(UV_mean_r^3), cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
  summary(b_sh_uvbm_n2); mcmc_plot(b_sh_uvbm_n2, type="trace"); mcmc_plot(b_sh_uvbm_n2);
  hdi(b_sh_uvbm_n2, ci=0.95);
  brms::hypothesis(b_sh_uvbm_n2, c("UV_mean_r = 0", "IUV_mean_rE2 = 0")); # N=2 makes a difference
  
  # N=1:
  b_sh_uvbm_n1 <- update(b_sh_uvbm_n2, . ~ . - I(UV_mean_r^2), cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
  summary(b_sh_uvbm_n1); mcmc_plot(b_sh_uvbm_n1, type="trace"); mcmc_plot(b_sh_uvbm_n1);
  hdi(b_sh_uvbm_n1, ci=0.95);
  brms::hypothesis(b_sh_uvbm_n1, c("UV_mean_r = 0")); # N=1 makes a difference
  
  plot_model(b_sh_uvbm_n1, type="pred", terms="UV_mean_r [all]", axis.lim=c(0,1));
  plot_model(b_sh_uvbm_n2, type="pred", terms="UV_mean_r [all]", axis.lim=c(0,1));
  
  # --> the glmer and brms results are very similar!

  
  ### sd UV-B:
  
  ## Use glmer:
  
  # N=3:
  m_sh_uvbs_n3 <- glmer(exists_blue ~ 1 + UV_sd_r + I(UV_sd_r^2) + I(UV_sd_r^3) + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag);
  summary(m_sh_uvbs_n3);
  
  # N=2:
  m_sh_uvbs_n2 <- update(m_sh_uvbs_n3, . ~ . - I(UV_sd_r^3));
  summary(m_sh_uvbs_n2);
  anova(m_sh_uvbs_n2, m_sh_uvbs_n3); # N=3 can be dropped
  
  # N=1:
  m_sh_uvbs_n1 <- update(m_sh_uvbs_n2, . ~ . - I(UV_sd_r^2));
  summary(m_sh_uvbs_n1);
  anova(m_sh_uvbs_n1, m_sh_uvbs_n2); # N=2 can be dropped
  # ---> N=1 seems best

  plot_model(m_sh_uvbs_n1, type="pred", terms="UV_sd_r [all]", axis.lim=c(0,1));
  plot_model(m_sh_uvbs_n1, type="re")[[2]]; # macroarea
  
  
  ## Use brms:
  
  # N=3:
  b_sh_uvbs_n3 <- brm(exists_blue ~ 1 + UV_sd_r + I(UV_sd_r^2) + I(UV_sd_r^3) + (1 | glottocode_family) + (1 | macroarea),
                      family=bernoulli(link="logit"), data=d_colors_ag, 
                      prior=c(prior(student_t(3, 0, 2.5), class="Intercept"),
                              prior(student_t(3, 0, 2.5), class="b")), # pretty wide priors centered on 0
                      sample_prior=TRUE,  # needed for hypotheses tests
                      cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
  summary(b_sh_uvbs_n3); mcmc_plot(b_sh_uvbs_n3, type="trace"); mcmc_plot(b_sh_uvbs_n3);
  hdi(b_sh_uvbs_n3, ci=0.95);
  brms::hypothesis(b_sh_uvbs_n3, c("UV_sd_r = 0", "IUV_sd_rE2 = 0", "IUV_sd_rE3 = 0")); # N=3 can be dropped
  
  # N=2:
  b_sh_uvbs_n2 <- update(b_sh_uvbs_n3, . ~ . - I(UV_sd_r^3), cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
  summary(b_sh_uvbs_n2); mcmc_plot(b_sh_uvbs_n2, type="trace"); mcmc_plot(b_sh_uvbs_n2);
  hdi(b_sh_uvbs_n2, ci=0.95);
  brms::hypothesis(b_sh_uvbs_n2, c("UV_sd_r = 0", "IUV_sd_rE2 = 0")); # N=2 can be dropped
  
  # N=1:
  b_sh_uvbs_n1 <- update(b_sh_uvbs_n2, . ~ . - I(UV_sd_r^2), cores=brms_ncores, iter=reg_iter, warmup=reg_warmup, thin=reg_thin, control=reg_control);
  summary(b_sh_uvbs_n1); mcmc_plot(b_sh_uvbs_n1, type="trace"); mcmc_plot(b_sh_uvbs_n1);
  hdi(b_sh_uvbs_n1, ci=0.95);
  brms::hypothesis(b_sh_uvbs_n1, c("UV_sd_r = 0")); # N=1 makes a difference
  
  plot_model(b_sh_uvbs_n1, type="pred", terms="UV_sd_r [all]", axis.lim=c(0,1));

  # --> the glmer and brms results are very similar!

  
  ### mean UV-B + subsistence:
  
  ## Use glmer:
  
  # N=3:
  m_sh_uvbm_subst_n3 <- glmer(exists_blue ~ 1 + UV_mean_r*subsistence + I(UV_mean_r^2)*subsistence + I(UV_mean_r^3)*subsistence + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag[ !is.na(d_colors_ag$subsistence), ]); # Failed to converge
  summary(m_sh_uvbm_subst_n3);
  
  # N=2:
  m_sh_uvbm_subst_n2 <- update(m_sh_uvbm_subst_n3, . ~ . - I(UV_mean_r^3) - I(UV_mean_r^3):subsistence); # singular
  summary(m_sh_uvbm_subst_n2);
  anova(m_sh_uvbm_subst_n2, m_sh_uvbm_subst_n3); # N=3 can be dropped
  
  # N=1:
  m_sh_uvbm_subst_n1 <- update(m_sh_uvbm_subst_n2, . ~ . - I(UV_mean_r^2) - I(UV_mean_r^2):subsistence);
  summary(m_sh_uvbm_subst_n1);
  anova(m_sh_uvbm_subst_n1, m_sh_uvbm_subst_n2); # N=2 can be dropped
  
  # interaction:
  m_sh_uvbm_substa_n1 <- update(m_sh_uvbm_subst_n1, . ~ . - UV_mean_r:subsistence);
  summary(m_sh_uvbm_substa_n1);
  anova(m_sh_uvbm_substa_n1, m_sh_uvbm_subst_n1); # interaction can be dropped
  
  # try to remove subsistence:
  m_sh_uvbm_subst0_n1 <- update(m_sh_uvbm_substa_n1, . ~ . - subsistence);
  summary(m_sh_uvbm_subst0_n1);
  anova(m_sh_uvbm_substa_n1, m_sh_uvbm_subst0_n1); # subsistence does make a difference!
  
  # ---> so, it seems that adding subsistence reduced the dataset by 103 (of 728) but basically replaced the quadratic effect of mean(UV-B)!

  plot_model(m_sh_uvbm_substa_n1, type="pred", terms=c("UV_mean_r [all]", "subsistence"), axis.lim=c(0,1));

  
  ### sd UV-B + subsistence:
  
  ## Use glmer:
  
  # N=3:
  m_sh_uvbs_subst_n3 <- glmer(exists_blue ~ 1 + UV_sd_r*subsistence + I(UV_sd_r^2)*subsistence + I(UV_sd_r^3)*subsistence + (1 | glottocode_family) + (1 | macroarea), family=binomial(), data=d_colors_ag[ !is.na(d_colors_ag$subsistence), ]); # Failed to converge
  summary(m_sh_uvbs_subst_n3);
  
  # N=2:
  m_sh_uvbs_subst_n2 <- update(m_sh_uvbs_subst_n3, . ~ . - I(UV_sd_r^3) - I(UV_sd_r^3):subsistence);
  summary(m_sh_uvbs_subst_n2);
  anova(m_sh_uvbs_subst_n2, m_sh_uvbs_subst_n3); # N=3 can be dropped
  
  # N=1:
  m_sh_uvbs_subst_n1 <- update(m_sh_uvbs_subst_n2, . ~ . - I(UV_sd_r^2) - I(UV_sd_r^2):subsistence); # singular
  summary(m_sh_uvbs_subst_n1);
  anova(m_sh_uvbs_subst_n1, m_sh_uvbs_subst_n2); # N=2 can be dropped
  
  # interaction:
  m_sh_uvbs_substa_n1 <- update(m_sh_uvbs_subst_n1, . ~ . - UV_sd_r:subsistence);
  summary(m_sh_uvbs_substa_n1);
  anova(m_sh_uvbs_substa_n1, m_sh_uvbs_subst_n1); # interaction can be dropped
  
  # try to remove subsistence:
  m_sh_uvbs_subst0_n1 <- update(m_sh_uvbs_substa_n1, . ~ . - subsistence);
  summary(m_sh_uvbs_subst0_n1);
  anova(m_sh_uvbs_substa_n1, m_sh_uvbs_subst0_n1); # subsistence does make a difference!
  
  # ---> so, it seems that adding subsistence reduced the dataset by 103 (of 728) but basically replaced the quadratic effect of mean(UV-B)!

  plot_model(m_sh_uvbs_substa_n1, type="pred", terms=c("UV_sd_r [all]", "subsistence"), axis.lim=c(0,1));

  

    
  # Save the results:
  shape_uvb__blue_reg <- list("mean"=list("quadratic"=m_sh_uvbm_n2, "linear"=m_sh_uvbm_n1, "linear_subsistence"=m_sh_uvbm_substa_n1, "quadratic_subsistence"=m_sh_uvbm_subst_n2),
                              "sd"  =list("quadratic"=m_sh_uvbs_n2, "linear"=m_sh_uvbs_n1, "linear_subsistence"=m_sh_uvbs_substa_n1, "quadratic_subsistence"=m_sh_uvbs_subst_n2));
  save(shape_uvb__blue_reg, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}

# Model predictions:
pred_lin_m  <- as.data.frame(ggeffects::ggpredict(shape_uvb__blue_reg$mean$linear,    "UV_mean_r [all]")); pred_lin_m  <- pred_lin_m[ order(pred_lin_m$x), ];   # make sure it is ordered by predictor
pred_lins_m_subst  <- as.data.frame(ggeffects::ggpredict(shape_uvb__blue_reg$mean$linear_subsistence, c("UV_mean_r [all]", "subsistence"))); pred_lins_m_subst  <- pred_lins_m_subst[ order(pred_lins_m_subst$x), ];   # make sure it is ordered by predictor
pred_quad_m <- as.data.frame(ggeffects::ggpredict(shape_uvb__blue_reg$mean$quadratic, "UV_mean_r [all]")); pred_quad_m <- pred_quad_m[ order(pred_quad_m$x), ]; # make sure it is ordered by predictor
pred_lin_s  <- as.data.frame(ggeffects::ggpredict(shape_uvb__blue_reg$sd$linear,      "UV_sd_r [all]"));   pred_lin_s  <- pred_lin_s[ order(pred_lin_s$x), ];   # make sure it is ordered by predictor
pred_lin_s_subst  <- as.data.frame(ggeffects::ggpredict(shape_uvb__blue_reg$sd$linear_subsistence, c("UV_sd_r [all]", "subsistence"))); pred_lin_s_subst <- pred_lin_s_subst[ order(pred_lin_s_subst$x), ];   # make sure it is ordered by predictor
```

We performed the logistic regression of 'blue' on the mean(UV-B) (*z*-scored) using both `glmer` and `brms` and, as the results are extremely similar, we present here only the former.

##### Mean UV-B incidence

We found that the quadratic regression fits the data best (we went up to a degree 3 polynomial), and both the linear and quadratic effects are highly significant.

In the **linear model**, going from the minimum mean UV-B incidence of `r round(min(d_colors_ag$UV_mean),1)` mW/m^2^ to the maximum of `r round(max(d_colors_ag$UV_mean),1)` mW/m^2^ is associated with a drop in the probability of 'blue' from about `r sprintf("%.0f%% 95%%CI [%.0f%%, %.0f%%]", 100*pred_lin_m$predicted[1], 100*pred_lin_m$conf.low[1], 100*pred_lin_m$conf.high[1])` to about `r sprintf("%.0f%% [%.0f%%, %.0f%%]", 100*pred_lin_m$predicted[nrow(pred_lin_m)], 100*pred_lin_m$conf.low[nrow(pred_lin_m)], 100*pred_lin_m$conf.high[nrow(pred_lin_m)])`.

However, allowing a **quadratic term** suggests that the relationship might not be linear (or even monotonic) at low mean UV-B incidences (the confidence interval is very wide) and instead the probability of 'blue' might plateau (or reach a maximum) at about `r round(mean(d_colors_ag$UV_mean) + sd(d_colors_ag$UV_mean) * pred_quad_m$x[ x <- which.max(pred_quad_m$predicted) ],1)` mW/m^2^ mean UV-B incidence of about `r sprintf("%.0f%% [%.0f%%, %.0f%%]", 100*pred_quad_m$predicted[x], 100*pred_quad_m$conf.low[x], 100*pred_quad_m$conf.high[x])`, and fall off to `r sprintf("%.0f%% [%.0f%%, %.0f%%]", 100*pred_quad_m$predicted[nrow(pred_quad_m)], 100*pred_quad_m$conf.low[nrow(pred_quad_m)], 100*pred_quad_m$conf.high[nrow(pred_quad_m)])` for the maximum mean UV-B incidence, and also (but see the very wide 95%CI!) towards `r sprintf("%.0f%% [%.0f%%, %.0f%%]", 100*pred_quad_m$predicted[1], 100*pred_quad_m$conf.low[1], 100*pred_quad_m$conf.high[1])` for the minimum mean UV-B incidence.

```{r fig.cap=capFig("The modelled effect of mean(UV-B) [mW/m^2^] on 'blue': left: linear model, middle: quadratic model, right: macroarea in the quadratic model."), fig.width=4, fig.height=4, fig.show="hold", out.width="30%"}
plot_model(shape_uvb__blue_reg$mean$linear,    type="pred", terms="UV_mean_r [all]", axis.lim=c(0,1)) + xlab("mean UV-B [mW/m"^"2"~"]") + ylab("Probability of 'blue'");
plot_model(shape_uvb__blue_reg$mean$quadratic, type="pred", terms="UV_mean_r [all]", axis.lim=c(0,1)) + xlab("mean UV-B [mW/m"^"2"~"]") + ylab("Probability of 'blue'");
plot_model(shape_uvb__blue_reg$mean$quadratic, type="re")[[2]]; # macroarea
```

However, the "dip" at lower mean UV-B incidences (higher latitudes) could be an artifact of HG populations that tend to lack a word for 'blue;, so we also performed the same polynomial regression also including all the interactions with subsistence.
Now, model simplification suggests that the best model actually comprises the linear effect of UV-B and the independent contribution of subsistence (i.e., with no interaction between the two):

```{r fig.cap=capFig("The modelled effect of mean(UV-B) [mW/m^2^] and subsistence on 'blue'."), fig.width=5, fig.height=4}
plot_model(shape_uvb__blue_reg$mean$linear_subsistence, type="pred", terms=c("UV_mean_r [all]", "subsistence"), axis.lim=c(0,1)) + xlab("mean UV-B [mW/m"^"2"~"]") + ylab("Probability of 'blue'");
```

The model comparisons are:

- linear vs quadratic: `r sprintf("*χ*^2^(%d)=%.2f, *p*=%.3g, ΔAIC=%.1f, ΔBIC=%.1f", (a <- anova(shape_uvb__blue_reg$mean$linear, shape_uvb__blue_reg$mean$quadratic))$Df[2], a$Chisq[2], a[2,"Pr(>Chisq)"], a$AIC[1]-a$AIC[2], a$BIC[1]-a$BIC[2])`
- quadratic vs subsistence + linear: `r sprintf("ΔAIC=%.1f, ΔBIC=%.1f", AIC(shape_uvb__blue_reg$mean$quadratic) - AIC(shape_uvb__blue_reg$mean$linear_subsistence), BIC(shape_uvb__blue_reg$mean$quadratic) - BIC(shape_uvb__blue_reg$mean$linear_subsistence))`

#### SD UV-B incidence

We found that the linear regression fits the data best (we went up to a degree 3 polynomial).

In the **linear model**, going from the minimum sd UV-B incidence of `r round(min(d_colors_ag$UV_sd),1)` mW/m^2^ to the maximum of `r round(max(d_colors_ag$UV_sd),1)` mW/m^2^ is associated with an increase in the probability of 'blue' from about `r sprintf("%.0f%% [%.0f%%, %.0f%%]", 100*pred_lin_s$predicted[1], 100*pred_lin_s$conf.low[1], 100*pred_lin_s$conf.high[1])` to about `r sprintf("%.0f%% [%.0f%%, %.0f%%]", 100*pred_lin_s$predicted[nrow(pred_lin_s)], 100*pred_lin_s$conf.low[nrow(pred_lin_s)], 100*pred_lin_s$conf.high[nrow(pred_lin_s)])`.

```{r fig.cap=capFig("The modelled effect of sd(UV-B) on 'blue': left: linear model, middle: quadratic model, right: macroarea in the quadratic model."), fig.width=4, fig.height=4, fig.show="hold", out.width="30%"}
plot_model(shape_uvb__blue_reg$sd$linear, type="pred", terms="UV_sd_r [all]", axis.lim=c(0,1)) + xlab("sd UV-B [mW/m"^"2"~"]") + ylab("Probability of 'blue'");
plot_model(shape_uvb__blue_reg$sd$linear, type="re")[[2]]; # macroarea
```

As above, we also performed the same polynomial regression also including all the interactions with subsistence, and the best model actually comprises the linear effect of UV-B and the independent contribution of subsistence (i.e., with no interaction between the two):

```{r fig.cap=capFig("The modelled effect of sd(UV-B) [mW/m^2^] and subsistence on 'blue'."), fig.width=5, fig.height=4}
plot_model(shape_uvb__blue_reg$sd$linear_subsistence, type="pred", terms=c("UV_sd_r [all]", "subsistence"), axis.lim=c(0,1)) + xlab("sd UV-B [mW/m"^"2"~"]") + ylab("Probability of 'blue'");
```

The model comparisons are:

- linear vs quadratic: `r sprintf("*χ*^2^(%d)=%.2f, *p*=%.3g, ΔAIC=%.1f, ΔBIC=%.1f", (a <- anova(shape_uvb__blue_reg$sd$linear, shape_uvb__blue_reg$sd$quadratic))$Df[2], a$Chisq[2], a[2,"Pr(>Chisq)"], a$AIC[1]-a$AIC[2], a$BIC[1]-a$BIC[2])`
- linear vs subsistence + linear: `r sprintf("ΔAIC=%.1f, ΔBIC=%.1f", AIC(shape_uvb__blue_reg$sd$linear) - AIC(shape_uvb__blue_reg$sd$linear_subsistence), BIC(shape_uvb__blue_reg$sd$linear) - BIC(shape_uvb__blue_reg$sd$linear_subsistence))`

```{r include=FALSE}
# Figure for paper:
png("./paper/fig_shape_uvb_blue_subst.png", width=3*3, height=3*2, units="in", res=300);
grid.arrange(
  plot_model(shape_uvb__blue_reg$mean$linear,    type="pred", terms="UV_mean_r [all]", axis.lim=c(0,1)) + xlab("mean UV-B [mW/m"^"2"~"]") + ylab("Probability of 'blue'") + ggtitle("linear"),
  plot_model(shape_uvb__blue_reg$mean$quadratic, type="pred", terms="UV_mean_r [all]", axis.lim=c(0,1)) + xlab("mean UV-B [mW/m"^"2"~"]") + ylab("Probability of 'blue'") + ggtitle("linear + quadratic"),
  plot_model(shape_uvb__blue_reg$mean$linear_subsistence, type="pred", terms=c("UV_mean_r [all]", "subsistence"), axis.lim=c(0,1)) + xlab("mean UV-B [mW/m"^"2"~"]") + ylab("Probability of 'blue'") + ggtitle("linear + subsistence") + theme(legend.position=c(0.25, 0.25)),
  plot_model(shape_uvb__blue_reg$sd$linear, type="pred", terms="UV_sd_r [all]", axis.lim=c(0,1)) + xlab("sd UV-B [mW/m"^"2"~"]") + ylab("Probability of 'blue'") + ggtitle("linear"),
  grid.rect(gp=gpar(col="white")),
  plot_model(shape_uvb__blue_reg$sd$linear_subsistence, type="pred", terms=c("UV_sd_r [all]", "subsistence"), axis.lim=c(0,1)) + xlab("sd UV-B [mW/m"^"2"~"]") + ylab("Probability of 'blue'") + ggtitle("linear + subsistence") + theme(legend.position=c(0.75, 0.25)),
  ncol=3);
dev.off();
```


### Conditional inference trees

```{r include=FALSE}
file_name <- "./cached_results/shape_uvb__blue_ctree.RData";
if( !all(file.exists(file_name)) )
{
  d <- d_colors_ag; d$macroarea <- factor(d$macroarea);
  
  ## Mean UV-B:
  
  # with macroarea:
  ctree_uvbm_ma <- ctree(exists_blue ~ macroarea + UV_mean, data = d, control = ctree_control(testtype = c("MonteCarlo"), maxdepth=2));
  plot(ctree_uvbm_ma);
  cm_ctree_uvbm_ma <- confusionMatrix(d$exists_blue, predict(ctree_uvbm_ma,  newdata=d, allow_new_levels=TRUE), positive="yes");
  
  # just UV-B:
  ctree_uvbm <- ctree(exists_blue ~ UV_mean, data = d, control = ctree_control(testtype = c("MonteCarlo")));
  plot(ctree_uvbm);
  cm_ctree_uvbm <- confusionMatrix(d$exists_blue, predict(ctree_uvbm,  newdata=d, allow_new_levels=TRUE), positive="yes");

  
  ## sd UV-B:
  
  # with macroarea:
  ctree_uvbs_ma <- ctree(exists_blue ~ macroarea + UV_sd, data = d, control = ctree_control(testtype = c("MonteCarlo"), maxdepth=2));
  plot(ctree_uvbs_ma);
  cm_ctree_uvbs_ma <- confusionMatrix(d$exists_blue, predict(ctree_uvbs_ma,  newdata=d, allow_new_levels=TRUE), positive="yes");
  
  # just UV-B:
  ctree_uvbs <- ctree(exists_blue ~ UV_sd, data = d, control = ctree_control(testtype = c("MonteCarlo")));
  plot(ctree_uvbs);
  cm_ctree_uvbs <- confusionMatrix(d$exists_blue, predict(ctree_uvbs,  newdata=d, allow_new_levels=TRUE), positive="yes");
  
  
  # Save to file:
  shape_uvb__blue_ctree <- list("data"=d, 
                                "mean"=list("with_macroarea"=ctree_uvbm_ma, "no_macroarea"=ctree_uvbm),
                                "sd"  =list("with_macroarea"=ctree_uvbs_ma, "no_macroarea"=ctree_uvbs));
  save(shape_uvb__blue_ctree, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
} 
```

#### Mean UV-B incidence

Because using only mean UV-B is a degenerate model that always predicts "yes", we focus here only on the one that also uses the macroareas:

```{r fig.cap=capFig("Conditional inference trees for predicting 'blue' using macroarea (left) or just mean UV-B (right).", TRUE, c("partykit"), is_map=FALSE), fig.width=8, fig.height=8}
plot(shape_uvb__blue_ctree$mean$with_macroarea, gp=gpar(fontsize = 11));
```

```{r}
print(shape_uvb__blue_ctree$mean$with_macroarea);

cm1 <- confusionMatrix(shape_uvb__blue_ctree$mean$with_macroarea$data$exists_blue, predict(shape_uvb__blue_ctree$mean$with_macroarea), positive="yes");

tmp_all <- data.frame("Predictors" =c("Macroarea and mean UV-B"),
                 "Accuracy"   =sprintf("%.1f%%", 100*c(cm1$overall["Accuracy"])),
                 "Sensitivity"=sprintf("%.1f%%", 100*c(cm1$byClass["Sensitivity"])), 
                 "Specificity"=sprintf("%.1f%%", 100*c(cm1$byClass["Specificity"])),
                 "Precision"  =sprintf("%.1f%%", 100*c(cm1$byClass["Precision"])),
                 "Recall"     =sprintf("%.1f%%", 100*c(cm1$byClass["Recall"])));
kable(tmp_all, row.names=FALSE, align="r",
      caption=capTab("Success (as %) of conditional inference trees with macroarea and mean UV-B."));
```


#### SD UV-B incidence

Because using only sd UV-B is a degenerate model that always predicts "yes", we focus here only on the one that also uses the macroareas:

```{r fig.cap=capFig("Conditional inference trees for predicting 'blue' using macroarea (left) or just sd UV-B (right).", TRUE, c("partykit"), is_map=FALSE), fig.width=8, fig.height=8}
plot(shape_uvb__blue_ctree$sd$with_macroarea, gp=gpar(fontsize = 11));
```

```{r}
print(shape_uvb__blue_ctree$sd$with_macroarea);

cm1 <- confusionMatrix(shape_uvb__blue_ctree$sd$with_macroarea$data$exists_blue, predict(shape_uvb__blue_ctree$sd$with_macroarea), positive="yes");

tmp_all <- data.frame("Predictors" =c("Macroarea and sd UV-B"),
                 "Accuracy"   =sprintf("%.1f%%", 100*c(cm1$overall["Accuracy"])),
                 "Sensitivity"=sprintf("%.1f%%", 100*c(cm1$byClass["Sensitivity"])), 
                 "Specificity"=sprintf("%.1f%%", 100*c(cm1$byClass["Specificity"])),
                 "Precision"  =sprintf("%.1f%%", 100*c(cm1$byClass["Precision"])),
                 "Recall"     =sprintf("%.1f%%", 100*c(cm1$byClass["Recall"])));
kable(tmp_all, row.names=FALSE, align="r",
      caption=capTab("Success (as %) of conditional inference trees with macroarea and mean UV-B."));
```



## Phylogenetic analyses

### Which families to use?

We need families that:

- are large
- show enough variation in 'blue'
- show enough variation in UV-B incidence
- have phylogenetic trees with branch length

```{r}
#compute Shannon entropy (from https://rpubs.com/philjet/shannonentropy):
entropy <- function(target)
{
  freq <- table(target)/length(target)
  # vectorize
  vec <- as.data.frame(freq)[,2]
  #drop 0 to avoid NaN resulting from log2
  vec<-vec[vec>0]
  #compute entropy
  abs(-sum(vec * log2(vec))) # avoid -0
}
```

```{r}
# Summarize the relevant info per family:
min_n_lgs_per_fam <- 10;
fams_summary <- d_colors_ag %>% 
  filter(!is.na(glottocode) & !is.na(exists_blue) & !is.na(UV_mean) & !is.na(UV_sd) & !is.na(latitude)) %>%
  group_by(glottocode_family) %>%
  summarise("n.langs"=n(), 
            "blue.perc"=sum(exists_blue == "yes")/n(), 
            "blue.h"   =entropy(exists_blue), 
            "uvbm.range"=(max(UV_mean,na.rm=TRUE) - min(UV_mean,na.rm=TRUE)),
            "uvbm.sd"   =sd(UV_mean,na.rm=TRUE),
            "uvbm.iqr"  =IQR(UV_mean,na.rm=TRUE),
            "uvbs.range"=(max(UV_sd,na.rm=TRUE) - min(UV_sd,na.rm=TRUE)),
            "uvbs.sd"   =sd(UV_sd,na.rm=TRUE),
            "uvbs.iqr"  =IQR(UV_sd,na.rm=TRUE),
            "lat.range"=(max(latitude,na.rm=TRUE) - min(latitude,na.rm=TRUE)),
            "lat.sd"   =sd(latitude,na.rm=TRUE),
            "lat.iqr"  =IQR(latitude,na.rm=TRUE),
            "long.range"=(max(longitude,na.rm=TRUE) - min(longitude,na.rm=TRUE)),
            "long.sd"   =sd(longitude,na.rm=TRUE),
            "long.iqr"  =IQR(longitude,na.rm=TRUE),
            "alt.range"=(max(elevation,na.rm=TRUE) - min(elevation,na.rm=TRUE)),
            "alt.sd"   =sd(elevation,na.rm=TRUE),
            "alt.iqr"  =IQR(elevation,na.rm=TRUE),
            "hg.perc"=sum(subsistence == "HG", na.rm=TRUE)/sum(!is.na(subsistence)), 
            "hg.h"   =entropy(subsistence), 
            "psiz.range"=(max(log_popSize_ethno,na.rm=TRUE) - min(log_popSize_ethno,na.rm=TRUE)),
            "psiz.sd"   =sd(log_popSize_ethno,na.rm=TRUE),
            "psiz.iqr"  =IQR(log_popSize_ethno,na.rm=TRUE)) %>%
  filter(n.langs >= min_n_lgs_per_fam);

# Load the Glottolog data:
d_glottolog <- read.table("./input_files/glottolog/languoid.csv", sep=",", quote='"', header=TRUE, stringsAsFactors=FALSE);

# Add the family names:
fams_summary <- merge(fams_summary, d_glottolog[ d_glottolog$id %in% fams_summary$glottocode_family & d_glottolog$level == "family", c("id", "name") ], by.x="glottocode_family", by.y="id", all.x=TRUE, all.y=FALSE);

# Show them:
knitr::kable(data.frame("family"=paste0(fams_summary$name, " (", fams_summary$glottocode_family, ")"),
                  "n.langs"=fams_summary$n.langs,
                  "blue.perc"=sprintf("%.1f%%", 100*fams_summary$blue.perc),
                  "blue.h"=sprintf("%.2f", fams_summary$blue.h),
                  "uvbm"=sprintf("%.1f (%.1f; %.1f)", fams_summary$uvbm.range, fams_summary$uvbm.sd, fams_summary$uvbm.iqr),
                  "uvbs"=sprintf("%.1f (%.1f; %.1f)", fams_summary$uvbs.range, fams_summary$uvbs.sd, fams_summary$uvbs.iqr),
                  "lat"=sprintf("%.1f (%.1f; %.1f)", fams_summary$lat.range, fams_summary$lat.sd, fams_summary$lat.iqr),
                  "long"=sprintf("%.1f (%.1f; %.1f)", fams_summary$long.range, fams_summary$long.sd, fams_summary$long.iqr),
                  "alt"=sprintf("%.1f (%.1f; %.1f)", fams_summary$alt.range, fams_summary$alt.sd, fams_summary$alt.iqr),
                  "psiz"=sprintf("%.1f (%.1f; %.1f)", fams_summary$psiz.range, fams_summary$psiz.sd, fams_summary$psiz.iqr),
                  "hg.perc"=sprintf("%.1f%%", 100*fams_summary$hg.perc),
                  "hg.h"=sprintf("%.2f", fams_summary$hg.h)),
            row.names=FALSE,
            col.names=c("Family (glottocode)", "# lgs", "% lgs with 'blue'", "H('blue')", "Mean UVB", "SD UVB", "Latitude", "Longitude", "Altitude", "Log (pop. size)", "% HG lgs", "H(HG)"),
            align="r",
            caption=capTab(paste0("Summaries of the language families with at least ",min_n_lgs_per_fam," languages, showing the number of languages, the percent of languages and the Shannon entropy H, with a dedicated word for 'blue', the ranges (and standard deviations; IQR) of mean and standard devaition of UV-B incidence (from TOMS), latitude and longitude, altitude, population size, and the percept of languages and the Shannon entropy H, that are spoken by hunter-gatherers. The variables are in their raw form (i.e., not *z*-scored), but population size is log'ed.")));
```

They all look promising, so let' see which ones have actual phylogenies available...

```{r include=FALSE}
library(stringr);
library(ape);

# Check the tree (from ape::plot.phylo()):
.check.phylo <- function(tree, verbose=FALSE)
{
  Nedge <- dim(tree$edge)[1];
  Nnode <- tree$Nnode;
  Ntip <- length(tree$tip.label);
  if( Ntip < 2 ) 
  {
    if(verbose) warning("Less than 2 tips in the tree");
    return (FALSE);
  }        
  if( any(tree$edge < 1) || any(tree$edge > Ntip + Nnode) )
  {
    if(verbose) warning("Tree badly conformed");
    return (FALSE);
  }
  return (TRUE); # all seems ok
}


file_name <- "./cached_results/phylo_blue.RData";
if( !all(file.exists(file_name)) )
{
  #devtools::install_github("erichround/glottoTrees", dependencies=TRUE, INSTALL_opts=c("--no-multiarch"), force=TRUE);
  library(glottoTrees); # we use Glottolog 4.6 throughout
  library(castor);
  
  trees <- list();
  
  ## 1. The Glottolog trees:
  
  # Read and process Glottolog newick trees:
  .read.glottolog.newick <- function(fam_name, 
                                     lgs_to_keep=d_colors_ag$glottocode[ !is.na(d_colors_ag$glottocode) & !is.na(d_colors_ag$exists_blue) & !is.na(d_colors_ag$UV_mean) & !is.na(d_colors_ag$UV_sd) & !is.na(d_colors_ag$latitude) ],
                                     ignore.nodes=NULL)
  {
    # Read the tree:
    #tree <- ape::read.tree(file_path);
    tree <- glottoTrees::get_glottolog_trees(family=fam_name, glottolog_version="4.6");
    if( is.null(tree) || !inherits(tree, "phylo") )
    {
      warning(paste0("Could not read Glottolog newick tree '",file_path,"'!"))
      return  (NULL);
    }
    
    tree <- glottoTrees::abridge_labels(tree); # use the glottocodes only
    
    was.tree.rooted <- is.rooted(tree);
    
    tree <- drop.tip(tree, which(is.na(tree$tip.label)), trim.internal=TRUE); # drop NA tips (if any)
    
    tree <- glottoTrees::keep_as_tip(tree, intersect(setdiff(c(tree$tip.label, tree$node.label), ignore.nodes), lgs_to_keep)); # keep only the languages for which we have info
    
    if( was.tree.rooted && !is.rooted(tree) && !is.null(castor::find_root(tree)) && !is.na(castor::find_root(tree)) )
    {
      # Root seems to have been lost in the process: re-root it:
      tree <- castor::root_at_node(tree, castor::find_root(tree), update_indices=TRUE);
    }
    
    if( has.singles(tree) ) tree <- collapse.singles(tree, root.edge=TRUE);
    
    tree$edge.length[ tree$edge.length <= 0.0 ] <- min(tree$edge.length[ tree$edge.length > 0.0 ], na.rm=TRUE) / 10.0; # make sure there are no 0-length branches

    # Return the trees:
    return (list("original"=tree,
                 "exponential"=glottoTrees::rescale_branches_exp(tree),
                 "ultrametric"=glottoTrees::ultrametricize(tree)));
  }
  
  # Afro-Asiatic:
  tree <- (trees$afro_asiatic$glottolog <- .read.glottolog.newick("Afro-Asiatic"))$original; 
  glcode <- "afro1255";
  cat(paste0("Included as tips: ", paste0(s3 <- intersect(tree$tip.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; as internal nodes: ", paste0(s3 <- intersect(tree$node.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; NOT included: ", paste0(s3 <- setdiff(d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ], c(tree$tip.label, tree$node.label)), collapse=", "), " (", length(s3), ")","\n"));
  
  # Atlantic-Congo:
  tree <- (trees$atlantic_congo$glottolog <- .read.glottolog.newick("Atlantic-Congo"))$original; 
  glcode <- "atla1278";
  cat(paste0("Included as tips: ", paste0(s3 <- intersect(tree$tip.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; as internal nodes: ", paste0(s3 <- intersect(tree$node.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; NOT included: ", paste0(s3 <- setdiff(d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ], c(tree$tip.label, tree$node.label)), collapse=", "), " (", length(s3), ")","\n"));
  
  # Austroasiatic:
  tree <- (trees$austroasiatic$glottolog <- .read.glottolog.newick("Austroasiatic"))$original; 
  glcode <- "aust1305";
  cat(paste0("Included as tips: ", paste0(s3 <- intersect(tree$tip.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; as internal nodes: ", paste0(s3 <- intersect(tree$node.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; NOT included: ", paste0(s3 <- setdiff(d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ], c(tree$tip.label, tree$node.label)), collapse=", "), " (", length(s3), ")","\n"));
  
  # Austronesian:
  tree <- (trees$austronesian$glottolog <- .read.glottolog.newick("Austronesian", 
                                                                  ignore.nodes=c("ciac1237", "panc1247", "nage1237", "ngad1267", "sika1262")))$original; # conflicts between ciac1237 and kaes1237, panc1247 and kale1247, nage1237 and cent2355, ngad1267 and rong1269, sika1262 and tana1283
  glcode <- "aust1307";
  cat(paste0("Included as tips: ", paste0(s3 <- intersect(tree$tip.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; as internal nodes: ", paste0(s3 <- intersect(tree$node.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; NOT included: ", paste0(s3 <- setdiff(d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ], c(tree$tip.label, tree$node.label)), collapse=", "), " (", length(s3), ")","\n"));
  
  # Hmong-Mien:
  tree <- (trees$hmong_mien$glottolog <- .read.glottolog.newick("Hmong-Mien"))$original; 
  glcode <- "hmon1336";
  cat(paste0("Included as tips: ", paste0(s3 <- intersect(tree$tip.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; as internal nodes: ", paste0(s3 <- intersect(tree$node.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; NOT included: ", paste0(s3 <- setdiff(d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ], c(tree$tip.label, tree$node.label)), collapse=", "), " (", length(s3), ")","\n"));
  
  # Indo-European:
  tree <- (trees$indo_european$glottolog <- .read.glottolog.newick("Indo-European", 
                                                                   ignore.nodes=c("indo1319", "sout1528", "alba1267", "east1436", "kurd1259", "osse1243")))$original; # indo1319 is the whole thing; conflicts between sout1528 and croa1245, alba1267 and tosk1239, east1436 and nepa1254, kurd1259 and nort2641, osse1243 and iron1242
  glcode <- "indo1319";
  cat(paste0("Included as tips: ", paste0(s3 <- intersect(tree$tip.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; as internal nodes: ", paste0(s3 <- intersect(tree$node.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; NOT included: ", paste0(s3 <- setdiff(d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ], c(tree$tip.label, tree$node.label)), collapse=", "), " (", length(s3), ")","\n"));
  
  # Nakh-Daghestanian:
  tree <- (trees$nakh_daghestanian$glottolog <- .read.glottolog.newick("Nakh-Daghestanian", 
                                                                       ignore.nodes=c("kara1474")))$original; # conflicts between kara1474 and toki1238
  glcode <- "nakh1245";
  cat(paste0("Included as tips: ", paste0(s3 <- intersect(tree$tip.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; as internal nodes: ", paste0(s3 <- intersect(tree$node.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; NOT included: ", paste0(s3 <- setdiff(d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ], c(tree$tip.label, tree$node.label)), collapse=", "), " (", length(s3), ")","\n"));
  
  # Pama-Nyungan:
  tree <- (trees$pama_nyungan$glottolog <- .read.glottolog.newick("Pama-Nyungan",
                                                                  ignore.nodes=c("yuul1239")))$original; # conflicts between yuul1239 and yann1237 
  glcode <- "pama1250";
  cat(paste0("Included as tips: ", paste0(s3 <- intersect(tree$tip.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; as internal nodes: ", paste0(s3 <- intersect(tree$node.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; NOT included: ", paste0(s3 <- setdiff(d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ], c(tree$tip.label, tree$node.label)), collapse=", "), " (", length(s3), ")","\n"));
  
  # Pano-Tacanan:
  tree <- (trees$pano_tacanan$glottolog <- .read.glottolog.newick("Pano-Tacanan"))$original; 
  glcode <- "pano1259";
  cat(paste0("Included as tips: ", paste0(s3 <- intersect(tree$tip.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; as internal nodes: ", paste0(s3 <- intersect(tree$node.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; NOT included: ", paste0(s3 <- setdiff(d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ], c(tree$tip.label, tree$node.label)), collapse=", "), " (", length(s3), ")","\n"));
  
  # Sino-Tibetan:
  tree <- (trees$sino_tibetan$glottolog <- .read.glottolog.newick("Sino-Tibetan",
                                                                  ignore.nodes=c("nucl1310", "sich1238", "situ1238", "jing1260")))$original; # conflicts between nucl1310 and mand1476, sich1238 and yish1238, situ1238 and lixi1238, jing1260 and kach1280
  glcode <- "sino1245";
  cat(paste0("Included as tips: ", paste0(s3 <- intersect(tree$tip.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; as internal nodes: ", paste0(s3 <- intersect(tree$node.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; NOT included: ", paste0(s3 <- setdiff(d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ], c(tree$tip.label, tree$node.label)), collapse=", "), " (", length(s3), ")","\n"));
  
  # Tai-Kadai:
  tree <- (trees$tai_kadai$glottolog <- .read.glottolog.newick("Tai-Kadai"))$original; 
  glcode <- "taik1256";
  cat(paste0("Included as tips: ", paste0(s3 <- intersect(tree$tip.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; as internal nodes: ", paste0(s3 <- intersect(tree$node.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; NOT included: ", paste0(s3 <- setdiff(d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ], c(tree$tip.label, tree$node.label)), collapse=", "), " (", length(s3), ")","\n"));
  
  # Timor-Alor-Pantar:
  tree <- (trees$timor_alor_pantar$glottolog <- .read.glottolog.newick("Timor-Alor-Pantar",
                                                                       ignore.nodes=c("kuii1253", "blag1240", "teiw1235")))$original; # conflicts between kuii1253 and kira1248, blag1240 and baka1276, teiw1235 and dein1238
  glcode <- "timo1261";
  cat(paste0("Included as tips: ", paste0(s3 <- intersect(tree$tip.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; as internal nodes: ", paste0(s3 <- intersect(tree$node.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; NOT included: ", paste0(s3 <- setdiff(d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ], c(tree$tip.label, tree$node.label)), collapse=", "), " (", length(s3), ")","\n"));
  
  # Turkic:
  tree <- (trees$turkic$glottolog <- .read.glottolog.newick("Turkic"))$original; 
  glcode <- "turk1311";
  cat(paste0("Included as tips: ", paste0(s3 <- intersect(tree$tip.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; as internal nodes: ", paste0(s3 <- intersect(tree$node.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; NOT included: ", paste0(s3 <- setdiff(d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ], c(tree$tip.label, tree$node.label)), collapse=", "), " (", length(s3), ")","\n"));
  
  # Uralic:
  tree <- (trees$uralic$glottolog <- .read.glottolog.newick("Uralic",
                                                            ignore.nodes=c("mari1278")))$original; # conflicts between mari1278 and east2328 
  glcode <- "ural1272";
  cat(paste0("Included as tips: ", paste0(s3 <- intersect(tree$tip.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; as internal nodes: ", paste0(s3 <- intersect(tree$node.label, d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ]), collapse=", "), " (", length(s3), ")", "; NOT included: ", paste0(s3 <- setdiff(d_colors_ag$glottocode[ d_colors_ag$glottocode_family == glcode ], c(tree$tip.label, tree$node.label)), collapse=", "), " (", length(s3), ")","\n"));
  
  
  ## 2. Bayesian trees from other sources:
  # Read and process Glottolog newick trees:
  .read.mcmc.trees <- function(fam_path, n_posterior_trees=NA, # how many posterior tress to keep (NA=all)
                               lgs_to_keep=d_colors_ag$glottocode[ !is.na(d_colors_ag$glottocode) & !is.na(d_colors_ag$exists_blue) & !is.na(d_colors_ag$UV_mean) & !is.na(d_colors_ag$UV_sd) & !is.na(d_colors_ag$latitude) ])
  {
    # Read the language mappings:
    lgm <- read.csv(paste0(fam_path, "taxa.csv"));
    
    # Read and process the summary tree:
    trs <- NULL;
    if( file.exists(paste0(fam_path, "summary.trees")) )
    {
      trs <- read.nexus(paste0(fam_path, "summary.trees"));
      if( .check.phylo(trs) )
      {
        trs$tip.label <- vapply(trs$tip.label, function(s) if( s %in% lgm$taxon ) lgm$glottocode[ lgm$taxon == s ] else NA_character_, character(1)); names(trs$tip.label) <- NULL;
        trs <- drop.tip(trs, which(!(trs$tip.label %in% lgs_to_keep)), trim.internal=TRUE);
        dup.tips <- duplicated(trs$tip.label); # duplicated tips
        trs <- drop.tip(trs, which(dup.tips), trim.internal=TRUE); # drop them and keep the first occurrence
        if( has.singles(trs) ) trs <- collapse.singles(trs, root.edge=TRUE);
        trs$edge.length[ trs$edge.length <= 0.0 ] <- min(trs$edge.length[ trs$edge.length > 0.0 ], na.rm=TRUE) / 10.0; # make sure there are no 0-length branches
      } else
      {
        trs <- NULL;
      }
    }
    
    # Read and process the posterior trees:
    trp <- NULL;
    if( file.exists(paste0(fam_path, "posterior.trees")) )
    {
      trp <- read.nexus(paste0(fam_path, "posterior.trees"));
      if( !is.na(n_posterior_trees) && is.numeric(n_posterior_trees) && n_posterior_trees > 0 && n_posterior_trees < length(trp) )
      {
        # Keep a random sample of posterior trees:
        trp_idx <- sample(length(trp), n_posterior_trees, replace=FALSE);
      } else
      {
        # Keep all the trees:
        trp_idx <- 1:length(trp);
      }
      trp <- lapply(trp_idx, function(i)
      {
        tripi <- trp[[i]];
        if( .check.phylo(tripi) )
        {
          tripi$tip.label <- vapply(tripi$tip.label, function(s) if( s %in% lgm$taxon ) lgm$glottocode[ lgm$taxon == s ] else NA_character_, character(1)); names(tripi$tip.label) <- NULL;
          tripi <- drop.tip(tripi, which(!(tripi$tip.label %in% lgs_to_keep)), trim.internal=TRUE);
          dup.tips <- duplicated(tripi$tip.label); # duplicated tips
          tripi <- drop.tip(tripi, which(dup.tips), trim.internal=TRUE); # drop them and keep the first occurrence
          if( has.singles(tripi) ) tripi <- collapse.singles(tripi, root.edge=TRUE);
          tripi$edge.length[ tripi$edge.length <= 0.0 ] <- min(tripi$edge.length[ tripi$edge.length > 0.0 ], na.rm=TRUE) / 10.0; # make sure there are no 0-length branches
        } else
        {
          tripi <- NULL;
        }
        return (tripi);
      });
      class(trp) <- "multiPhylo";
    }
    
    # Return the trees:
    return (list("summary"=trs,
                 "posterior"=trp));
  }
  
  # Austronesian:
  trees$austronesian$mcmc <- .read.mcmc.trees("./input_files/phylogenies/Austronesian/Gray_etal_2009/");
  
  # Bantu:
  trees$bantu$mcmc <- .read.mcmc.trees("./input_files/phylogenies/Bantu/Grollemund_etal_2015/");
  
  # Indo-European:
  trees$indo_european$mcmc <- .read.mcmc.trees("./input_files/phylogenies/Indo-European/Chang_etal_2015/");
  
  # Pama-Nyungan:
  trees$pama_nyungan$mcmc <- .read.mcmc.trees("./input_files/phylogenies/Pama-Nyungan/Bouckaert_etal_2018/");
  
  # Turkic:
  trees$turkic$mcmc <- .read.mcmc.trees("./input_files/phylogenies/Turkic/Hruschka_etal_2015/");
  
  # Uralic:
  trees$uralic$mcmc <- .read.mcmc.trees("./input_files/phylogenies/Uralic/Honkola_etal_2013/");
  
  
  ## 3. Gerhard Jäger (2018)'s frequentist trees based on ASJP 17:
  
  # Unpack, read and delete the ASJP language metadata:
  if( !file.exists("./input_files/phylogenies/Jaeger_2018/asjp-v17.zip") )
  {
    # try to download it:
    download.file("https://zenodo.org/record/3835942/files/lexibank/asjp-v17.zip?download=1", "./input_files/phylogenies/Jaeger_2018/asjp-v17.zip");
    if( !file.exists("./input_files/phylogenies/Jaeger_2018/asjp-v17.zip") ) stop("Error retrieveing the ASJP-17 data!");
  }
  unzip("./input_files/phylogenies/Jaeger_2018/asjp-v17.zip", exdir="./input_files/phylogenies/Jaeger_2018/");
  asjp_lgs <- read.table("./input_files/phylogenies/Jaeger_2018/lexibank-asjp-5114ccc/cldf/languages.csv", header=TRUE, sep=",", quote='"');
  asjp_lgs$Name2 <- toupper(str_replace_all(asjp_lgs$Name, fixed("-"), "_")); # - seem systematically replaced by "_" in Gerhard's trees
  asjp_lgs <- rbind(asjp_lgs, asjp_lgs[ asjp_lgs$Name2 == "WEMBAWEMBA", ]); asjp_lgs$Name2[ nrow(asjp_lgs) ] <- "WEMBA_WEMBA"; # in Gerhard's trees it appears also as WEMBA_WEMBA
  unlink("./input_files/phylogenies/Jaeger_2018/lexibank-asjp-5114ccc", recursive=TRUE);
  
  # Unpack, read and delete Gerhard's trees:
  if( !file.exists("./input_files/phylogenies/Jaeger_2018/trees.zip") )
  {
    stop("Please download the 'trees' subfolder of the https://osf.io/cufv7/ OSF repository ( DOI 10.17605/OSF.IO/CUFV7) as ZIP file!");
  }
  unzip("./input_files/phylogenies/Jaeger_2018/trees.zip", exdir="./input_files/phylogenies/Jaeger_2018/trees/");

  # Read and process Gerhard's trees:
  .read.gerhard.tree <- function(tree_name, 
                                 lgs_to_keep=d_colors_ag$glottocode[ !is.na(d_colors_ag$glottocode) & !is.na(d_colors_ag$exists_blue) & !is.na(d_colors_ag$UV_mean) & !is.na(d_colors_ag$UV_sd) & !is.na(d_colors_ag$latitude) ])
  {
    # Read the tree:
    if( !file.exists(paste0("./input_files/phylogenies/Jaeger_2018/trees/",tree_name,".tre")) ) 
    {
      warning(paste0("Tree for '",tree_name,"' was not found!"));
      return (NULL);
    }
    tree <- read.tree(paste0("./input_files/phylogenies/Jaeger_2018/trees/",tree_name,".tre"));
    if( is.null(tree) ) return (NULL);
    
    # Map the tips to Glottolog codes:
    tree$tip.label <- vapply(tree$tip.label, function(s)
    {
      s.asjp <- toupper(strsplit(s,".",fixed=TRUE)[[1]][3]);
      if( is.null(s.asjp) || is.na(s.asjp) ){ warning(paste0("No ASJP name can be extracted from language '",s,"'.")); return (NA_character_); }
      s.glottolog <- unique(asjp_lgs$Glottocode[ asjp_lgs$Name2 == s.asjp ]);
      if( length(s.glottolog) == 0 ){ warning(paste0("No match found in the ASJP database for language '",s,"'.")); return (NA_character_); }
      if( length(s.glottolog) > 1 ){ warning(paste0("More than one matching Glottolog code found in the ASJP database for language '",s,"': ",paste0(s.glottolog,collapse=", ")," -- picking the first one.")); return (s.glottolog[1]); }
      return (s.glottolog);
    }, character(1));
    
    # Trim the tree to the available data:
    if( !.check.phylo(tree) )
    {
      warning(paste0("The tree for  '",tree_name,"' has well-fromedness issues."));
      return (NULL);
    }
    
    lgs_to_keep <- d_colors_ag$glottocode[ !is.na(d_colors_ag$glottocode) & !is.na(d_colors_ag$exists_blue) & !is.na(d_colors_ag$UV_mean) & !is.na(d_colors_ag$UV_sd) & !is.na(d_colors_ag$latitude) ];
    tree <- drop.tip(tree, which(!(tree$tip.label %in% lgs_to_keep)), trim.internal=TRUE);
    if( is.null(tree) ){ warning(paste0("The tree for  '",tree_name,"' is has no data in our database.")); return (NULL); }
    dup.tips <- duplicated(tree$tip.label); # duplicated tips
    tree <- drop.tip(tree, which(dup.tips), trim.internal=TRUE); # drop them and keep the first occurrence
    if( length(tree$tip.label) == 1 ){ warning(paste0("The tree for  '",tree_name,"' is degenerate when intersected with our database.")); return (NULL); }
    if( has.singles(tree) ) tree <- collapse.singles(tree, root.edge=TRUE);
    tree$edge.length[ tree$edge.length <= 0.0 ] <- min(tree$edge.length[ tree$edge.length > 0.0 ], na.rm=TRUE) / 10.0; # make sure there are no 0-length branches
    
    if( length(tree$tip.label) < min_n_lgs_per_fam )
    {
      warning(paste0("The tree for  '",tree_name,"' has less than ",min_n_lgs_per_fam," languages: dropping it."));
      return (NULL);
    }
    
    return (tree);
  }

  # Try to load Gerhard's trees:
  tree_names <- list.files("./input_files/phylogenies/Jaeger_2018/trees/", pattern=glob2rx("*.tre"), all.files=TRUE, full.names=FALSE, recursive=FALSE, include.dirs=FALSE);
  for( tree_name in tree_names )
  {
    fam_name <- substring(tree_name, 1, nchar(tree_name)-4);
    fam_name2 <- tolower(str_replace_all(fam_name, fixed("-"),  "_"));
    if( !is.null(tree <- .read.gerhard.tree(fam_name)) )
    {
      cat(paste0("Successfully loaded Gerhard Jäger's tree '",fam_name,"' (as '",fam_name2,"')...\n"));
      if( fam_name2 %in% names(trees) )
      {
        trees[[fam_name2]]$gerhard <- tree;
      } else
      {
        trees[[length(trees)+1]] <- list();
        trees[[length(trees)]]$gerhard <- tree;
        names(trees)[length(trees)] <- fam_name2;
      }
    }
  }
  
  # Delete the temporary folder and files:
  unlink("./input_files/phylogenies/Jaeger_2018/trees", recursive=TRUE);
  
  
  ## 4. Sino-Tibetan Maximum Clade Credibility (MCC) tree from Zhang et al. (2019):
  
  # Load the language names mapping to Glottolog codes:
  lgs_to_glottolog <- read.table("./input_files/phylogenies/Sino-Tibetan/Zhang_etal_2019/map_lgs_glottocode.csv", header=TRUE, sep="\t", quote='"', na.strings="");
  # Load the tree:
  if( !file.exists("./input_files/phylogenies/Sino-Tibetan/Zhang_etal_2019/41586_2019_1153_MOESM4_ESM.zip") ) 
  {
    # try to download it:
    download.file("https://static-content.springer.com/esm/art%3A10.1038%2Fs41586-019-1153-z/MediaObjects/41586_2019_1153_MOESM4_ESM.zip", "./input_files/phylogenies/Sino-Tibetan/Zhang_etal_2019/41586_2019_1153_MOESM4_ESM.zip");
    if( !file.exists("./input_files/phylogenies/Sino-Tibetan/Zhang_etal_2019/41586_2019_1153_MOESM4_ESM.zip") ) warning("Please download the Supplementary Data 1 of the Zhang et al. (2019) paper from https://www.nature.com/articles/s41586-019-1153-z");
  }
  if( file.exists("./input_files/phylogenies/Sino-Tibetan/Zhang_etal_2019/41586_2019_1153_MOESM4_ESM.zip") ) 
  {
    unzip("./input_files/phylogenies/Sino-Tibetan/Zhang_etal_2019/41586_2019_1153_MOESM4_ESM.zip", exdir="./input_files/phylogenies/Sino-Tibetan/Zhang_etal_2019/SD1");
    st_tree <- read.nexus("./input_files/phylogenies/Sino-Tibetan/Zhang_etal_2019/SD1/109SinoTibetanLanguages.MCC.tree");
    if( is.null(st_tree) )
    {
      warning("Issues reading the Sino-Tibetan tree of Zhang et al. (2019).");
    } else
    {
      # Map the tips to Glottolog codes:
      st_tree$tip.label <- vapply(st_tree$tip.label, function(s)
      {
        s.idx <- unique(lgs_to_glottolog$glottocde[ lgs_to_glottolog$name == s ]);
        if( length(s.idx) == 0 ){ warning(paste0("Could not find the glottcode for language '",s,"'.")); return (NA_character_); }
        if( length(s.idx) > 1 ){ warning(paste0("The are several glottcodes for language '",s,"': ",paste0(s.idx, collapse=", ")," - picking the first one.")); return (s.idx[1]); }
        return (s.idx);
      }, character(1));
      
      # Trim the tree to the available data:
      if( !.check.phylo(st_tree) )
      {
        warning(paste0("The tree for Sino-Tibetan of Zhang et al. (2019) has well-fromedness issues."));
        return (NULL);
      }
      
      lgs_to_keep=d_colors_ag$glottocode[ !is.na(d_colors_ag$glottocode) & !is.na(d_colors_ag$exists_blue) & !is.na(d_colors_ag$UV_mean) & !is.na(d_colors_ag$UV_sd) & !is.na(d_colors_ag$latitude) ];
      st_tree <- drop.tip(st_tree, which(!(st_tree$tip.label %in% lgs_to_keep)), trim.internal=TRUE);
      if( is.null(st_tree) ){ warning(paste0("The tree for Sino-Tibetan of Zhang et al. (2019) is has no data in our database.")); st_tree <- NULL; }
      dup.tips <- duplicated(st_tree$tip.label); # duplicated tips
      st_tree <- drop.tip(st_tree, which(dup.tips), trim.internal=TRUE); # drop them and keep the first occurrence
      if( length(st_tree$tip.label) == 1 ){ warning(paste0("The tree for Sino-Tibetan of Zhang et al. (2019) is degenrate when intersected with our database.")); st_tree <- NULL; }
      if( has.singles(st_tree) ) st_tree <- collapse.singles(st_tree, root.edge=TRUE);
      st_tree$edge.length[ st_tree$edge.length <= 0.0 ] <- min(st_tree$edge.length[ st_tree$edge.length > 0.0 ], na.rm=TRUE) / 10.0; # make sure there are no 0-length branches
      
      if( length(st_tree$tip.label) < min_n_lgs_per_fam )
      {
        warning(paste0("The tree for Sino-Tibetan of Zhang et al. (2019) has less than ",min_n_lgs_per_fam," languages: dropping it."));
        st_tree <- NULL;
      }
      # Delete the temporary folder and files:
      unlink("./input_files/phylogenies/Sino-Tibetan/Zhang_etal_2019/SD1/", recursive=TRUE);
      
      if( !is.null(st_tree) )
      {
        # Store it:
        trees$sino_tibetan$zhang <- st_tree;
      }
    }
  }
  
  
  ## 5. The MCC global phylogeny from Bouckaert et al. (2022):
  b22_tree <- NULL;
  if( !file.exists("./input_files/phylogenies/Bouckaert_etal_2022/global-language-tree-MCC-labelled.tree.gz") ) 
  {
    # try to download it:
    download.file("https://github.com/rbouckaert/global-language-tree-pipeline/releases/download/v1.0.0/global-language-tree-MCC-labelled.tree.gz", "./input_files/phylogenies/Bouckaert_etal_2022/global-language-tree-MCC-labelled.tree.gz");
    if( !file.exists("./input_files/phylogenies/Bouckaert_etal_2022/global-language-tree-MCC-labelled.tree.gz") ) warning("Please download the MCC global phylogeny 'global-language-tree-MCC-labelled.tree.gz' from https://github.com/rbouckaert/global-language-tree-pipeline/releases/ (Release 1.0.0, Jul 10, 2022)");
  }
  if( file.exists("./input_files/phylogenies/Bouckaert_etal_2022/global-language-tree-MCC-labelled.tree.gz") ) 
  {
    b22_tree <- read.nexus(gzfile("./input_files/phylogenies/Bouckaert_etal_2022/global-language-tree-MCC-labelled.tree.gz"));
    if( is.null(b22_tree) )
    {
      warning("Issues reading the global tree of Bouckaert et al. (2022).");
    } else
    {
      b22_tree$tip.label <- vapply(b22_tree$tip.label, function(s) substring(s,1,8), character(1)); # keep just the glottocode for the tips
      
      # Trim the tree to the available data:
      if( !.check.phylo(b22_tree) )
      {
        warning(paste0("The global tree of Bouckaert et al. (2022) has well-fromedness issues."));
        return (NULL);
      }
      
      lgs_to_keep=d_colors_ag$glottocode[ !is.na(d_colors_ag$glottocode) & !is.na(d_colors_ag$exists_blue) & !is.na(d_colors_ag$UV_mean) & !is.na(d_colors_ag$UV_sd) & !is.na(d_colors_ag$latitude) ];
      b22_tree <- drop.tip(b22_tree, which(!(b22_tree$tip.label %in% lgs_to_keep)), trim.internal=TRUE);
      if( is.null(b22_tree) ){ warning(paste0("The global tree of Bouckaert et al. (2022) is has no data in our database.")); b22_tree <- NULL; }
      dup.tips <- duplicated(b22_tree$tip.label); # duplicated tips
      b22_tree <- drop.tip(b22_tree, which(dup.tips), trim.internal=TRUE); # drop them and keep the first occurrence
      if( length(b22_tree$tip.label) == 1 ){ warning(paste0("The global tree of Bouckaert et al. (2022) is degenrate when intersected with our database.")); b22_tree <- NULL; }
      if( has.singles(b22_tree) ) b22_tree <- collapse.singles(b22_tree, root.edge=TRUE);
      b22_tree$edge.length[ b22_tree$edge.length <= 0.0 ] <- min(b22_tree$edge.length[ b22_tree$edge.length > 0.0 ], na.rm=TRUE) / 10.0; # make sure there are no 0-length branches
      
      if( length(b22_tree$tip.label) < min_n_lgs_per_fam )
      {
        warning(paste0("The tree for Sino-Tibetan of Zhang et al. (2019) has less than ",min_n_lgs_per_fam," languages: dropping it."));
        b22_tree <- NULL;
      }

      if( !is.null(b22_tree) )
      {
        # Store it:
        trees$world$betal22 <- b22_tree;
      }
    }
  } else
  {
    warning("Issues reading the global tree of Bouckaert et al. (2022).");
  }

  
  # Finally, assemble the various results and save them:
  save(trees, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
} 
```

Sources for the trees:

- the *Glottolog* trees where accessed and post-processed using the [`glottoTrees` package](https://github.com/erichround/glottoTrees) [@MacklinCordesRound2022], 
- the Bayesian MCMC trees were accessed through [D-PLACE](https://d-place.org/) [@kirby_dplace_2016] (please note that for Bantu and Turkik we had to manually fix the format of the file containing the posterior sample to make it readable in `R`),
- @jagerGlobalscalePhylogeneticLinguistic2018's trees were retrieved from the publications' Supplementary Information on [OSF DOI:10.17605/OSF.IO/CUFV7](https://osf.io/cufv7/) (we also needed the ASJP-v17 data to retrieve the Glottlog codes, which we downloaded from [Zenodo DOI:10.5281/zenodo.3835942](https://doi.org/10.5281/zenodo.3835942)),
- the Maximum Clade Credibility (MCC) tree for Sino-Tibetan from @zhangPhylogeneticEvidenceSinoTibetan2019a was retrieved from the paper's [Supplementary Data 1](https://static-content.springer.com/esm/art%3A10.1038%2Fs41586-019-1153-z/MediaObjects/41586_2019_1153_MOESM4_ESM.zip) (the mapping between language names and Glottolog codes was done manually), and
- the Maximum Clade Credibility (MCC) global tree from @bouckaert_global_2022 was retrieved from the [GitHub repository accompanying the pre-print (as of 3 october 2022)](https://github.com/rbouckaert/global-language-tree-pipeline/releases/), in particular the file `global-language-tree-MCC-labelled.tree.gz` (Release 1.0.0 from Jul 10, 2022).

```{r}
# Map a variable to a tree:
.map.data.to.tree <- function(tree, family.name=NA, tree.name=NA, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, rebase.IV=FALSE, plot.legend=TRUE)
{
  if( is.null(tree) || !inherits(tree, "phylo") ){cat(paste0("Tree '",family.name,"' : '",tree.name,"' is empty.\n")); return (NULL);}
  
  # Select and align the data to the tree:
  d <- unique(d_colors_ag[ !is.na(d_colors_ag$exists_blue) & 
                             if( !is.null(show.IV) && !is.na(show.IV) ){ !is.na(d_colors_ag[,show.IV]) }else{ rep(TRUE,nrow(d_colors_ag)) } & 
                             (d_colors_ag$glottocode %in% tree$tip.label), 
                           c("glottocode", "exists_blue", if(!is.null(show.IV) && !is.na(show.IV)){show.IV}else{NULL}) ]);
  d <- d[ !duplicated(d$glottocode), ]; # keep the first of potentially duplicated rows
  d <- as.data.frame(d); # make sure this is a data.frame
  d$exists_blue_num <- as.numeric(d$exists_blue == "yes"); 
  rownames(d) <- d$glottocode;
  d <- d[intersect(d$glottocode, tree$tip.label), ];
  tree <- drop.tip(tree, setdiff(tree$tip.label, d$glottocode), trim.internal=TRUE);
  d <- d[tree$tip.label,]; # make sure the tree and the data are identically ordered
  
  if( is.null(tree) || !inherits(tree, "phylo") || nrow(d) == 0 ){cat(paste0("Tree '",family.name,"' : '",tree.name,"' is empty when intersected with the data.\n")); return (NULL);}
  
  # Plot the tree:
  if( plot.tree )
  {
    require(phytools);
    if( is.null(show.IV) || is.na(show.IV) )
    {
      # Just blue:
      x <- d$exists_blue; names(x) <- d$glottocode;
      dotTree(tree, x, colors=setNames(c("green","blue"), c("no","yes")), ftype="i", fsize=0.7, legend=plot.legend);
    } else
    {
      # Blue and the other IV:
      if( binarize.IV && is.numeric(d[,show.IV]) )
      {
        # Median split:
        d[,show.IV] <- factor(ifelse(d[,show.IV] < median(d[,show.IV], na.rm=TRUE), "below", "above"), levels=c("below", "above"));
      }
      if( is.factor(d[,show.IV]) )
      {
        if( length(levels(d[,show.IV])) == 2 )
        {
          # Both binary
          x <- d[, c("exists_blue", show.IV) ]; rownames(x) <- d$glottocode;
          dotTree(tree, x, colors=setNames(c("green","blue", "yellow", "red"), c("no","yes", levels(d[,show.IV]))), ftype="i", fsize=0.7, legend=plot.legend);
        } else
        {
          warning("IV must be continuous or binary!");
          return (NULL);
        }
      } else
      {
        # Binary and continuous:
        # For some reason, plotTree.barplot doesn't match correctly the bar colors to the tips, so use plotTree.wBars instead: 
        #x <- d[, c("exists_blue", show.IV) ]; rownames(x) <- d$glottocode;
        #plotTree.barplot(tree, x[,show.IV,drop=FALSE], args.barplot=list(col=ifelse(x$exists_blue == "no", "green", "blue")), ftype="i", fsize=0.7);
        if( rebase.IV ) d[, show.IV] <- (d[, show.IV] - min(d[, show.IV], na.rm=TRUE));
        tip.lables <- paste0(d$glottocode, " [", round(d[, show.IV],1), "]"); names(tip.lables) <- d$glottocode;
        d$labels <- rownames(d) <- tip.lables;
        tree$tip.label <- tip.lables[ tree$tip.label ];
        x <- d[, show.IV, drop=TRUE]; names(x) <- d$labels;
        cols <- ifelse(d$exists_blue == "no", "green", "blue"); names(cols) <- d$labels;
        phytools::plotTree.wBars(tree, x, col=cols, tip.labels=TRUE, type="phylogram", ftype="reg", fsize=1.0);
      }
    }
  }
  
  # Return summaries:
  x <- d$exists_blue_num; names(x) <- rownames(d);
  return (list("n.tips"=length(tree$tip.label), "tips.blue"=x, "tips.IV"=if(!is.null(show.IV) && !is.na(show.IV)){d[,show.IV]}else{NULL}));
}
## TESTS:
#.map.data.to.tree(tree=trees$afro_asiatic$glottolog$original, family.name="Afro-Asiatic", tree.name="Glottolog (original)", show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE);
```

#### Afro-Asiatic

***Glottolog***: `r length(trees$afro_asiatic$glottolog$original$tip.label)` languages (tips), with three kinds of branch lengths: "original" (1.0), "exponential" and "ultrametric".

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Afro-Asiatic"),"* : *",(tree.name <- "Glottolog (ultrametric)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$afro_asiatic$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_AA_glottolog";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$afro_asiatic$glottolog$original$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$afro_asiatic$glottolog$original$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$afro_asiatic$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=TRUE)); # show legend just for this one
dev.off();
```

***@jagerGlobalscalePhylogeneticLinguistic2018***: `r length(trees$afro_asiatic$gerhard$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Afro-Asiatic"),"* : *",(tree.name <- "Jäger (2018)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$afro_asiatic$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_AA_j2018";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$afro_asiatic$gerhard$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$afro_asiatic$gerhard$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$afro_asiatic$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### Atlantic-Congo

***Glottolog***: `r length(trees$atlantic_congo$glottolog$original$tip.label)` languages (tips), with three kinds of branch lengths: "original" (1.0), "exponential" and "ultrametric".

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Atlantic-Congo"),"* : *",(tree.name <- "Glottolog (ultrametric)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$atlantic_congo$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_AC_glottolog";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$atlantic_congo$glottolog$original$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$atlantic_congo$glottolog$original$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$atlantic_congo$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

For the ***Bantu*** subfamily, from @grollemund2015: one summary tree with `r length(trees$bantu$mcmc$summary$tip.label)` languages (tips), and `r sum(vapply(trees$bantu$mcmc$posterior, function(x) !is.null(x), logical(1)))` individual posterior trees.

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Bantu"),"* : *",(tree.name <- "MCMC (summary)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$bantu$mcmc$summary, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_AC_g2015";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$bantu$mcmc$summary$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$bantu$mcmc$summary$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$bantu$mcmc$summary, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

***@jagerGlobalscalePhylogeneticLinguistic2018***: `r length(trees$atlantic_congo$gerhard$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Atlantic-Congo"),"* : *",(tree.name <- "Jäger (2018)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$atlantic_congo$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_AC_j2018";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$atlantic_congo$gerhard$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$atlantic_congo$gerhard$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$atlantic_congo$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### Austroasiatic

***Glottolog***: `r length(trees$austroasiatic$glottolog$original$tip.label)` languages (tips), with three kinds of branch lengths: "original" (1.0), "exponential" and "ultrametric".

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Austroasiatic"),"* : *",(tree.name <- "Glottolog (ultrametric)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$austroasiatic$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_AuA_glottolog";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$austroasiatic$glottolog$original$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$austroasiatic$glottolog$original$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$austroasiatic$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

***@jagerGlobalscalePhylogeneticLinguistic2018***: `r length(trees$austroasiatic$gerhard$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Austroasiatic"),"* : *",(tree.name <- "Jäger (2018)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$austroasiatic$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_AuA_j2018";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$austroasiatic$gerhard$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$austroasiatic$gerhard$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$austroasiatic$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### Austronesian

***Glottolog***: `r length(trees$austronesian$glottolog$original$tip.label)` languages (tips), with three kinds of branch lengths: "original" (1.0), "exponential" and "ultrametric".

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Austronesian"),"* : *",(tree.name <- "Glottolog (ultrametric)"),"*?")), fig.height=12, results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$austronesian$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_Aun_glottolog";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$austronesian$glottolog$original$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$austronesian$glottolog$original$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$austronesian$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

From ***@gray2009***: one summary tree with `r length(trees$austronesian$mcmc$summary$tip.label)` languages (tips), and `r sum(vapply(trees$austronesian$mcmc$posterior, function(x) !is.null(x), logical(1)))` individual posterior trees.

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",family.name,"* : *",(tree.name <- "MCMC (summary)"),"*?")), fig.height=10, results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$austronesian$mcmc$summary, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_Aun_g2009";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$austronesian$mcmc$summary$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$austronesian$mcmc$summary$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$austronesian$mcmc$summary, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

***@jagerGlobalscalePhylogeneticLinguistic2018***: `r length(trees$austronesian$gerhard$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Austronesian"),"* : *",(tree.name <- "Jäger (2018)"),"*?")), fig.height=10, results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$austronesian$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_Aun_j2018";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$austronesian$gerhard$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$austronesian$gerhard$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$austronesian$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### Hmong-Mien

***Glottolog***: `r length(trees$hmong_mien$glottolog$original$tip.label)` languages (tips), with three kinds of branch lengths: "original" (1.0), "exponential" and "ultrametric".

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Hmong-Mien"),"* : *",(tree.name <- "Glottolog (ultrametric)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$hmong_mien$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_HM_glottolog";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$hmong_mien$glottolog$original$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$hmong_mien$glottolog$original$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$hmong_mien$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

***@jagerGlobalscalePhylogeneticLinguistic2018***: `r length(trees$hmong_mien$gerhard$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Hmong-Mien"),"* : *",(tree.name <- "Jäger (2018)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$hmong_mien$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_HM_j2018";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$hmong_mien$gerhard$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$hmong_mien$gerhard$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$hmong_mien$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### Indo-European

***Glottolog***: `r length(trees$indo_european$glottolog$original$tip.label)` languages (tips), with three kinds of branch lengths: "original" (1.0), "exponential" and "ultrametric".

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Indo-European"),"* : *",(tree.name <- "Glottolog (ultrametric)"),"*?")), fig.height=10, results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$indo_european$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_IE_glottolog";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$indo_european$glottolog$original$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$indo_european$glottolog$original$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$indo_european$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

From ***@Chang2015***: one summary tree with `r length(trees$indo_european$mcmc$summary$tip.label)` languages (tips), and `r sum(vapply(trees$indo_european$mcmc$posterior, function(x) !is.null(x), logical(1)))` individual posterior trees.

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",family.name,"* : *",(tree.name <- "MCMC (summary)"),"*?")), fig.height=10, results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$indo_european$mcmc$summary, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_IE_c2015g";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$indo_european$mcmc$summary$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$indo_european$mcmc$summary$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$indo_european$mcmc$summary, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

***@jagerGlobalscalePhylogeneticLinguistic2018***: `r length(trees$indo_european$gerhard$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Indo-European"),"* : *",(tree.name <- "Jäger (2018)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$indo_european$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_IE_j2018";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$indo_european$gerhard$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$indo_european$gerhard$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$indo_european$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### Nakh-Daghestanian

***Glottolog***: `r length(trees$nakh_daghestanian$glottolog$original$tip.label)` languages (tips), with three kinds of branch lengths: "original" (1.0), "exponential" and "ultrametric".

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Nakh-Daghestanian"),"* : *",(tree.name <- "Glottolog (ultrametric)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$nakh_daghestanian$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_ND_glottolog";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$nakh_daghestanian$glottolog$original$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$nakh_daghestanian$glottolog$original$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$nakh_daghestanian$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

***@jagerGlobalscalePhylogeneticLinguistic2018***: `r length(trees$nakh_daghestanian$gerhard$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Nakh-Daghestanian"),"* : *",(tree.name <- "Jäger (2018)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$nakh_daghestanian$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_ND_j2018";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$nakh_daghestanian$gerhard$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$nakh_daghestanian$gerhard$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$nakh_daghestanian$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### Pama-Nyungan

***Glottolog***: `r length(trees$pama_nyungan$glottolog$original$tip.label)` languages (tips), with three kinds of branch lengths: "original" (1.0), "exponential" and "ultrametric".

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Pama-Nyungan"),"* : *",(tree.name <- "Glottolog (ultrametric)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$pama_nyungan$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_PN_glottolog";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$pama_nyungan$glottolog$original$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$pama_nyungan$glottolog$original$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$pama_nyungan$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

From ***@Bouckaert2018***: one summary tree with `r length(trees$pama_nyungan$mcmc$summary$tip.label)` languages (tips), and `r sum(vapply(trees$pama_nyungan$mcmc$posterior, function(x) !is.null(x), logical(1)))` individual posterior trees.

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",family.name,"* : *",(tree.name <- "MCMC (summary)"),"*?")), fig.height=10, results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$pama_nyungan$mcmc$summary, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_PN_b2018";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$pama_nyungan$mcmc$summary$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$pama_nyungan$mcmc$summary$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$pama_nyungan$mcmc$summary, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

***@jagerGlobalscalePhylogeneticLinguistic2018***: `r length(trees$pama_nyungan$gerhard$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Pama-Nyungan"),"* : *",(tree.name <- "Jäger (2018)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$pama_nyungan$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_PN_j2018";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$pama_nyungan$gerhard$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$pama_nyungan$gerhard$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$pama_nyungan$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### Pano-Tacanan

***Glottolog***: `r length(trees$pano_tacanan$glottolog$original$tip.label)` languages (tips), with three kinds of branch lengths: "original" (1.0), "exponential" and "ultrametric".

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Pano-Tacanan"),"* : *",(tree.name <- "Glottolog (ultrametric)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$pano_tacanan$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_PT_glottolog";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$pano_tacanan$glottolog$original$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$pano_tacanan$glottolog$original$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$pano_tacanan$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### Sino-Tibetan
 
***Glottolog***: `r length(trees$sino_tibetan$glottolog$original$tip.label)` languages (tips), with three kinds of branch lengths: "original" (1.0), "exponential" and "ultrametric".

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Sino-Tibetan"),"* : *",(tree.name <- "Glottolog (ultrametric)"),"*?")), fig.height=10, results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$sino_tibetan$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_ST_glottolog";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$sino_tibetan$glottolog$original$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$sino_tibetan$glottolog$original$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$sino_tibetan$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

From ***@zhangPhylogeneticEvidenceSinoTibetan2019a***: one Maximum Clade Credibility (MCC) tree  with `r length(trees$sino_tibetan$zhang$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",family.name,"* : *",(tree.name <- "Zhang et al. (2019)"),"*?")), fig.height=10, results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$sino_tibetan$zhang, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_ST_z2019";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$sino_tibetan$zhang$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$sino_tibetan$zhang$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$sino_tibetan$zhang, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

***@jagerGlobalscalePhylogeneticLinguistic2018***: `r length(trees$sino_tibetan$gerhard$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Sino-Tibetan"),"* : *",(tree.name <- "Jäger (2018)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$sino_tibetan$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_ST_j2018";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$sino_tibetan$gerhard$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$sino_tibetan$gerhard$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$sino_tibetan$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### Tai-Kadai

***Glottolog***: `r length(trees$tai_kadai$glottolog$original$tip.label)` languages (tips), with three kinds of branch lengths: "original" (1.0), "exponential" and "ultrametric".

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Tai-Kadai"),"* : *",(tree.name <- "Glottolog (ultrametric)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$tai_kadai$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_TK_glottolog";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$tai_kadai$glottolog$original$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$tai_kadai$glottolog$original$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$tai_kadai$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

***@jagerGlobalscalePhylogeneticLinguistic2018***: `r length(trees$tai_kadai$gerhard$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Tai-Kadai"),"* : *",(tree.name <- "Jäger (2018)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$tai_kadai$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_TK_j2018";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$tai_kadai$gerhard$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$tai_kadai$gerhard$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$tai_kadai$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### Timor-Alor-Pantar

***Glottolog***: `r length(trees$timor_alor_pantar$glottolog$original$tip.label)` languages (tips), with three kinds of branch lengths: "original" (1.0), "exponential" and "ultrametric".

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Timor-Alor-Pantar"),"* : *",(tree.name <- "Glottolog (ultrametric)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$timor_alor_pantar$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_TAP_glottolog";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$timor_alor_pantar$glottolog$original$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$timor_alor_pantar$glottolog$original$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$timor_alor_pantar$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

***@jagerGlobalscalePhylogeneticLinguistic2018***: `r length(trees$timor_alor_pantar$gerhard$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Timor-Alor-Pantar"),"* : *",(tree.name <- "Jäger (2018)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$timor_alor_pantar$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_TAP_j2018";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$timor_alor_pantar$gerhard$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$timor_alor_pantar$gerhard$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$timor_alor_pantar$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### Turkic

***Glottolog***: `r length(trees$turkic$glottolog$original$tip.label)` languages (tips), with three kinds of branch lengths: "original" (1.0), "exponential" and "ultrametric".

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Turkic"),"* : *",(tree.name <- "Glottolog (ultrametric)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$turkic$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_Tur_glottolog";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$turkic$glottolog$original$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$turkic$glottolog$original$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$turkic$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

From ***@Hruschka2015***: one summary tree with `r length(trees$turkic$mcmc$summary$tip.label)` languages (tips), and `r sum(vapply(trees$turkic$mcmc$posterior, function(x) !is.null(x), logical(1)))` individual posterior trees

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",family.name,"* : *",(tree.name <- "MCMC (summary)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$turkic$mcmc$summary, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_Tur_h2015";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$turkic$mcmc$summary$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$turkic$mcmc$summary$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$turkic$mcmc$summary, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### Uralic

***Glottolog***: `r length(trees$uralic$glottolog$original$tip.label)` languages (tips), with three kinds of branch lengths: "original" (1.0), "exponential" and "ultrametric".

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Uralic"),"* : *",(tree.name <- "Glottolog (ultrametric)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$uralic$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_Ur_glottolog";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$uralic$glottolog$original$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$uralic$glottolog$original$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$uralic$glottolog$ultrametric, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

From ***@Honkola2013***: one summary tree with `r length(trees$uralic$mcmc$summary$tip.label)` languages (tips), and `r sum(vapply(trees$uralic$mcmc$posterior, function(x) !is.null(x), logical(1)))` individual posterior trees.

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",family.name,"* : *",(tree.name <- "MCMC (summary)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$uralic$mcmc$summary, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_Ur_h2013";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$uralic$mcmc$summary$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$uralic$mcmc$summary$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$uralic$mcmc$summary, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

***@jagerGlobalscalePhylogeneticLinguistic2018***: `r length(trees$uralic$gerhard$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "Uralic"),"* : *",(tree.name <- "Jäger (2018)"),"*?")), results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$uralic$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_Ur_j2018";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$uralic$gerhard$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$uralic$gerhard$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$uralic$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### "Global" languages tree [@jagerGlobalscalePhylogeneticLinguistic2018]

***@jagerGlobalscalePhylogeneticLinguistic2018***: `r length(trees$world$gerhard$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "World"),"* : *",(tree.name <- "World (Jäger, 2018)"),"*?")), fig.height=40, results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$world$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_Glob_j2018";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$world$gerhard$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$world$gerhard$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$world$gerhard, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```

#### "Global" MCC phylogeny [@bouckaert_global_2022]

***@bouckaert_global_2022***: `r length(trees$world$betal22$tip.label)` languages (tips).

```{r fig.cap=capFig(paste0("Is there a dedicated word for 'blue' in *",(family.name <- "World"),"* : *",(tree.name <- "World (Bouckaert et al., 2022)"),"*?")), fig.height=70, results='asis'}
invisible(x <- .map.data.to.tree(tree=trees$world$betal22, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE));
cat(sprintf("   **tree info:** # lgs = %d, %% blue = %.2f%%, H(blue) = %.2f\n", x$n.tips, 100*mean(x$tips.blue,na.rm=TRUE), entropy(x$tips.blue)));
```
```{r include=FALSE}
# save tree for paper:
file_name <- "fig_tree_Glob_b2022";
#png(paste0("./paper/",file_name,".png"), width=8, height=length(trees$world$betal22$tip.label)*0.15, units="in", res=300); # for main paper
jpeg(paste0("./paper/",file_name,".jpg"), width=8, height=length(trees$world$betal22$tip.label)*0.15, units="in", res=300, quality=85); # for SI
invisible(x <- .map.data.to.tree(tree=trees$world$betal22, family.name=family.name, tree.name=tree.name, show.IV=NULL, binarize.IV=FALSE, plot.tree=TRUE, plot.legend=FALSE));
dev.off();
```


### Phylogenetic signal of 'blue'

```{r include=FALSE}
file_name <- "./cached_results/physig_blue.RData";
if( !all(file.exists(file_name)) )
{
  # Estimate phylogenetic signal for 'blue' given a tree (D does not work and also crashes R, so let's ignore it for now):
  .estimate.phylosig.blue <- function(tree, family.name=NA, tree.name=NA, do.d=TRUE, do.pglmm=TRUE, do.IG10=TRUE)
  {
    # Return value:
    ret.val <- data.frame("family"=family.name, "tree"=tree.name,
                          "error"=NA,
                          "D"=NA, "D.p0"=NA, "D.p1"=NA, 
                          "PGLMM.s2"=NA, "PGLMM.s2.p0"=NA, 
                          "IG10.alpha"=NA, "IG10.alphaWarn"=NA); # alphaWarn !=0 -> may simply reflect a flat likelihood at small/large alpha values, meaning that the phylogenetic correlation is estimated to be negligible
    
    if( is.null(tree) || !inherits(tree, "phylo") ){ret.val$error <- "empty tree"; return (ret.val);}
    
    # Select and align the data to the tree:
    d <- unique(d_colors_ag[ !is.na(d_colors_ag$exists_blue) & d_colors_ag$glottocode %in% tree$tip.label, c("glottocode", "exists_blue") ]);
    d <- d[ !duplicated(d$glottocode), ]; # keep the first of potentially duplicated rows
    d <- as.data.frame(d); # make sure it is a data.frame
    d$exists_blue <- as.numeric(d$exists_blue == "yes"); 
    rownames(d) <- d$glottocode;
    d <- d[intersect(d$glottocode, tree$tip.label), ];
    tree <- drop.tip(tree, setdiff(tree$tip.label, d$glottocode), trim.internal=TRUE);
    d <- d[tree$tip.label,]; # make sure the tree and the data re identically ordered
    
    # Checks:
    if( is.null(tree) || !inherits(tree, "phylo") || nrow(d) == 0 ){ret.val$error <- "empty tree and data"; return (ret.val);}
    if( length(unique(d$exists_blue)) == 1 ){ret.val$error <- "blue is constant"; return (ret.val);}
    
    # Method 1: Fritz and Purvis'D (https://wiki.duke.edu/display/AnthroTree/5.5.1+Fritz+and+Purvis%27+D+in+R)
    if( do.d )
    {
      require(caper);
      ps_d <- NULL;
      try(ps_d <- caper::phylo.d(data=d, phy=tree, names.col=glottocode, binvar=exists_blue), silent=TRUE);
      if( !is.null(ps_d) ) 
      {
        ret.val$D <- ps_d$DEstimate; ret.val$D.p0 <- ps_d$Pval0; ret.val$D.p1 <- ps_d$Pval1; 
      }
    }
    
    # Method 2: binaryPGLMM:
    if( do.pglmm )
    {
      require(ape);
      ps_pglmm <- NULL;
      try(ps_pglmm <- binaryPGLMM(exists_blue ~ 1, data=d, phy=tree), silent=TRUE);
      if( !is.null(ps_pglmm) ) 
      {
        ret.val$PGLMM.s2 <- ps_pglmm$s2; ret.val$PGLMM.s2.p0 <- ps_pglmm$P.H0.s2; 
      }
    }
    
    # Method 3: phyloglm (@Ives2014):
    if( do.IG10 )
    {
      require(phylolm);
      ps_phyloglm <- NULL;
      suppressWarnings(try(ps_phyloglm <-phyloglm(exists_blue ~ 1, data=d, phy=tree, method="logistic_IG10"), silent=TRUE));
      if( !is.null(ps_phyloglm) ) 
      {
        ret.val$IG10.alpha     <- ps_phyloglm$alpha;
        ret.val$IG10.alphaWarn <- ps_phyloglm$alphaWarn;
      }
    }
    
    # Return it:
    return (ret.val);
  }
  
  physig_blue <- NULL;
  
  # Afro-Asiatic:
  cat("Estimating phylogenetic signal for Afro-Asiatic (1/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$afro_asiatic$glottolog$original,    "Afro-Asiatic", "Glottolog (original)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$afro_asiatic$glottolog$exponential, "Afro-Asiatic", "Glottolog (exponential)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$afro_asiatic$glottolog$ultrametric, "Afro-Asiatic", "Glottolog (ultrametric)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$afro_asiatic$gerhard,               "Afro-Asiatic", "Jäger (2018)"));
  
  # Atlantic-Congo:
  cat("Estimating phylogenetic signal for Atlantic-Congo (2/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$atlantic_congo$glottolog$original,    "Atlantic-Congo", "Glottolog (original)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$atlantic_congo$glottolog$exponential, "Atlantic-Congo", "Glottolog (exponential)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$atlantic_congo$glottolog$ultrametric, "Atlantic-Congo", "Glottolog (ultrametric)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$atlantic_congo$gerhard,               "Atlantic-Congo", "Jäger (2018)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$bantu$mcmc$summary, "Bantu", "MCMC (summary)"));
  physig_blue <- rbind(physig_blue, do.call(rbind, mclapply(trees$bantu$mcmc$posterior, function(x) .estimate.phylosig.blue(x, "Bantu", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-2))));
  
  # Austroasiatic:
  cat("Estimating phylogenetic signal for Austroasiatic (3/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$austroasiatic$glottolog$original,    "Austroasiatic", "Glottolog (original)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$austroasiatic$glottolog$exponential, "Austroasiatic", "Glottolog (exponential)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$austroasiatic$glottolog$ultrametric, "Austroasiatic", "Glottolog (ultrametric)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$austroasiatic$gerhard,               "Austroasiatic", "Jäger (2018)"));
  
  # Austronesian:
  cat("Estimating phylogenetic signal for Austronesian (4/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$austronesian$glottolog$original,    "Austronesian", "Glottolog (original)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$austronesian$glottolog$exponential, "Austronesian", "Glottolog (exponential)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$austronesian$glottolog$ultrametric, "Austronesian", "Glottolog (ultrametric)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$austronesian$gerhard,               "Austronesian", "Jäger (2018)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$austronesian$mcmc$summary, "Austronesian", "MCMC (summary)"));
  physig_blue <- rbind(physig_blue, do.call(rbind, mclapply(trees$austronesian$mcmc$posterior, function(x) .estimate.phylosig.blue(x, "Austronesian", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-2))));
  
  # Hmong-Mien:
  cat("Estimating phylogenetic signal for Hmong-Mien (5/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$hmong_mien$glottolog$original,    "Hmong-Mien", "Glottolog (original)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$hmong_mien$glottolog$exponential, "Hmong-Mien", "Glottolog (exponential)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$hmong_mien$glottolog$ultrametric, "Hmong-Mien", "Glottolog (ultrametric)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$hmong_mien$gerhard,               "Hmong-Mien", "Jäger (2018)"));
  
  # Indo-European:
  cat("Estimating phylogenetic signal for Indo-European (6/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$indo_european$glottolog$original,    "Indo-European", "Glottolog (original)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$indo_european$glottolog$exponential, "Indo-European", "Glottolog (exponential)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$indo_european$glottolog$ultrametric, "Indo-European", "Glottolog (ultrametric)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$indo_european$gerhard,               "Indo-European", "Jäger (2018)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$indo_european$mcmc$summary, "Indo-European", "MCMC (summary)"));
  physig_blue <- rbind(physig_blue, do.call(rbind, mclapply(trees$indo_european$mcmc$posterior, function(x) .estimate.phylosig.blue(x, "Indo-European", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-2))));
  
  # Nakh-Daghestanian:
  cat("Estimating phylogenetic signal for Nakh-Daghestanian (7/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$nakh_daghestanian$glottolog$original,    "Nakh-Daghestanian", "Glottolog (original)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$nakh_daghestanian$glottolog$exponential, "Nakh-Daghestanian", "Glottolog (exponential)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$nakh_daghestanian$glottolog$ultrametric, "Nakh-Daghestanian", "Glottolog (ultrametric)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$nakh_daghestanian$gerhard,               "Nakh-Daghestanian", "Jäger (2018)"));
  
  # Pama-Nyungan:
  cat("Estimating phylogenetic signal for Pama-Nyungan (8/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$pama_nyungan$glottolog$original,    "Pama-Nyungan", "Glottolog (original)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$pama_nyungan$glottolog$exponential, "Pama-Nyungan", "Glottolog (exponential)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$pama_nyungan$glottolog$ultrametric, "Pama-Nyungan", "Glottolog (ultrametric)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$pama_nyungan$gerhard,               "Pama-Nyungan", "Jäger (2018)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$pama_nyungan$mcmc$summary, "Pama-Nyungan", "MCMC (summary)"));
  physig_blue <- rbind(physig_blue, do.call(rbind, mclapply(trees$pama_nyungan$mcmc$posterior, function(x) .estimate.phylosig.blue(x, "Pama-Nyungan", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-2))));
  
  # Pano-Tacanan:
  cat("Estimating phylogenetic signal for Pano-Tacanan (9/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$pano_tacanan$glottolog$original,    "Pano-Tacanan", "Glottolog (original)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$pano_tacanan$glottolog$exponential, "Pano-Tacanan", "Glottolog (exponential)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$pano_tacanan$glottolog$ultrametric, "Pano-Tacanan", "Glottolog (ultrametric)"));

  # Sino-Tibetan:
  cat("Estimating phylogenetic signal for Sino-Tibetan (10/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$sino_tibetan$glottolog$original,    "Sino-Tibetan", "Glottolog (original)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$sino_tibetan$glottolog$exponential, "Sino-Tibetan", "Glottolog (exponential)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$sino_tibetan$glottolog$ultrametric, "Sino-Tibetan", "Glottolog (ultrametric)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$sino_tibetan$gerhard,               "Sino-Tibetan", "Jäger (2018)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$sino_tibetan$zhang,                 "Sino-Tibetan", "Zhang et al. (2019)"));
  
  # Tai-Kadai:
  cat("Estimating phylogenetic signal for Tai-Kadai (11/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$tai_kadai$glottolog$original,    "Tai-Kadai", "Glottolog (original)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$tai_kadai$glottolog$exponential, "Tai-Kadai", "Glottolog (exponential)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$tai_kadai$glottolog$ultrametric, "Tai-Kadai", "Glottolog (ultrametric)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$tai_kadai$gerhard,               "Tai-Kadai", "Jäger (2018)"));
  
  # Timor-Alor-Pantar:
  cat("Estimating phylogenetic signal for Timor-Alor-Pantar (12/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$timor_alor_pantar$glottolog$original,    "Timor-Alor-Pantar", "Glottolog (original)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$timor_alor_pantar$glottolog$exponential, "Timor-Alor-Pantar", "Glottolog (exponential)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$timor_alor_pantar$glottolog$ultrametric, "Timor-Alor-Pantar", "Glottolog (ultrametric)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$timor_alor_pantar$gerhard,               "Timor-Alor-Pantar", "Jäger (2018)"));
  
  # Turkic:
  cat("Estimating phylogenetic signal for Turkic (13/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$turkic$glottolog$original,    "Turkic", "Glottolog (original)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$turkic$glottolog$exponential, "Turkic", "Glottolog (exponential)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$turkic$glottolog$ultrametric, "Turkic", "Glottolog (ultrametric)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$turkic$mcmc$summary, "Turkic", "MCMC (summary)"));
  physig_blue <- rbind(physig_blue, do.call(rbind, mclapply(trees$turkic$mcmc$posterior, function(x) .estimate.phylosig.blue(x, "Turkic", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-2))));
  
  # Uralic:
  cat("Estimating phylogenetic signal for Uralic (14/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$uralic$glottolog$original,    "Uralic", "Glottolog (original)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$uralic$glottolog$exponential, "Uralic", "Glottolog (exponential)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$uralic$glottolog$ultrametric, "Uralic", "Glottolog (ultrametric)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$uralic$gerhard,               "Uralic", "Jäger (2018)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$uralic$mcmc$summary, "Uralic", "MCMC (summary)"));
  physig_blue <- rbind(physig_blue, do.call(rbind, mclapply(trees$uralic$mcmc$posterior, function(x) .estimate.phylosig.blue(x, "Uralic", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-2))));
  
  # World:
  cat("Estimating phylogenetic signal for World (15/15)...\n");
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$world$gerhard, "World", "Jäger (2018)"));
  physig_blue <- rbind(physig_blue, .estimate.phylosig.blue(trees$world$betal22, "World", "Bouckaert et al. (2022)"));
  
  # Assemble the various results and save them:
  save(physig_blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
} 
```

We estimated the phylogenetic signal of 'blue' using three methods:

- Fritz and Purvis' *D* [@fritz_selectivity_2010], as implemented by `phylo.d()` in package `caper`: this has a numeric estimate *D* of the phylogenetic signal and also two *p*-values associated with the hypotheses (*D*=0) and (*D*=1), respectively,
- *logistic phylogenetic regression* with no predictors, as implemented by:
  - `binaryPGLMM()` in package `ape`, which gives the "phylogenetic signal measured as the scalar magnitude of the phylogenetic variance-covariance matrix s2 * V" (denoted here *s2*) and the *p*-value of the "likelihood ratio test of the hypothesis H0 that s2 = 0", and
  - `phyloglm()` in package `phylolm` using @IG2010's method, which uses "alpha to estimate the level of phylogenetic correlation" (denoted here *α*); this might come with a warning if the *α* is too close to its limits, in which case this probably means that the phylogenetic signal is negligible.

```{r}
tmp_no_mcmc <- physig_blue[ !(physig_blue$tree %in% c("MCMC (summary)", "MCMC (posterior)")), ];
tmp_no_mcmc$tree <- ifelse(tmp_no_mcmc$tree == "Glottolog (original)", "Original", ifelse(tmp_no_mcmc$tree == "Glottolog (exponential)", "Exponential", ifelse(tmp_no_mcmc$tree == "Glottolog (ultrametric)", "Ultrametric", tmp_no_mcmc$tree)));
tmp_no_mcmc$error[ is.na(tmp_no_mcmc$error) ] <- "-";
tmp_no_mcmc$D <- sprintf("%s%.2f%s", ifelse(tmp_no_mcmc$D.p0 < 0.05,"**",""), tmp_no_mcmc$D, ifelse(tmp_no_mcmc$D.p0 < 0.05,"**",""));
tmp_no_mcmc$D.p0 <- sprintf("%s%.2g%s%s", ifelse(tmp_no_mcmc$D.p0 < 0.05,"**",""), tmp_no_mcmc$D.p0, ifelse(tmp_no_mcmc$D.p0 < 0.01, "^⭑⭑^", ifelse(tmp_no_mcmc$D.p0 < 0.05, "^⭑^", "")), ifelse(tmp_no_mcmc$D.p0 < 0.05,"**",""));
tmp_no_mcmc$D.p1 <- sprintf("%.2g%s", tmp_no_mcmc$D.p1, ifelse(tmp_no_mcmc$D.p1 < 0.01, "^⭑⭑^", ifelse(tmp_no_mcmc$D.p1 < 0.05, "^⭑^","")));
tmp_no_mcmc$PGLMM.s2 <- sprintf("%s%.2f%s", ifelse(tmp_no_mcmc$PGLMM.s2.p0 < 0.05, "**", ""), tmp_no_mcmc$PGLMM.s2, ifelse(tmp_no_mcmc$PGLMM.s2.p0 < 0.05, "**", ""));
tmp_no_mcmc$PGLMM.s2.p0 <- sprintf("%s%.2g%s%s", ifelse(tmp_no_mcmc$PGLMM.s2.p0 < 0.05, "**", ""), tmp_no_mcmc$PGLMM.s2.p0, ifelse(tmp_no_mcmc$PGLMM.s2.p0 < 0.01, "^⭑⭑^", ifelse(tmp_no_mcmc$PGLMM.s2.p0 < 0.05, "^⭑^", "")), ifelse(tmp_no_mcmc$PGLMM.s2.p0 < 0.05, "**", ""));
tmp_no_mcmc$IG10.alpha <- sprintf("%.2f", tmp_no_mcmc$IG10.alpha);
tmp_no_mcmc$IG10.alphaWarn <- ifelse( tmp_no_mcmc$IG10.alphaWarn == 0, "-", "at limit");
tmp_no_mcmc$D[ tmp_no_mcmc$D == "NANANA" ] <- "-";
tmp_no_mcmc$D.p0[ tmp_no_mcmc$D.p0 == "NANANANA" ] <- "-";
tmp_no_mcmc$D.p1[ tmp_no_mcmc$D.p1 == "NANA" ] <- "-";
tmp_no_mcmc$PGLMM.s2[ tmp_no_mcmc$PGLMM.s2 == "NANANA" ] <- "-";
tmp_no_mcmc$PGLMM.s2.p0[ tmp_no_mcmc$PGLMM.s2.p0 == "NANANANA" ] <- "-";
tmp_no_mcmc$IG10.alpha[ tmp_no_mcmc$IG10.alpha == "NA" ] <- "-";
tmp_no_mcmc$IG10.alphaWarn[ is.na(tmp_no_mcmc$IG10.alphaWarn) ] <- "";
tmp_no_mcmc$family[ tmp_no_mcmc$family == "World" ] <- "***World***";
knitr::kable(tmp_no_mcmc, 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "*D*", "*p*(*D*=0)", "*p*(*D*=1)", "*s2*", "*p*(*s2*=0)", "*α*", "*α* warning?"),
             align="r",
             caption=capTab('Various estimates of the phylogenetic signal when using the **Glottolog trees** with original ("Original") branch length (i.e., all branches have length 1.0), using an exponential ("Exponential") branch length and a ultrametric ("Ultrametric") one, as well as the **@jagerGlobalscalePhylogeneticLinguistic2018 trees** (where available), and the **@zhangPhylogeneticEvidenceSinoTibetan2019a for Sino-Tibetan**.')); 
```

```{r}
tmp_mcmc_summary <- physig_blue[ (physig_blue$tree %in% c("MCMC (summary)")), ];
tmp_mcmc_summary$error[ is.na(tmp_mcmc_summary$error) ] <- "-";
tmp_mcmc_summary$D <- sprintf("%.2f", tmp_mcmc_summary$D);
tmp_mcmc_summary$D.p0 <- sprintf("%.2g%s", tmp_mcmc_summary$D.p0, ifelse(tmp_mcmc_summary$D.p0 < 0.01, "**", ifelse(tmp_mcmc_summary$D.p0 < 0.05, "*", "")));
tmp_mcmc_summary$D.p1 <- sprintf("%.2g%s", tmp_mcmc_summary$D.p1, ifelse(tmp_mcmc_summary$D.p1 < 0.01, "**", ifelse(tmp_mcmc_summary$D.p1 < 0.05, "*", "")));
tmp_mcmc_summary$PGLMM.s2 <- sprintf("%.2f", tmp_mcmc_summary$PGLMM.s2);
tmp_mcmc_summary$PGLMM.s2.p0 <- sprintf("%.2g%s", tmp_mcmc_summary$PGLMM.s2.p0, ifelse(tmp_mcmc_summary$PGLMM.s2.p0 < 0.01, "**", ifelse(tmp_mcmc_summary$PGLMM.s2.p0 < 0.05, "*", "")));
tmp_mcmc_summary$IG10.alpha <- sprintf("%.2f", tmp_mcmc_summary$IG10.alpha);
tmp_mcmc_summary$IG10.alphaWarn <- ifelse( tmp_mcmc_summary$IG10.alphaWarn == 0, "-", "at limit");
tmp_mcmc_summary$D[ tmp_mcmc_summary$D == "NA" ] <- "-";
tmp_mcmc_summary$D.p0[ tmp_mcmc_summary$D.p0 == "NANA" ] <- "-";
tmp_mcmc_summary$D.p1[ tmp_mcmc_summary$D.p1 == "NANA" ] <- "-";
tmp_mcmc_summary$PGLMM.s2[ tmp_mcmc_summary$PGLMM.s2 == "NA" ] <- "-";
tmp_mcmc_summary$PGLMM.s2.p0[ tmp_mcmc_summary$PGLMM.s2.p0 == "NANA" ] <- "-";
tmp_mcmc_summary$IG10.alpha[ tmp_mcmc_summary$IG10.alpha == "NA" ] <- "-";
tmp_mcmc_summary$IG10.alphaWarn[ is.na(tmp_mcmc_summary$IG10.alphaWarn) ] <- "";
knitr::kable(tmp_mcmc_summary[,-2], 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "*D*", "*p*(*D*=0)", "*p*(*D*=1)", "*s2*", "*p*(*s2*=0)", "*α*", "*α* warning?"),
             align="r",
             caption=capTab("Various estimates of the phylogenetic signal when using the **summary MCMC trees**. 'Bantu' is a subfamily of 'Atlantic-Congo'."));
```

```{r}
tmp_mcmc_post <- physig_blue[ (physig_blue$tree %in% c("MCMC (posterior)")), ];
tmp_mcmc_post <- tmp_mcmc_post %>% 
  group_by(family) %>% 
  summarise("errors"=paste0(unique(error,collapse="; ")),
            "mean.sd.D"=sprintf("%.2g (%.2g)", mean(D, na.rm=TRUE), sd(D, na.rm=TRUE)), 
            "median.iqr.D"=sprintf("%.2g (%.2g)", median(D, na.rm=TRUE), IQR(D, na.rm=TRUE)), 
            "perc.signif.D.0"=sprintf("%.1f%%", 100*sum(D.p0 < 0.05, na.rm=TRUE)/sum(!is.na(D.p0))),
            "perc.signif.D.1"=sprintf("%.1f%%", 100*sum(D.p1 < 0.05, na.rm=TRUE)/sum(!is.na(D.p1))),
            "mean.sd.s2"=sprintf("%.2g (%.2g)", mean(PGLMM.s2, na.rm=TRUE), sd(PGLMM.s2, na.rm=TRUE)), 
            "median.iqr.s2"=sprintf("%.2g (%.2g)", median(PGLMM.s2, na.rm=TRUE), IQR(PGLMM.s2, na.rm=TRUE)), 
            "perc.signif.s2"=sprintf("%.1f%%", 100*sum(PGLMM.s2.p0 < 0.05, na.rm=TRUE)/sum(!is.na(PGLMM.s2.p0))),
            "mean.sd.alpha"=sprintf("%.2g (%.2g)", mean(IG10.alpha, na.rm=TRUE), sd(IG10.alpha, na.rm=TRUE)), 
            "median.iqr.alpha"=sprintf("%.2g (%.2g)", median(IG10.alpha, na.rm=TRUE), IQR(IG10.alpha, na.rm=TRUE)), 
            "perc.nowarn.alpha"=sprintf("%.1f%%", 100*sum(IG10.alphaWarn != 0, na.rm=TRUE)/sum(!is.na(IG10.alphaWarn))));
tmp_mcmc_post$errors[ tmp_mcmc_post$errors == "NA" ] <- "-";
tmp_mcmc_post$mean.sd.D[ tmp_mcmc_post$mean.sd.D == "NaN (NA)" ] <- "-";
tmp_mcmc_post$median.iqr.D[ tmp_mcmc_post$median.iqr.D == "NA (NA)" ] <- "-";
tmp_mcmc_post$perc.signif.D.0[ tmp_mcmc_post$perc.signif.D.0 == "NaN%" ] <- "-";
tmp_mcmc_post$perc.signif.D.1[ tmp_mcmc_post$perc.signif.D.1 == "NaN%" ] <- "-";
tmp_mcmc_post$mean.sd.s2[ tmp_mcmc_post$mean.sd.s2 == "NaN (NA)" ] <- "-";
tmp_mcmc_post$median.iqr.s2[ tmp_mcmc_post$median.iqr.s2 == "NA (NA)" ] <- "-";
tmp_mcmc_post$perc.signif.s2[ tmp_mcmc_post$perc.signif.s2 == "NaN%" ] <- "-";
tmp_mcmc_post$mean.sd.alpha[ tmp_mcmc_post$mean.sd.alpha == "NaN (NA)" ] <- "-";
tmp_mcmc_post$median.iqr.alpha[ tmp_mcmc_post$median.iqr.alpha == "NA (NA)" ] <- "-";
tmp_mcmc_post$perc.nowarn.alpha[ tmp_mcmc_post$perc.nowarn.alpha == "NaN%" ] <- "-";
knitr::kable(tmp_mcmc_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "*D* μ(σ)", "*D* med(IQR)", "% *D* != 0", "% *D* != 1", "*s2* μ(σ)", "*s2* med(IQR)", "% *s2* != 0", "*α* μ(σ)", "*α* med(IQR)", "% *α* no warn"),
             align="r",
             caption=capTab("Various estimates of the phylogenetic signal when using the **posterior sample of MCMC trees**."));
```

<!--
The estimates of the phylogenetic signal of 'blue' across the families and used trees is mixed, but we can highlight the following:

- *Austronesian*: s2 > 0 and D < 1 (Glottolog, MCMC, and @jagerGlobalscalePhylogeneticLinguistic2018)
- *Indo-European*: s2 > 0 and D < 1 (Glottolog)
- *World*: s2 > 0 and 0 < D < 1
-->

```{r include=FALSE, eval=FALSE}
# Export as LaTeX table for the paper (sill needs some re-arranging and small changes, but the bulk of the work is done):
tmp <- tmp_no_mcmc[,c("family", "tree", "D", "D.p0", "D.p1", "PGLMM.s2", "PGLMM.s2.p0", "IG10.alpha", "IG10.alphaWarn")];
tmp <- rbind(tmp, tmp_mcmc_summary[,c("family", "tree", "D", "D.p0", "D.p1", "PGLMM.s2", "PGLMM.s2.p0", "IG10.alpha", "IG10.alphaWarn")]);
tmp$tree <- vapply(tmp$tree, function(s) switch(s, "Original"="Go", "Exponential"="Ge", "Ultrametric"="Gu", "Jäger (2018)"="\\citet{JagerGlobal2018}", "Zhang et al. (2019)"="summary", "Bouckaert et al. (2022)"="\\citet{bouckaert_global_2022}",
                                                "MCMC (summary)"="summary"), character(1));
tmp$IG10.alphaWarn <- ifelse(tmp$IG10.alphaWarn != "at limit", "N", "Y");
tmp <- rbind(tmp, data.frame("family"=tmp_mcmc_post$family, "tree"="posterior", 
                             "D"=vapply(strsplit(tmp_mcmc_post$mean.sd.D, "(", fixed=TRUE), function(s) s[1],character(1)), 
                             "D.p0"=tmp_mcmc_post$perc.signif.D.0, 
                             "D.p1"=tmp_mcmc_post$perc.signif.D.1, 
                             "PGLMM.s2"=vapply(strsplit(tmp_mcmc_post$mean.sd.s2, "(", fixed=TRUE), function(s) s[1],character(1)), 
                             "PGLMM.s2.p0"=tmp_mcmc_post$perc.signif.s2, 
                             "IG10.alpha"=vapply(strsplit(tmp_mcmc_post$mean.sd.alpha, "(", fixed=TRUE), function(s) s[1],character(1)), 
                             "IG10.alphaWarn"=tmp_mcmc_post$perc.nowarn.alpha));
tmp$family[ tmp$family == "Bantu" ] <- "(Bantu)"
tmp$family[ tmp$family == "***World***" & tmp$tree == "\\citet{JagerGlobal2018}" ] <- "**``global'' (1)**";
tmp$family[ tmp$family == "***World***" & tmp$tree == "\\citet{bouckaert_global_2022}" ] <- "**``global'' (2)**";
tmp <- tmp[ tmp$D != "-", ];

rownames(tmp) <- paste0(ifelse(tmp$family == "(Bantu)", "Atlantic-Congo", ifelse(tmp$family == "**``global'' (1)**", "XXX1", ifelse(tmp$family == "**``global'' (2)**", "XXX2", tmp$family))), 
                        ".",
                        ifelse(tmp$tree == "Go", 1, 
                               ifelse(tmp$tree == "Ge", 2, 
                                      ifelse(tmp$tree == "Gu", 3, 
                                             ifelse(tmp$tree == "\\citet{JagerGlobal2018}", 4, 
                                                    ifelse(tmp$tree == "\\citet{bouckaert_global_2022}", 5,
                                                           ifelse(tmp$tree == "summary", 6,
                                                                  7)))))));
tmp <- tmp[ order(rownames(tmp)), ];
i <- 2;
while( i < nrow(tmp) )
{
  if( strsplit(rownames(tmp)[i-1],".",fixed=TRUE)[[1]][1] != strsplit(rownames(tmp)[i],".",fixed=TRUE)[[1]][1] )
  {
    # change of family:
    tmp <- rbind(tmp[1:i-1,], data.frame("family"="\\hline", "tree"="", "D"="", "D.p0"="", "D.p1"="", "PGLMM.s2"="", "PGLMM.s2.p0"="", "IG10.alpha"="", "IG10.alphaWarn"=""), tmp[i:nrow(tmp),]);
    rownames(tmp)[i] <- paste0(rownames(tmp)[i+1],".");
  } 
  i <- i+1;
}
for( i in 2:nrow(tmp) )
{
  if( strsplit(rownames(tmp)[i-1],".",fixed=TRUE)[[1]][1] == strsplit(rownames(tmp)[i],".",fixed=TRUE)[[1]][1] && tmp$family[i-1] != "\\hline") tmp$family[i] <- "";
}

tmp$tree <- paste0((x <- ifelse( (startsWith(tmp$D, "**") | startsWith(tmp$PGLMM.s2, "**")) & !startsWith(tmp$tree, "**"), "**", "" )), tmp$tree, x); 

s <- vapply(1:nrow(tmp), function(i) ifelse(tmp$tree[i] == "", tmp$family[i], paste0(tmp[i,], collapse=" & ")), character(1));
s <- paste0(s, ifelse(s=="\\hline", "\n", "\\\\ \n"));
s <- str_replace_all(s, "^\\*\\*", "\\\\textbf{");
s <- str_replace_all(s, fixed(" **"), " \\textbf{");
s <- str_replace_all(s, fixed("**"), "}");
s <- str_replace_all(s, fixed("^⭑^"), "\\textsuperscript{*}");
s <- str_replace_all(s, fixed("^⭑⭑^"), "\\textsuperscript{**}");
s <- str_replace_all(s, fixed("%"), "\\%");
library("clipr");
write_clip(s); # copy it directly to clipboard for pasting in the latex file...
#cat(paste0(s,collapse="\n"));
```


### Ancestral state reconstruction

```{r include=FALSE}
file_name <- paste0("./cached_results/ancrec_blue.RData");
if( !file.exists(file_name) )
{
  # Ancestral state reconstruction of blue given a tree:
  .anc.st.rec.blue <- function(tree, family.name=NA, tree.name=NA, do.ace=TRUE, do.rerooting=TRUE)
  {
    # Return value:
    ret.val <- data.frame("family"=family.name, "tree"=tree.name, "error"=NA); # general info
    # ACE:
    ret.val <- cbind(ret.val, "ace.er.rate"=NA, 
                     "ace.er.rate.se"=NA, "ace.er.prob0root"=NA,
                     "ace.ard.rate01"=NA, "ace.ard.rate10"=NA, "ace.ard.rate01.se"=NA, "ace.ard.rate10.se"=NA, "ace.ard.prob0root"=NA,
                     "ace.delta.AIC.er.ard"=NA, "ace.LRT.er.ard.p"=NA);
    # Re-rooting:
    ret.val <- cbind(ret.val, "rerrot.rate"=NA, "rerrot.er.prob0root"=NA);

    if( is.null(tree) || !inherits(tree, "phylo") ){ret.val$error <- "empty tree"; return (ret.val);}
    
    # Select and align the data to the tree:
    d <- unique(d_colors_ag[ !is.na(d_colors_ag$exists_blue) & 
                               (d_colors_ag$glottocode %in% tree$tip.label), 
                             c("glottocode", "exists_blue") ]);
    d <- d[ !duplicated(d$glottocode), ]; # keep the first of potentially duplicated rows
    d <- as.data.frame(d); # make sure it is a data.frame
    d$exists_blue_num <- as.numeric(d$exists_blue == "yes"); 
    rownames(d) <- d$glottocode;
    d <- d[intersect(d$glottocode, tree$tip.label), ];
    tree <- drop.tip(tree, setdiff(tree$tip.label, d$glottocode), trim.internal=TRUE);
    d <- d[tree$tip.label,]; # make sure the tree and the data are identically ordered
    
    # Checks:
    if( is.null(tree) || !inherits(tree, "phylo") || nrow(d) == 0 ){ret.val$error <- "empty tree and data"; return (ret.val);}
    
    if( length(unique(d$exists_blue_num)) == 1 )
    {
      ret.val$error <- paste0("blue is constant (",unique(d$exists_blue_num)," == ",unique(d$exists_blue),")"); 
      ret.val$ace.er.prob0root <- ret.val$ace.ard.prob0root <- ret.val$rerrot.er.prob0root <- ifelse(unique(d$exists_blue_num) == 0, 1.00, 0.00);
      ret.val$ace.delta.AIC.er.ard <- 0.0; ret.val$ace.LRT.er.ard.p <- 1.0;
      return (ret.val);
    }

    # Method 1: ace:
    if( do.ace )
    {
      require(ape);
      require(castor);
      x <- d$exists_blue_num; names(x) <- rownames(d);
      if( ape::is.binary(tree) )
      {
        tree.bin <- tree;
      } else
      {
        tree.bin <- ape::multi2di(tree); # ape::ace need a binary rooted tree...
        tree.bin$edge.length[ tree.bin$edge.length <= 0 ] <- min(tree.bin$edge.length[ tree.bin$edge.length > 0 ], na.rm=TRUE) / 10; # avoid branches of length 0.0
      }
      # Try to estimate ER and ARD models (n.b., ER and SYM are the same model as the character is binary):
      asr_ace_er <- asr_ace_ard <- NULL;
      suppressWarnings(try(asr_ace_er  <- ape::ace(x, tree.bin, type="discrete", model="ER"), silent=TRUE));
      suppressWarnings(try(asr_ace_ard <- ape::ace(x, tree.bin, type="discrete", model="ARD"), silent=TRUE));
      if( !is.null(asr_ace_er) ) 
      {
        ret.val$ace.er.rate      <- asr_ace_er$rates[1]; 
        ret.val$ace.er.rate.se   <- asr_ace_er$se[1];
        ret.val$ace.er.prob0root <- asr_ace_er$lik.anc[ rownames(asr_ace_er$lik.anc) == castor::find_root(tree.bin), "0" ];
      }
      if( !is.null(asr_ace_ard) ) 
      {
        ret.val$ace.ard.rate01    <- asr_ace_ard$rates[ asr_ace_ard$index.matrix[1,2] ]; 
        ret.val$ace.ard.rate01.se <- asr_ace_ard$se[ asr_ace_ard$index.matrix[1,2] ];
        ret.val$ace.ard.rate10    <- asr_ace_ard$rates[ asr_ace_ard$index.matrix[2,1] ]; 
        ret.val$ace.ard.rate10.se <- asr_ace_ard$se[ asr_ace_ard$index.matrix[2,1] ];
        ret.val$ace.ard.prob0root <- asr_ace_ard$lik.anc[ rownames(asr_ace_ard$lik.anc) == castor::find_root(tree.bin), "0" ];
      }
      if( !is.null(asr_ace_er) && !is.null(asr_ace_ard) ) 
      {
        ret.val$ace.delta.AIC.er.ard <- (AIC(asr_ace_er) - AIC(asr_ace_ard));
        ret.val$ace.LRT.er.ard.p     <- anova(asr_ace_er, asr_ace_ard)[2, "Pr(>|Chi|)"];
      }
    }

    # Method 2: re-rooting:
    if( do.rerooting )
    {
      require(phytools);
      require(castor);
      x <- d$exists_blue_num; names(x) <- rownames(d);
      if( ape::is.binary(tree) )
      {
        tree.bin <- tree;
      } else
      {
        tree.bin <- ape::multi2di(tree); # ape::ace need a binary rooted tree...
        tree.bin$edge.length[ tree.bin$edge.length <= 0 ] <- min(tree.bin$edge.length[ tree.bin$edge.length > 0 ], na.rm=TRUE) / 10; # avoid branches of length 0.0
      }
      # This method works only with ER (or, equivalently here, SYM):
      asr_rr <- NULL;
      suppressWarnings(try(asr_rr  <- phytools::rerootingMethod(tree.bin, x, model="ER", tips=FALSE), silent=TRUE));
      if( !is.null(asr_rr) ) 
      {
        ret.val$rerrot.rate         <- asr_rr$Q["0","1"];
        ret.val$rerrot.er.prob0root <- asr_rr$marginal.anc[ rownames(asr_rr$marginal.anc) == castor::find_root(tree.bin), "0" ];
      }
    }

    # Return it:
    return (ret.val);
  }
  
  cat(paste0("\n** Ancestral state reconstruction for 'blue'... ***\n\n"));
  
  ancrec_blue <- NULL;
  
  # Afro-Asiatic:
  cat("  - Ancestral state reconstruction for Afro-Asiatic (1/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$afro_asiatic$glottolog$original,    "Afro-Asiatic", "Glottolog (original)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$afro_asiatic$glottolog$exponential, "Afro-Asiatic", "Glottolog (exponential)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$afro_asiatic$glottolog$ultrametric, "Afro-Asiatic", "Glottolog (ultrametric)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$afro_asiatic$gerhard,               "Afro-Asiatic", "Jäger (2018)"));
  
  # Atlantic-Congo:
  cat("  - Ancestral state reconstruction for Atlantic-Congo (2/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$atlantic_congo$glottolog$original,    "Atlantic-Congo", "Glottolog (original)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$atlantic_congo$glottolog$exponential, "Atlantic-Congo", "Glottolog (exponential)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$atlantic_congo$glottolog$ultrametric, "Atlantic-Congo", "Glottolog (ultrametric)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$atlantic_congo$gerhard,               "Atlantic-Congo", "Jäger (2018)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$bantu$mcmc$summary, "Bantu", "MCMC (summary)"));
  ancrec_blue <- rbind(ancrec_blue, do.call(rbind, mclapply(trees$bantu$mcmc$posterior, function(x) .anc.st.rec.blue(x, "Bantu", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-1))));
  
  # Austroasiatic:
  cat("  - Ancestral state reconstruction for Austroasiatic (3/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$austroasiatic$glottolog$original,    "Austroasiatic", "Glottolog (original)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$austroasiatic$glottolog$exponential, "Austroasiatic", "Glottolog (exponential)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$austroasiatic$glottolog$ultrametric, "Austroasiatic", "Glottolog (ultrametric)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$austroasiatic$gerhard,               "Austroasiatic", "Jäger (2018)"));
  
  # Austronesian:
  cat("  - Ancestral state reconstruction for Austronesian (4/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$austronesian$glottolog$original,    "Austronesian", "Glottolog (original)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$austronesian$glottolog$exponential, "Austronesian", "Glottolog (exponential)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$austronesian$glottolog$ultrametric, "Austronesian", "Glottolog (ultrametric)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$austronesian$gerhard,               "Austronesian", "Jäger (2018)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$austronesian$mcmc$summary,          "Austronesian", "MCMC (summary)"));
  ancrec_blue <- rbind(ancrec_blue, do.call(rbind, mclapply(trees$austronesian$mcmc$posterior, function(x) .anc.st.rec.blue(x, "Austronesian", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-1))));
  
  # Hmong-Mien:
  cat("  - Ancestral state reconstruction for Hmong-Mien (5/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$hmong_mien$glottolog$original,    "Hmong-Mien", "Glottolog (original)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$hmong_mien$glottolog$exponential, "Hmong-Mien", "Glottolog (exponential)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$hmong_mien$glottolog$ultrametric, "Hmong-Mien", "Glottolog (ultrametric)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$hmong_mien$gerhard,               "Hmong-Mien", "Jäger (2018)"));
  
  # Indo-European:
  cat("  - Ancestral state reconstruction for Indo-European (6/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$indo_european$glottolog$original,    "Indo-European", "Glottolog (original)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$indo_european$glottolog$exponential, "Indo-European", "Glottolog (exponential)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$indo_european$glottolog$ultrametric, "Indo-European", "Glottolog (ultrametric)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$indo_european$gerhard,               "Indo-European", "Jäger (2018)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$indo_european$mcmc$summary, "Indo-European", "MCMC (summary)"));
  ancrec_blue <- rbind(ancrec_blue, do.call(rbind, mclapply(trees$indo_european$mcmc$posterior, function(x) .anc.st.rec.blue(x, "Indo-European", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-1))));
  
  # Nakh-Daghestanian:
  cat("  - Ancestral state reconstruction for Nakh-Daghestanian (7/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$nakh_daghestanian$glottolog$original,    "Nakh-Daghestanian", "Glottolog (original)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$nakh_daghestanian$glottolog$exponential, "Nakh-Daghestanian", "Glottolog (exponential)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$nakh_daghestanian$glottolog$ultrametric, "Nakh-Daghestanian", "Glottolog (ultrametric)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$nakh_daghestanian$gerhard,               "Nakh-Daghestanian", "Jäger (2018)"));

  # Pama-Nyungan:
  cat("  - Ancestral state reconstruction for Pama-Nyungan (8/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$pama_nyungan$glottolog$original,    "Pama-Nyungan", "Glottolog (original)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$pama_nyungan$glottolog$exponential, "Pama-Nyungan", "Glottolog (exponential)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$pama_nyungan$glottolog$ultrametric, "Pama-Nyungan", "Glottolog (ultrametric)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$pama_nyungan$gerhard,               "Pama-Nyungan", "Jäger (2018)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$pama_nyungan$mcmc$summary,          "Pama-Nyungan", "MCMC (summary)"));
  ancrec_blue <- rbind(ancrec_blue, do.call(rbind, mclapply(trees$pama_nyungan$mcmc$posterior, function(x) .anc.st.rec.blue(x, "Pama-Nyungan", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-1))));
  
  # Pano-Tacanan:
  cat("  - Ancestral state reconstruction for Pano-Tacanan (9/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$pano_tacanan$glottolog$original,    "Pano-Tacanan", "Glottolog (original)",));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$pano_tacanan$glottolog$exponential, "Pano-Tacanan", "Glottolog (exponential)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$pano_tacanan$glottolog$ultrametric, "Pano-Tacanan", "Glottolog (ultrametric)"));

  # Sino-Tibetan:
  cat("  - Ancestral state reconstruction for Sino-Tibetan (10/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$sino_tibetan$glottolog$original,    "Sino-Tibetan", "Glottolog (original)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$sino_tibetan$glottolog$exponential, "Sino-Tibetan", "Glottolog (exponential)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$sino_tibetan$glottolog$ultrametric, "Sino-Tibetan", "Glottolog (ultrametric)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$sino_tibetan$gerhard,               "Sino-Tibetan", "Jäger (2018)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$sino_tibetan$zhang,                 "Sino-Tibetan", "Zhang et al. (2019)"));
  
  # Tai-Kadai:
  cat("  - Ancestral state reconstruction for Tai-Kadai (11/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$tai_kadai$glottolog$original,    "Tai-Kadai", "Glottolog (original)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$tai_kadai$glottolog$exponential, "Tai-Kadai", "Glottolog (exponential)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$tai_kadai$glottolog$ultrametric, "Tai-Kadai", "Glottolog (ultrametric)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$tai_kadai$gerhard,               "Tai-Kadai", "Jäger (2018)"));
  
  # Timor-Alor-Pantar:
  cat("  - Ancestral state reconstruction for Timor-Alor-Pantar (12/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$timor_alor_pantar$glottolog$original,    "Timor-Alor-Pantar", "Glottolog (original)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$timor_alor_pantar$glottolog$exponential, "Timor-Alor-Pantar", "Glottolog (exponential)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$timor_alor_pantar$glottolog$ultrametric, "Timor-Alor-Pantar", "Glottolog (ultrametric)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$timor_alor_pantar$gerhardc,              "Timor-Alor-Pantar", "Jäger (2018)"));
  
  # Turkic:
  cat("  - Ancestral state reconstruction for Turkic (13/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$turkic$glottolog$original,    "Turkic", "Glottolog (original)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$turkic$glottolog$exponential, "Turkic", "Glottolog (exponential)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$turkic$glottolog$ultrametric, "Turkic", "Glottolog (ultrametric)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$turkic$mcmc$summary,          "Turkic", "MCMC (summary)"));
  ancrec_blue <- rbind(ancrec_blue, do.call(rbind, mclapply(trees$turkic$mcmc$posterior, function(x) .anc.st.rec.blue(x, "Turkic", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-1))));
  
  # Uralic:
  cat("  - Ancestral state reconstruction for Uralic (14/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$uralic$glottolog$original,    "Uralic", "Glottolog (original)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$uralic$glottolog$exponential, "Uralic", "Glottolog (exponential)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$uralic$glottolog$ultrametric, "Uralic", "Glottolog (ultrametric)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$uralic$gerhard,               "Uralic", "Jäger (2018)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$uralic$mcmc$summary,          "Uralic", "MCMC (summary)"));
  ancrec_blue <- rbind(ancrec_blue, do.call(rbind, mclapply(trees$uralic$mcmc$posterior, function(x) .anc.st.rec.blue(x, "Uralic", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-1))));
  
  # World:
  cat("  - Ancestral state reconstruction for World (15/15)...\n");
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$world$gerhard, "World", "Jäger (2018)"));
  ancrec_blue <- rbind(ancrec_blue, .anc.st.rec.blue(trees$world$betal22, "World", "Bouckaert et al. (2022)"));

  # Save it:
  save(ancrec_blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
} 
```

We estimated the probability that proto-languages had a word for 'blue' using two methods of ancient character reconstruction:

- the one implemented by `ace()` in package `ape` and based on @pagel_detecting_1994: we used both the single-rate (*ER*, equivalent in this case to the symmetric *SYM* model) and the all-rates (*ARD*); both estimate the appropriate transition rate(s) (1 for *ER*, 2 for *ARD*) and the probability of a "0" (i.e., the absence of 'blue') at the root; further, we compared the two methods (using the LR test and AIC), retaining the one best fitting the data;
- the one implemented by `rerootingMethod` in package `phytools` and based on @yang_new_1995, which estimates the marginal ancestral state estimates by re-rooting the tree; this works only for symmetric models (so, in this case, *ER*, or equivalently *SYM*) and gives the transition rate and the probability of a "0" at the root.


```{r}
tmp_no_mcmc <- ancrec_blue[ !(ancrec_blue$tree %in% c("MCMC (summary)", "MCMC (posterior)")), ]; 
tmp_no_mcmc$tree <- ifelse(tmp_no_mcmc$tree == "Glottolog (original)", "Original", ifelse(tmp_no_mcmc$tree == "Glottolog (exponential)", "Exponential", ifelse(tmp_no_mcmc$tree == "Glottolog (ultrametric)", "Ultrametric", tmp_no_mcmc$tree)));
tmp_no_mcmc$error[ is.na(tmp_no_mcmc$error) ] <- "-";
tmp_no_mcmc$ace.best.model <- ifelse(tmp_no_mcmc$ace.delta.AIC.er.ard > 3 & tmp_no_mcmc$ace.LRT.er.ard.p < 0.05, "ARD", "ER");
tmp_no_mcmc$ace.rate01 <- ifelse(tmp_no_mcmc$ace.best.model == "ER", tmp_no_mcmc$ace.er.rate, tmp_no_mcmc$ace.ard.rate01);
tmp_no_mcmc$ace.rate10 <- ifelse(tmp_no_mcmc$ace.best.model == "ER", tmp_no_mcmc$ace.er.rate, tmp_no_mcmc$ace.ard.rate10);
tmp_no_mcmc$ace.prob1root <- sprintf("%.0f%%",100-100*ifelse(tmp_no_mcmc$ace.best.model == "ER", tmp_no_mcmc$ace.er.prob0root, tmp_no_mcmc$ace.ard.prob0root));
tmp_no_mcmc$rerrot.prob1root <- sprintf("%.0f%%",100-100*tmp_no_mcmc$rerrot.er.prob0root);
tmp_no_mcmc$family[ tmp_no_mcmc$family == "World" ] <- "***World***";
knitr::kable(tmp_no_mcmc[,c("family", "tree", "error", "ace.best.model", "ace.prob1root", "rerrot.prob1root")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "ACE: model", "ACE: *p*(root=1)", "ReR: *p*(root=1)"),
             align="r",
             caption=capTab('Estimated probability that the root did have a dedicated word for \'blue\' using the **Glottolog trees** with original ("Original") branch length (i.e., all branches have length 1.0), using an exponential ("Exponential") branch length and a ultrametric ("Ultrametric") one, as well as the **@jagerGlobalscalePhylogeneticLinguistic2018 trees** (where available), and the **@zhangPhylogeneticEvidenceSinoTibetan2019a for Sino-Tibetan**, as given by `ace` (*ACE*) and by re-routing (*ReR*), respectively; we also show which `ace` model best fits the data.'));
```

```{r}
tmp_mcmc_summary <- ancrec_blue[ (ancrec_blue$tree %in% c("MCMC (summary)")), ]; 
tmp_mcmc_summary$error[ is.na(tmp_mcmc_summary$error) ] <- "-";
tmp_mcmc_summary$ace.best.model <- ifelse(tmp_mcmc_summary$ace.delta.AIC.er.ard > 3 & tmp_mcmc_summary$ace.LRT.er.ard.p < 0.05, "ARD", "ER");
tmp_mcmc_summary$ace.rate01 <- ifelse(tmp_mcmc_summary$ace.best.model == "ER", tmp_mcmc_summary$ace.er.rate, tmp_mcmc_summary$ace.ard.rate01);
tmp_mcmc_summary$ace.rate10 <- ifelse(tmp_mcmc_summary$ace.best.model == "ER", tmp_mcmc_summary$ace.er.rate, tmp_mcmc_summary$ace.ard.rate10);
tmp_mcmc_summary$ace.prob1root <- sprintf("%.0f%%",100-100*ifelse(tmp_mcmc_summary$ace.best.model == "ER", tmp_mcmc_summary$ace.er.prob0root, tmp_mcmc_summary$ace.ard.prob0root));
tmp_mcmc_summary$rerrot.prob1root <- sprintf("%.0f%%",100-100*tmp_mcmc_summary$rerrot.er.prob0root);
knitr::kable(tmp_mcmc_summary[,c("family", "error", "ace.best.model", "ace.prob1root", "rerrot.prob1root")], 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "ACE: model", "ACE: *p*(root=1)", "ReR: *p*(root=1)"),
             align="r",
             caption=capTab("Estimated probability that the root did have a dedicated word for 'blue' using the **summary MCMC trees**, as given by `ace` (*ACE*) and by re-routing (*ReR*), respectively; we also show which `ace` model best fits the data. 'Bantu' is a subfamily of 'Atlantic-Congo'."));
```

```{r}
tmp_mcmc_post <- ancrec_blue[ (ancrec_blue$tree %in% c("MCMC (posterior)")), ]; 
tmp_mcmc_post$ace.best.model <- ifelse(tmp_mcmc_post$ace.delta.AIC.er.ard > 3 & tmp_mcmc_post$ace.LRT.er.ard.p < 0.05, "ARD", "ER");
tmp_mcmc_post <- tmp_mcmc_post %>% 
  group_by(family) %>% 
  summarise("errors"=paste0(unique(error,collapse="; ")),
            "ace.er.proc"=sprintf("%.0f%%", 100*sum(ace.best.model == "ER") / n()),
            "ace.prob1root"=sprintf("%.0f%% (%.1f%%)", 100*mean(1-ifelse(ace.best.model == "ER", ace.er.prob0root, ace.ard.prob0root), na.rm=TRUE), 100*sd(1-ifelse(ace.best.model == "ER", ace.er.prob0root, ace.ard.prob0root), na.rm=TRUE)),
            "rerrot.prob1root"=sprintf("%.0f%% (%.1f%%)",100*mean(1-rerrot.er.prob0root, na.rm=TRUE), 100*sd(1-rerrot.er.prob0root, na.rm=TRUE)));
knitr::kable(tmp_mcmc_post[], 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "% ER best", "ACE: *p*(root=1)", "ReR: *p*(root=1)"),
             align="r",
             caption=capTab("Estimated probability that the root did have a dedicated word for 'blue' using the **posterior MCMC trees**, as given by `ace` (*ACE*) and by re-routing (*ReR*), respectively as mean (sd); we also show the % of trees for which `ace` best fits the data.."));
```

<!--
As expected given the results for the phylogenetic signal above, the estimates of the root probabilities for 'blue' seem to depend to a certain extent on the particular branch lengths and model used.
However, the following families seem to have had 'blue' "from the beginning": *Austronesian*, *Indo-European*, *Nakh-Daghestanian*, *Sino-Tibetan*, *Tai-Kadai*, *Turkic* and *Uralic*, while *Pama-Nyungan* seemingly did not.
Moreover, *World* is suggested to possibly have had 'blue' (but this is far from clear).
-->

```{r include=FALSE, eval=FALSE}
# Export as LaTeX table for the paper (sill needs some re-arranging and small changes, but the bulk of the work is done):
tmp <- data.frame("family"=tmp_no_mcmc$family, "tree"=tmp_no_mcmc$tree, "ace"=paste0(tmp_no_mcmc$ace.best.model,": ",tmp_no_mcmc$ace.prob1root), "rer"=tmp_no_mcmc$rerrot.prob1root);
tmp$family[ tmp$family == "***World***" & tmp$tree == "Jäger (2018)" ] <- "``global'' (1)";
tmp$family[ tmp$family == "***World***" & tmp$tree == "Bouckaert et al. (2022)" ] <- "``global'' (2)";

tmp <- rbind(tmp, data.frame("family"=tmp_mcmc_summary$family, "tree"=tmp_mcmc_summary$tree, "ace"=paste0(tmp_mcmc_summary$ace.best.model,": ",tmp_mcmc_summary$ace.prob1root), "rer"=tmp_mcmc_summary$rerrot.prob1root));

tmp$tree <- vapply(tmp$tree, function(s) switch(s, "Original"="Go", "Exponential"="Ge", "Ultrametric"="Gu", "Jäger (2018)"="\\citet{JagerGlobal2018}", "Zhang et al. (2019)"="summary", "Bouckaert et al. (2022)"="\\citet{bouckaert_global_2022}",
                                                "MCMC (summary)"="summary"), character(1));

tmp <- rbind(tmp, data.frame("family"=tmp_mcmc_post$family, "tree"="posterior", 
                             "ace"=paste0(tmp_mcmc_post$ace.er.proc,": ",vapply(strsplit(tmp_mcmc_post$ace.prob1root," (",fixed=TRUE), function(x) x[1], character(1))),
                             "rer"=vapply(strsplit(tmp_mcmc_post$rerrot.prob1root," (",fixed=TRUE), function(x) x[1], character(1))));

tmp <- tmp[ tmp$ace != "NA: NA%", ];
             
tmp$family[ tmp$family == "Bantu" ] <- "(Bantu)"

rownames(tmp) <- paste0(ifelse(tmp$family == "(Bantu)", "Atlantic-Congo", ifelse(tmp$family == "``global'' (1)", "XXX1", ifelse(tmp$family == "``global'' (2)", "XXX2", tmp$family))), 
                        ".",
                        ifelse(tmp$tree == "Go", 1, 
                               ifelse(tmp$tree == "Ge", 2, 
                                      ifelse(tmp$tree == "Gu", 3, 
                                             ifelse(tmp$tree == "\\citet{JagerGlobal2018}", 4, 
                                                    ifelse(tmp$tree == "\\citet{bouckaert_global_2022}", 5,
                                                           ifelse(tmp$tree == "summary", 6,
                                                                  7)))))));
tmp <- tmp[ order(rownames(tmp)), ];
i <- 2;
while( i < nrow(tmp) )
{
  if( strsplit(rownames(tmp)[i-1],".",fixed=TRUE)[[1]][1] != strsplit(rownames(tmp)[i],".",fixed=TRUE)[[1]][1] )
  {
    # change of family:
    tmp <- rbind(tmp[1:i-1,], data.frame("family"="\\hline", "tree"="", "ace"="", "rer"=""), tmp[i:nrow(tmp),]);
    rownames(tmp)[i] <- paste0(rownames(tmp)[i+1],".");
  } 
  i <- i+1;
}
for( i in 2:nrow(tmp) )
{
  if( strsplit(rownames(tmp)[i-1],".",fixed=TRUE)[[1]][1] == strsplit(rownames(tmp)[i],".",fixed=TRUE)[[1]][1] && tmp$family[i-1] != "\\hline") tmp$family[i] <- "";
}

for( i in 1:nrow(tmp) )
{
  if( tmp$family[i] != "\\hline" )
  {
    if( (x <- as.numeric(str_sub(strsplit(tmp$ace[i], ": ", fixed=TRUE)[[1]][2], 1, -2))) >= 75 || x <= 25 )
    {
      if( !startsWith(tmp$ace[i], "**") ) tmp$ace[i] <- paste0("**",tmp$ace[i],"**");
      if( !startsWith(tmp$tree[i], "**") ) tmp$tree[i] <- paste0("**",tmp$tree[i],"**");
    }
    if( (x <- as.numeric(str_sub(tmp$rer[i], 1, -2))) >= 75 || x <= 25 )
    {
      if( !startsWith(tmp$rer[i], "**") ) tmp$rer[i] <- paste0("**",tmp$rer[i],"**");
      if( !startsWith(tmp$tree[i], "**") ) tmp$tree[i] <- paste0("**",tmp$tree[i],"**");
    }
  }
}

s <- vapply(1:nrow(tmp), function(i) ifelse(tmp$tree[i] == "", tmp$family[i], paste0(tmp[i,], collapse=" & ")), character(1));
s <- paste0(s, ifelse(s=="\\hline", "\n", "\\\\ \n"));
s <- str_replace_all(s, "^\\*\\*", "\\\\textbf{");
s <- str_replace_all(s, fixed(" **"), " \\textbf{");
s <- str_replace_all(s, fixed("**"), "}");
s <- str_replace_all(s, fixed("^⭑^"), "\\textsuperscript{*}");
s <- str_replace_all(s, fixed("^⭑⭑^"), "\\textsuperscript{**}");
s <- str_replace_all(s, fixed("%"), "\\%");
library("clipr");
write_clip(s); # copy it directly to clipboard for pasting in the latex file...
#cat(paste0(s,collapse="\n"));
```


### Correlated evolution and phylogenetic regression

```{r include=FALSE}
correv__blue_varnames <- c();
if( TRUE )
{
  # Estimate the correlated evolution of 'blue' and something else:
  .corr.ev.blue <- function(tree, IV=NA, is.IV.binary=TRUE, family.name=NA, tree.name=NA, do.pagel=TRUE, do.threshBayes=TRUE)
  {
    # Return value:
    ret.val <- data.frame("family"=family.name, "tree"=tree.name, "IV"=IV, "is.IV.binary"=is.IV.binary, "IV.threshold"=NA, "error"=NA); # general info
    # Pagel:
    ret.val <- cbind(ret.val, "Pagel.DeltaAIC"=NA, "Pagel.LR"=NA, "Pagel.LR.p"=NA);
    # threshBayes:
    ret.val <- cbind(ret.val, "threshBayes.mean"=NA, "threshBayes.hdi_low"=NA, "threshBayes.hdi_high"=NA, "threshBayes.p.rope"=NA);

    if( is.null(tree) || !inherits(tree, "phylo") ){ret.val$error <- "empty tree"; return (ret.val);}
    
    # Select and align the data to the tree:
    d <- unique(d_colors_ag[ !is.na(d_colors_ag$exists_blue) & 
                               !is.na(d_colors_ag[,IV]) & 
                               (d_colors_ag$glottocode %in% tree$tip.label), 
                             c("glottocode", "exists_blue", IV) ]);
    d <- d[ !duplicated(d$glottocode), ]; # keep the first of potentially duplicated rows
    d <- as.data.frame(d); # make sure it is a data.frame
    d$exists_blue_num <- as.numeric(d$exists_blue == "yes"); 
    rownames(d) <- d$glottocode;
    d <- d[intersect(d$glottocode, tree$tip.label), ];
    tree <- drop.tip(tree, setdiff(tree$tip.label, d$glottocode), trim.internal=TRUE);
    d <- d[tree$tip.label,]; # make sure the tree and the data are identically ordered
    
    # Checks:
    if( is.null(tree) || !inherits(tree, "phylo") || nrow(d) == 0 ){ret.val$error <- "empty tree and data"; return (ret.val);}
    if( length(unique(d$exists_blue)) == 1 ){ret.val$error <- "blue is constant"; return (ret.val);}
    if( length(unique(d[,IV])) == 1 ){ret.val$error <- paste0(IV," is constant"); return (ret.val);}
    
    if( !is.IV.binary || length(unique(d[,IV])) > 2 )
    {
      # Continuous IV: discretize it using median split:
      ret.val$is.IV.binary <- FALSE;
      ret.val$IV.threshold <- median(d[,IV],na.rm=TRUE); 
      d$IVb <- ifelse(d[,IV] < ret.val$IV.threshold, 0, 1);
    } else
    {
      # Already binary IV:
      d$IVb <- d[,IV];
    }

    # Method 1: fitPagel:
    if( do.pagel )
    {
      require(phytools);
      ce_pagel <- NULL;
      x <- d$exists_blue_num; names(x) <- rownames(d);
      y <- as.numeric(d$IVb); names(y) <- rownames(d);
      try(ce_pagel <- phytools::fitPagel(tree, x, y), silent=TRUE);
      if( !is.null(ce_pagel) ) 
      {
        ret.val$Pagel.DeltaAIC <- as.numeric(ce_pagel$independent.AIC - ce_pagel$dependent.AIC); # negative = independent is better (i.e., no evidence of correlated evolution); positive = dependent is better (i.e., correlated evolution)
        ret.val$Pagel.LR       <- as.numeric(ce_pagel$lik.ratio);
        ret.val$Pagel.LR.p     <- as.numeric(ce_pagel$P);
      }
    }
    
    # Method 2: threshBayes:
    if( do.threshBayes )
    {
      require(phytools);
      ce_threshBayes <- NULL;
      capture.output(try(ce_threshBayes <- phytools::threshBayes(tree, d[,c("exists_blue", IV)], types=c("discrete", ifelse(ret.val$is.IV.binary, "discrete", "continuous")), ngen=50000, plot=FALSE), silent=TRUE), type="output");
      if( !is.null(ce_threshBayes) ) 
      {
        require(bayestestR);
        post.sam.corr <- ce_threshBayes$par$r[ ce_threshBayes$par$gen >= ce_threshBayes$burnin ];
        ret.val$threshBayes.mean <- mean(post.sam.corr, na.rm=TRUE);
        ret.val$threshBayes.hdi_low <- bayestestR::hdi(post.sam.corr, ci=0.95)[1,"CI_low"];
        ret.val$threshBayes.hdi_high <- bayestestR::hdi(post.sam.corr, ci=0.95)[1,"CI_high"];
        ret.val$threshBayes.p.rope <- as.numeric(bayestestR::rope(post.sam.corr, ci=0.95, verbose=FALSE));
      }
    }

    # Return it:
    return (ret.val);
  }

  IVs_to_test <- c("UV_mean_r", "UV_sd_r", 
                   "longitude", "latitude", 
                   "log_popSize_ethno", "subsistence", 
                   "dist2water_r", "dist2rivers_r", "dist2ocean_r","dist2lakes_r", 
                   "clim_PC1_r", "clim_PC2_r", "clim_PC3_r", "hum_median", "hum_IQR");
  IVs_binary <- c("subsistence"); # binary variables
  for(iv in IVs_to_test)
  {
    ret.val.name <- paste0("correv__",iv,"__blue");
    correv__blue_varnames <- c(correv__blue_varnames, ret.val.name);
    file_name <- paste0("./cached_results/correv__",iv,"__blue.RData");
    if( !file.exists(file_name) )
    {
      cat(paste0("\n** Correlated evolution for IV '",iv,"' (",which(IVs_to_test == iv)," of ",length(IVs_to_test),")... ***\n\n"));
      
      ret.val <- NULL;

      # Afro-Asiatic:
      cat("  - Fitting correlated evolution for Afro-Asiatic (1/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$afro_asiatic$glottolog$original,    iv, (iv %in% IVs_binary), "Afro-Asiatic", "Glottolog (original)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$afro_asiatic$glottolog$exponential, iv, (iv %in% IVs_binary), "Afro-Asiatic", "Glottolog (exponential)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$afro_asiatic$glottolog$ultrametric, iv, (iv %in% IVs_binary), "Afro-Asiatic", "Glottolog (ultrametric)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$afro_asiatic$gerhard,               iv, (iv %in% IVs_binary), "Afro-Asiatic", "Jäger (2018)"));
      
      # Atlantic-Congo:
      cat("  - Fitting correlated evolution for Atlantic-Congo (2/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$atlantic_congo$glottolog$original,    iv, (iv %in% IVs_binary), "Atlantic-Congo", "Glottolog (original)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$atlantic_congo$glottolog$exponential, iv, (iv %in% IVs_binary), "Atlantic-Congo", "Glottolog (exponential)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$atlantic_congo$glottolog$ultrametric, iv, (iv %in% IVs_binary), "Atlantic-Congo", "Glottolog (ultrametric)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$atlantic_congo$gerhard,               iv, (iv %in% IVs_binary), "Atlantic-Congo", "Jäger (2018)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$bantu$mcmc$summary, iv, (iv %in% IVs_binary), "Bantu", "MCMC (summary)"));
      ret.val <- rbind(ret.val, do.call(rbind, mclapply(trees$bantu$mcmc$posterior, function(x) .corr.ev.blue(x, iv, (iv %in% IVs_binary), "Bantu", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-1))));
      
      # Austroasiatic:
      cat("  - Fitting correlated evolution for Austroasiatic (3/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$austroasiatic$glottolog$original,    iv, (iv %in% IVs_binary), "Austroasiatic", "Glottolog (original)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$austroasiatic$glottolog$exponential, iv, (iv %in% IVs_binary), "Austroasiatic", "Glottolog (exponential)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$austroasiatic$glottolog$ultrametric, iv, (iv %in% IVs_binary), "Austroasiatic", "Glottolog (ultrametric)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$austroasiatic$gerhard,               iv, (iv %in% IVs_binary), "Austroasiatic", "Jäger (2018)"));
      
      # Austronesian:
      cat("  - Fitting correlated evolution for Austronesian (4/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$austronesian$glottolog$original,    iv, (iv %in% IVs_binary), "Austronesian", "Glottolog (original)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$austronesian$glottolog$exponential, iv, (iv %in% IVs_binary), "Austronesian", "Glottolog (exponential)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$austronesian$glottolog$ultrametric, iv, (iv %in% IVs_binary), "Austronesian", "Glottolog (ultrametric)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$austronesian$gerhard,               iv, (iv %in% IVs_binary), "Austronesian", "Jäger (2018)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$austronesian$mcmc$summary,          iv, (iv %in% IVs_binary), "Austronesian", "MCMC (summary)"));
      ret.val <- rbind(ret.val, do.call(rbind, mclapply(trees$austronesian$mcmc$posterior, function(x) .corr.ev.blue(x, iv, (iv %in% IVs_binary), "Austronesian", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-1))));
      
      # Hmong-Mien:
      cat("  - Fitting correlated evolution for Hmong-Mien (5/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$hmong_mien$glottolog$original,    iv, (iv %in% IVs_binary), "Hmong-Mien", "Glottolog (original)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$hmong_mien$glottolog$exponential, iv, (iv %in% IVs_binary), "Hmong-Mien", "Glottolog (exponential)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$hmong_mien$glottolog$ultrametric, iv, (iv %in% IVs_binary), "Hmong-Mien", "Glottolog (ultrametric)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$hmong_mien$gerhard,               iv, (iv %in% IVs_binary), "Hmong-Mien", "Jäger (2018)"));
      
      # Indo-European:
      cat("  - Fitting correlated evolution for Indo-European (6/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$indo_european$glottolog$original,    iv, (iv %in% IVs_binary), "Indo-European", "Glottolog (original)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$indo_european$glottolog$exponential, iv, (iv %in% IVs_binary), "Indo-European", "Glottolog (exponential)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$indo_european$glottolog$ultrametric, iv, (iv %in% IVs_binary), "Indo-European", "Glottolog (ultrametric)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$indo_european$gerhard,               iv, (iv %in% IVs_binary), "Indo-European", "Jäger (2018)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$indo_european$mcmc$summary, iv, (iv %in% IVs_binary), "Indo-European", "MCMC (summary)"));
      ret.val <- rbind(ret.val, do.call(rbind, mclapply(trees$indo_european$mcmc$posterior, function(x) .corr.ev.blue(x, iv, (iv %in% IVs_binary), "Indo-European", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-1))));
      
      # Nakh-Daghestanian:
      cat("  - Fitting correlated evolution for Nakh-Daghestanian (7/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$nakh_daghestanian$glottolog$original,    iv, (iv %in% IVs_binary), "Nakh-Daghestanian", "Glottolog (original)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$nakh_daghestanian$glottolog$exponential, iv, (iv %in% IVs_binary), "Nakh-Daghestanian", "Glottolog (exponential)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$nakh_daghestanian$glottolog$ultrametric, iv, (iv %in% IVs_binary), "Nakh-Daghestanian", "Glottolog (ultrametric)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$nakh_daghestanian$gerhard,               iv, (iv %in% IVs_binary), "Nakh-Daghestanian", "Jäger (2018)"));
      
      # Pama-Nyungan:
      cat("  - Fitting correlated evolution for Pama-Nyungan (8/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$pama_nyungan$glottolog$original,    iv, (iv %in% IVs_binary), "Pama-Nyungan", "Glottolog (original)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$pama_nyungan$glottolog$exponential, iv, (iv %in% IVs_binary), "Pama-Nyungan", "Glottolog (exponential)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$pama_nyungan$glottolog$ultrametric, iv, (iv %in% IVs_binary), "Pama-Nyungan", "Glottolog (ultrametric)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$pama_nyungan$gerhard,               iv, (iv %in% IVs_binary), "Pama-Nyungan", "Jäger (2018)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$pama_nyungan$mcmc$summary,          iv, (iv %in% IVs_binary), "Pama-Nyungan", "MCMC (summary)"));
      ret.val <- rbind(ret.val, do.call(rbind, mclapply(trees$pama_nyungan$mcmc$posterior, function(x) .corr.ev.blue(x, iv, (iv %in% IVs_binary), "Pama-Nyungan", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-1))));
      
      # Pano-Tacanan:
      cat("  - Fitting correlated evolution for Pano-Tacanan (9/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$pano_tacanan$glottolog$original,    iv, (iv %in% IVs_binary), "Pano-Tacanan", "Glottolog (original)",));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$pano_tacanan$glottolog$exponential, iv, (iv %in% IVs_binary), "Pano-Tacanan", "Glottolog (exponential)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$pano_tacanan$glottolog$ultrametric, iv, (iv %in% IVs_binary), "Pano-Tacanan", "Glottolog (ultrametric)"));
      
      # Sino-Tibetan:
      cat("  - Fitting correlated evolution for Sino-Tibetan (10/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$sino_tibetan$glottolog$original,    iv, (iv %in% IVs_binary), "Sino-Tibetan", "Glottolog (original)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$sino_tibetan$glottolog$exponential, iv, (iv %in% IVs_binary), "Sino-Tibetan", "Glottolog (exponential)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$sino_tibetan$glottolog$ultrametric, iv, (iv %in% IVs_binary), "Sino-Tibetan", "Glottolog (ultrametric)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$sino_tibetan$gerhard,               iv, (iv %in% IVs_binary), "Sino-Tibetan", "Jäger (2018)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$sino_tibetan$zhang,                 iv, (iv %in% IVs_binary), "Sino-Tibetan", "Zhang et al. (2019)"));
      
      # Tai-Kadai:
      cat("  - Fitting correlated evolution for Tai-Kadai (11/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$tai_kadai$glottolog$original,    iv, (iv %in% IVs_binary), "Tai-Kadai", "Glottolog (original)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$tai_kadai$glottolog$exponential, iv, (iv %in% IVs_binary), "Tai-Kadai", "Glottolog (exponential)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$tai_kadai$glottolog$ultrametric, iv, (iv %in% IVs_binary), "Tai-Kadai", "Glottolog (ultrametric)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$tai_kadai$gerhard,               iv, (iv %in% IVs_binary), "Tai-Kadai", "Jäger (2018)"));
      
      # Timor-Alor-Pantar:
      cat("  - Fitting correlated evolution for Timor-Alor-Pantar (12/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$timor_alor_pantar$glottolog$original,    iv, (iv %in% IVs_binary), "Timor-Alor-Pantar", "Glottolog (original)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$timor_alor_pantar$glottolog$exponential, iv, (iv %in% IVs_binary), "Timor-Alor-Pantar", "Glottolog (exponential)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$timor_alor_pantar$glottolog$ultrametric, iv, (iv %in% IVs_binary), "Timor-Alor-Pantar", "Glottolog (ultrametric)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$timor_alor_pantar$gerhard,               iv, (iv %in% IVs_binary), "Timor-Alor-Pantar", "Jäger (2018)"));
      
      # Turkic:
      cat("  - Fitting correlated evolution for Turkic (13/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$turkic$glottolog$original,    iv, (iv %in% IVs_binary), "Turkic", "Glottolog (original)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$turkic$glottolog$exponential, iv, (iv %in% IVs_binary), "Turkic", "Glottolog (exponential)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$turkic$glottolog$ultrametric, iv, (iv %in% IVs_binary), "Turkic", "Glottolog (ultrametric)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$turkic$mcmc$summary,          iv, (iv %in% IVs_binary), "Turkic", "MCMC (summary)"));
      ret.val <- rbind(ret.val, do.call(rbind, mclapply(trees$turkic$mcmc$posterior, function(x) .corr.ev.blue(x, iv, (iv %in% IVs_binary), "Turkic", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-1))));
      
      # Uralic:
      cat("  - Fitting correlated evolution for Uralic (14/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$uralic$glottolog$original,    iv, (iv %in% IVs_binary), "Uralic", "Glottolog (original)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$uralic$glottolog$exponential, iv, (iv %in% IVs_binary), "Uralic", "Glottolog (exponential)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$uralic$glottolog$ultrametric, iv, (iv %in% IVs_binary), "Uralic", "Glottolog (ultrametric)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$uralic$gerhard,               iv, (iv %in% IVs_binary), "Uralic", "Jäger (2018)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$uralic$mcmc$summary,          iv, (iv %in% IVs_binary), "Uralic", "MCMC (summary)"));
      ret.val <- rbind(ret.val, do.call(rbind, mclapply(trees$uralic$mcmc$posterior, function(x) .corr.ev.blue(x, iv, (iv %in% IVs_binary), "Uralic", "MCMC (posterior)"), mc.cores=max(1,brms_ncores-1))));
      
      # World:
      cat("  - Fitting correlated evolution for World (15/15)...\n");
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$world$gerhard, iv, (iv %in% IVs_binary), "World", "Jäger (2018)"));
      ret.val <- rbind(ret.val, .corr.ev.blue(trees$world$betal22, iv, (iv %in% IVs_binary), "World", "Bouckaert et al. (2022)"));

      # Rename and save it:
      assign(ret.val.name, ret.val);
      
      saveRDS(get(ret.val.name), file=file_name, compress="xz");
      
      gc(); # force garbage collection
    } else
    {
      assign(ret.val.name, readRDS(file_name));
    } 
  }
} 
```

We estimated the **correlated evolution** of 'blue' with various IVs of interest, using two methods:

- `fitPagel()` in package `phytools` based on @pagel_detecting_1994: this only works for binary characters (which is fine for 'blue'), so we dichotomized the continuous IVs using *median split* (i.e., all values < the median → "0", all others → "1"), and
- the *threshold model* as implemented by `threshBayes()` also in package `phytools` and based on @felsenstein_comparative_2012: this is a Bayesian method which works with both discrete and continuous characters.

```{r include=FALSE}
phyreg__blue_varnames <- c();
if( TRUE )
{
  # Regress 'blue' on something else on a given tree:
  .phylo.regress.blue <- function(tree, IVs=c(), family.name=NA, tree.name=NA, do.pglmm=TRUE, do.phyloglm=TRUE, do.brms=TRUE, do.brms.cmp0=FALSE, do.brms.parallel=TRUE, do.flat=TRUE)
  {
    # Return value:
    ret.val <- data.frame("family"=family.name, "tree"=tree.name, "IVs"=paste0(IVs, collapse=" + "), "error"=NA); # general info
    # GLM:
    ret.val <- cbind(ret.val, "GLM.intercept"=NA, "GLM.intercept.se"=NA, "GLM.intercept.p"=NA);
    for( x in IVs )
    {
      ret.val <- cbind(ret.val, NA, NA, NA);
      names(ret.val)[ncol(ret.val)-(2:0)] <- paste0("GLM.",x, c("", ".se", ".p"));
    }
    # PGLMM:
    ret.val <- cbind(ret.val, "PGLMM.s2"=NA, "PGLMM.s2.p0"=NA);
    ret.val <- cbind(ret.val, "PGLMM.intercept"=NA, "PGLMM.intercept.se"=NA, "PGLMM.intercept.p"=NA);
    for( x in IVs )
    {
      ret.val <- cbind(ret.val, NA, NA, NA);
      names(ret.val)[ncol(ret.val)-(2:0)] <- paste0("PGLMM.",x, c("", ".se", ".p"));
    }
    # phyloglm:
    # IG10:
    ret.val <- cbind(ret.val, "IG10.alpha"=NA, "IG10.alphaWarn"=NA); # alphaWarn !=0 -> may simply reflect a flat likelihood at small/large alpha values, meaning that the phylogenetic correlation is estimated to be negligible
    ret.val <- cbind(ret.val, "IG10.AIC"=NA, "IG10.AIC0"=NA);
    ret.val <- cbind(ret.val, "IG10.intercept"=NA, "IG10.intercept.se"=NA, "IG10.intercept.p"=NA);
    for( x in IVs )
    {
      ret.val <- cbind(ret.val, NA, NA, NA);
      names(ret.val)[ncol(ret.val)-(2:0)] <- paste0("IG10.",x, c("", ".se", ".p"));
    }
    # MPLE:
    ret.val <- cbind(ret.val, "MPLE.alpha"=NA, "MPLE.alphaWarn"=NA); # alphaWarn !=0 -> may simply reflect a flat likelihood at small/large alpha values, meaning that the phylogenetic correlation is estimated to be negligible
    ret.val <- cbind(ret.val, "MPLE.AIC"=NA, "MPLE.AIC0"=NA);
    ret.val <- cbind(ret.val, "MPLE.intercept"=NA, "MPLE.intercept.se"=NA, "MPLE.intercept.p"=NA);
    for( x in IVs )
    {
      ret.val <- cbind(ret.val, NA, NA, NA);
      names(ret.val)[ncol(ret.val)-(2:0)] <- paste0("MPLE.",x, c("", ".se", ".p"));
    }
    # BRMS flat:
    ret.val <- cbind(ret.val, "BRMSf.intercept"=NA, "BRMSf.intercept.hdi89"=NA, "BRMSf.intercept.rope89"=NA, "BRMSf.intercept.hdi95"=NA, "BRMSf.intercept.rope95"=NA);
    for( x in IVs )
    {
      ret.val <- cbind(ret.val, NA, NA, NA, NA, NA, NA, NA);
      names(ret.val)[ncol(ret.val)-(6:0)] <- paste0("BRMSf.",x, c("", ".hdi89", ".rope89", ".hdi95", ".rope95", ".p0", ".p0star"));
    }
    # BRMS:
    ret.val <- cbind(ret.val, "BRMS.intercept"=NA, "BRMS.intercept.hdi89"=NA, "BRMS.intercept.rope89"=NA, "BRMS.intercept.hdi95"=NA, "BRMS.intercept.rope95"=NA);
    ret.val <- cbind(ret.val, "BRMS.vs0.BF"=NA, "BRMS.vs0.BFinterp"=NA, "BRMS.vs0.BF.better"=NA,
                     "BRMS.vs0.LOO.diff"=NA, "BRMS.vs0.LOO.se"=NA, "BRMS.vs0.LOO.better"=NA,
                     "BRMS.vs0.WAIC.diff"=NA, "BRMS.vs0.WAIC.se"=NA, "BRMS.vs0.WAIC.better"=NA,
                     "BRMS.vs0.KFOLD.diff"=NA, "BRMS.vs0.KFOLD.se"=NA, "BRMS.vs0.KFOLD.better"=NA,
                     "BRMS.vs0.WAIC.weight"=NA,  "BRMS.vs0.WAIC.weight.better"=NA);
    for( x in IVs )
    {
      ret.val <- cbind(ret.val, NA, NA, NA, NA, NA, NA, NA);
      names(ret.val)[ncol(ret.val)-(6:0)] <- paste0("BRMS.",x, c("", ".hdi89", ".rope89", ".hdi95", ".rope95", ".p0", ".p0star"));
    }
    
    if( is.null(tree) || !inherits(tree, "phylo") ){ret.val$error <- "empty tree"; return (ret.val);}
    
    # Select and align the data to the tree:
    d <- unique(d_colors_ag[ !is.na(d_colors_ag$exists_blue) & 
                               vapply(1:nrow(d_colors_ag), function(i) if(length(IVs) == 0) return (TRUE) else return (all(!is.na(d_colors_ag[i,IVs]))), logical(1)) & 
                               (d_colors_ag$glottocode %in% tree$tip.label), 
                             c("glottocode", "exists_blue", IVs) ]);
    d <- d[ !duplicated(d$glottocode), ]; # keep the first of potentially duplicated rows
    d <- as.data.frame(d); # make sure it is a data.frame
    d$exists_blue_num <- as.numeric(d$exists_blue == "yes"); 
    rownames(d) <- d$glottocode;
    d <- d[intersect(d$glottocode, tree$tip.label), ];
    tree <- drop.tip(tree, setdiff(tree$tip.label, d$glottocode), trim.internal=TRUE);
    d <- d[tree$tip.label,]; # make sure the tree and the data are identically ordered
    
    # Checks:
    if( is.null(tree) || !inherits(tree, "phylo") || nrow(d) == 0 ){ret.val$error <- "empty tree and data"; return (ret.val);}
    if( length(unique(d$exists_blue)) == 1 ){ret.val$error <- "blue is constant"; return (ret.val);}
    
    # Remove uniform IVs (avoid errors):
    IVs_informative <- IVs[ vapply(IVs, function(x) length(unique(d[,x])) > 1, logical(1)) ];
    if( is.null(IVs_informative) || length(IVs_informative) == 0 )
    {
      # Nothing to do
      return (ret.val);
    }
    
    # Fit flat models:
    if( do.flat && (do.pglmm || do.phyloglm) )
    {
      # glm:
      m_glm <- NULL;
      try(m_glm <- glm(formula(paste("exists_blue ~ ", ifelse(length(IVs_informative)==0,"1",""), paste0(IVs_informative,collapse=" + "))), data=d, family=binomial(link = "logit")), silent=TRUE);
      if( !is.null(m_glm) ) 
      {
        s <- summary(m_glm);
        ret.val$GLM.intercept    <- s$coefficients["(Intercept)","Estimate"]; 
        ret.val$GLM.intercept.se <- s$coefficients["(Intercept)","Std. Error"]; 
        ret.val$GLM.intercept.p  <- s$coefficients["(Intercept)","Pr(>|z|)"]; 
        for( x in IVs_informative )
        {
          ret.val[,paste0("GLM.",x)]       <- s$coefficients[grep(x,rownames(s$coefficients), fixed=TRUE),"Estimate"]; 
          ret.val[,paste0("GLM.",x,".se")] <- s$coefficients[grep(x,rownames(s$coefficients), fixed=TRUE),"Std. Error"]; 
          ret.val[,paste0("GLM.",x,".p")]  <- s$coefficients[grep(x,rownames(s$coefficients),fixed=TRUE),"Pr(>|z|)"]; 
        }
      }
    }
    
    # Method 1: binaryPGLMM:
    if( do.pglmm )
    {
      require(ape);
      ps_pglmm <- NULL;
      try(ps_pglmm <- binaryPGLMM(formula(paste("exists_blue_num ~ ", ifelse(length(IVs_informative)==0,"1",""), paste0(IVs_informative,collapse=" + "))), data=d, phy=tree), silent=TRUE);
      if( !is.null(ps_pglmm) ) 
      {
        ret.val$PGLMM.s2 <- ps_pglmm$s2; 
        ret.val$PGLMM.s2.p0 <- ps_pglmm$P.H0.s2; 
        ret.val$PGLMM.intercept    <- ps_pglmm$B["(Intercept)",1]; 
        ret.val$PGLMM.intercept.se <- ps_pglmm$B.se["(Intercept)",1]; 
        ret.val$PGLMM.intercept.p  <- ps_pglmm$B.pvalue["(Intercept)",1]; 
        for( x in IVs_informative )
        {
          ret.val[,paste0("PGLMM.",x)]       <- ps_pglmm$B       [grep(x,rownames(ps_pglmm$B),       fixed=TRUE),1]; 
          ret.val[,paste0("PGLMM.",x,".se")] <- ps_pglmm$B.se    [grep(x,rownames(ps_pglmm$B.se),    fixed=TRUE),1]; 
          ret.val[,paste0("PGLMM.",x,".p")]  <- ps_pglmm$B.pvalue[grep(x,rownames(ps_pglmm$B.pvalue),fixed=TRUE),1]; 
        }
      }
    }
    
    # Method 2: phyloglm :
    if( do.phyloglm )
    {
      require(phylolm);
      
      # IG10:
      ps_phyloglm <- NULL;
      suppressWarnings(try(ps_phyloglm <- phyloglm(formula(paste("exists_blue_num ~ ", ifelse(length(IVs_informative)==0,"1",""), paste0(IVs_informative,collapse=" + "))), data=d, phy=tree, method="logistic_IG10"), silent=TRUE));
      if( !is.null(ps_phyloglm) ) 
      {
        # Try to fit the null model as well:
        ps_phyloglm_0 <- NULL;
        suppressWarnings(try(ps_phyloglm_0 <- phyloglm(exists_blue_num ~ 1, data=d, phy=tree, method="logistic_IG10"), silent=TRUE));
        
        ps_phyloglm_s <- summary(ps_phyloglm);
        ret.val$IG10.alpha <- ps_phyloglm$alpha; ret.val$IG10.alphaWarn <- ps_phyloglm$alphaWarn;
        ret.val$IG10.AIC <- AIC(ps_phyloglm); if( !is.null(ps_phyloglm_0) ) ret.val$IG10.AIC0 <- AIC(ps_phyloglm_0);
        ret.val$IG10.intercept    <- ps_phyloglm_s$coefficients["(Intercept)","Estimate"]; 
        ret.val$IG10.intercept.se <- ps_phyloglm_s$coefficients["(Intercept)","StdErr"]; 
        ret.val$IG10.intercept.p  <- ps_phyloglm_s$coefficients["(Intercept)","p.value"];
        for( x in IVs_informative )
        {
          ret.val[,paste0("IG10.",x)]       <- ps_phyloglm_s$coefficients[grep(x,rownames(ps_phyloglm_s$coefficients),fixed=TRUE),"Estimate"]; 
          ret.val[,paste0("IG10.",x,".se")] <- ps_phyloglm_s$coefficients[grep(x,rownames(ps_phyloglm_s$coefficients),fixed=TRUE),"StdErr"]; 
          ret.val[,paste0("IG10.",x,".p")]  <- ps_phyloglm_s$coefficients[grep(x,rownames(ps_phyloglm_s$coefficients),fixed=TRUE),"p.value"]; 
        }
      }
      
      # MPLE:
      ps_phyloglm <- NULL;
      suppressWarnings(try(ps_phyloglm <- phyloglm(formula(paste("exists_blue_num ~ ", ifelse(length(IVs_informative)==0,"1",""), paste0(IVs_informative,collapse=" + "))), data=d, phy=tree, method="logistic_MPLE"), silent=TRUE));
      if( !is.null(ps_phyloglm) ) 
      {
        # Try to fit the null model as well:
        ps_phyloglm_0 <- NULL;
        suppressWarnings(try(ps_phyloglm_0 <- phyloglm(exists_blue_num ~ 1, data=d, phy=tree, method="logistic_MPLE"), silent=TRUE));
        
        ps_phyloglm_s <- summary(ps_phyloglm);
        ret.val$MPLE.alpha <- ps_phyloglm$alpha; ret.val$MPLE.alphaWarn <- ps_phyloglm$alphaWarn;
        ret.val$MPLE.AIC <- AIC(ps_phyloglm); if( !is.null(ps_phyloglm_0) ) ret.val$MPLE.AIC0 <- AIC(ps_phyloglm_0);
        ret.val$MPLE.intercept    <- ps_phyloglm_s$coefficients["(Intercept)","Estimate"]; 
        ret.val$MPLE.intercept.se <- ps_phyloglm_s$coefficients["(Intercept)","StdErr"]; 
        ret.val$MPLE.intercept.p  <- ps_phyloglm_s$coefficients["(Intercept)","p.value"];
        for( x in IVs_informative )
        {
          ret.val[,paste0("MPLE.",x)]       <- ps_phyloglm_s$coefficients[grep(x,rownames(ps_phyloglm_s$coefficients),fixed=TRUE),"Estimate"]; 
          ret.val[,paste0("MPLE.",x,".se")] <- ps_phyloglm_s$coefficients[grep(x,rownames(ps_phyloglm_s$coefficients),fixed=TRUE),"StdErr"]; 
          ret.val[,paste0("MPLE.",x,".p")]  <- ps_phyloglm_s$coefficients[grep(x,rownames(ps_phyloglm_s$coefficients),fixed=TRUE),"p.value"]; 
        }
      }
    }
    
    # Method 3: brms:
    if( do.brms )
    {
      require(brms);
      
      if( do.flat )
      {
        # Fit the flat brms model:
        m_brms <- NULL;
        capture.output(m_brms <- brm(formula(paste("exists_blue_num ~ ", ifelse(length(IVs_informative)==0,"1",""), paste0(IVs_informative,collapse=" + "))), 
                                     data=d,
                                     family=bernoulli("logit"),
                                     prior = c(prior(student_t(3, 0, 2.5), class="Intercept"),
                                               prior(student_t(3, 0, 2.5), class="b")),
                                     save_pars=save_pars(all=TRUE), # needed for Bayes factors
                                     sample_prior=TRUE,  # needed for hypotheses tests
                                     cores=ifelse(do.brms.parallel, brms_ncores, 1), iter=6000, warmup=2000, thin=2, control=list(adapt_delta=0.999, max_treedepth=15),
                                     silent=TRUE, refresh=0),
                       type="message");
        #summary(m_brms); mcmc_plot(m_brms, type="trace"); mcmc_plot(m_brms);
        fe <- fixef(m_brms);
        (h_brms <- brms::hypothesis(m_brms, paste0(rownames(fe)[ grep(IVs_informative, rownames(fe), fixed=TRUE) ],"=0")));
        (hdi_brms89 <- hdi(m_brms, ci=0.89));
        suppressWarnings(rope_brms89 <- rope(m_brms, ci=0.89, verbose=FALSE));
        (hdi_brms95 <- hdi(m_brms, ci=0.95));
        suppressWarnings(rope_brms95 <- rope(m_brms, ci=0.95, verbose=FALSE));
        
        # Store the results:
        if( !is.null(m_brms) ) 
        {
          ret.val$BRMSf.intercept        <- fe["Intercept", "Estimate"];
          ret.val$BRMSf.intercept.hdi89  <- sprintf("[%.2f, %.2f]", hdi_brms89$CI_low[ hdi_brms89$Parameter == "b_Intercept" ], hdi_brms89$CI_high[ hdi_brms89$Parameter == "b_Intercept" ]); 
          ret.val$BRMSf.intercept.rope89 <- rope_brms89$ROPE_Percentage[ rope_brms89$Parameter == "b_Intercept" ]; 
          ret.val$BRMSf.intercept.hdi95  <- sprintf("[%.2f, %.2f]", hdi_brms95$CI_low[ hdi_brms95$Parameter == "b_Intercept" ], hdi_brms95$CI_high[ hdi_brms95$Parameter == "b_Intercept" ]); 
          ret.val$BRMSf.intercept.rope95 <- rope_brms95$ROPE_Percentage[ rope_brms95$Parameter == "b_Intercept" ]; 
          for( x in IVs_informative )
          {
            ret.val[,paste0("BRMSf.",x)]           <- fe[grep(x, rownames(fe), fixed=TRUE), "Estimate"];
            ret.val[,paste0("BRMSf.",x,".hdi89")]  <- sprintf("[%.2f, %.2f]", hdi_brms89$CI_low[ grep(x,hdi_brms89$Parameter,fixed=TRUE) ], hdi_brms89$CI_high[ grep(x,hdi_brms89$Parameter,fixed=TRUE) ]); 
            ret.val[,paste0("BRMSf.",x,".rope89")] <- rope_brms89$ROPE_Percentage[ grep(x,rope_brms89$Parameter,fixed=TRUE) ]; 
            ret.val[,paste0("BRMSf.",x,".hdi95")]  <- sprintf("[%.2f, %.2f]", hdi_brms95$CI_low[ grep(x,hdi_brms95$Parameter,fixed=TRUE) ], hdi_brms95$CI_high[ grep(x,hdi_brms95$Parameter,fixed=TRUE) ]); 
            ret.val[,paste0("BRMSf.",x,".rope95")] <- rope_brms95$ROPE_Percentage[ grep(x,rope_brms95$Parameter,fixed=TRUE) ]; 
            ret.val[,paste0("BRMSf.",x,".p0")]     <- h_brms$hypothesis$Post.Prob[ grep(x,h_brms$hypothesis$Hypothesis,fixed=TRUE) ];
            ret.val[,paste0("BRMSf.",x,".p0star")] <- h_brms$hypothesis$Star[ grep(x,h_brms$hypothesis$Hypothesis,fixed=TRUE) ];
          }
        }
      }
      
      # Phylogeentic variance-covariance matrix:
      A <- ape::vcv.phylo(tree);
      
      # Full model:
      ps_brms <- NULL;
      capture.output(ps_brms <- brm(formula(paste("exists_blue_num ~ ", ifelse(length(IVs_informative)==0,"1",""), paste0(IVs_informative,collapse=" + "), " + (1 | gr(glottocode, cov=A))")), 
                                    data=d,
                                    family=bernoulli("logit"),
                                    data2=list(A=A),
                                    prior = c(prior(student_t(3, 0, 2.5), class="Intercept"),
                                              prior(student_t(3, 0, 2.5), class="b"),
                                              prior(student_t(3, 0, 20), class="sd")),
                                    save_pars=save_pars(all=TRUE), # needed for Bayes factors
                                    sample_prior=TRUE,  # needed for hypotheses tests
                                    cores=ifelse(do.brms.parallel, brms_ncores, 1), iter=6000, warmup=2000, thin=2, control=list(adapt_delta=0.999, max_treedepth=15),
                                    silent=TRUE, refresh=0),
                     type="message");
      #summary(ps_brms); mcmc_plot(ps_brms, type="trace"); mcmc_plot(ps_brms);
      fe <- fixef(ps_brms);
      (h_brms <- brms::hypothesis(ps_brms, paste0(rownames(fe)[ grep(IVs_informative, rownames(fe), fixed=TRUE) ],"=0")));
      (hdi_brms89 <- hdi(ps_brms, ci=0.89));
      suppressWarnings(rope_brms89 <- rope(ps_brms, ci=0.89, verbose=FALSE));
      (hdi_brms95 <- hdi(ps_brms, ci=0.95));
      suppressWarnings(rope_brms95 <- rope(ps_brms, ci=0.95, verbose=FALSE));
      
      if( do.brms.cmp0 ) 
      {
        suppressWarnings(ps_brms <- brms_fit_indices(ps_brms, verbose=FALSE, do.parallel=do.brms.parallel));
        
        # Null model:
        ps_brms0 <- NULL;
        capture.output(ps_brms0 <- brm(exists_blue_num ~ 1 + (1 | gr(glottocode, cov=A)), 
                                       data=d,
                                       family=bernoulli("logit"),
                                       data2=list(A=A),
                                       prior = c(prior(student_t(3, 0, 2.5), class="Intercept"),
                                                 prior(student_t(3, 0, 20), class="sd")),
                                       save_pars=save_pars(all=TRUE), # needed for Bayes factors
                                       sample_prior=TRUE,  # needed for hypotheses tests
                                       cores=ifelse(do.brms.parallel, brms_ncores, 1), iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.999, max_treedepth=15),
                                       silent=TRUE, refresh=0),
                       type="message");
        suppressWarnings(ps_brms0 <- brms_fit_indices(ps_brms0, verbose=FALSE, do.parallel=do.brms.parallel));
        
        # Compare full and null:
        suppressWarnings(cmp_brms_0 <- brms_compare_models(ps_brms, ps_brms0, "full", "null", print_results=FALSE));
      }
      
      # Store the results:
      if( !is.null(ps_brms) ) 
      {
        ret.val$BRMS.intercept        <- fe["Intercept", "Estimate"];
        ret.val$BRMS.intercept.hdi89  <- sprintf("[%.2f, %.2f]", hdi_brms89$CI_low[ hdi_brms89$Parameter == "b_Intercept" ], hdi_brms89$CI_high[ hdi_brms89$Parameter == "b_Intercept" ]); 
        ret.val$BRMS.intercept.rope89 <- rope_brms89$ROPE_Percentage[ rope_brms89$Parameter == "b_Intercept" ]; 
        ret.val$BRMS.intercept.hdi95  <- sprintf("[%.2f, %.2f]", hdi_brms95$CI_low[ hdi_brms95$Parameter == "b_Intercept" ], hdi_brms95$CI_high[ hdi_brms95$Parameter == "b_Intercept" ]); 
        ret.val$BRMS.intercept.rope95 <- rope_brms95$ROPE_Percentage[ rope_brms95$Parameter == "b_Intercept" ]; 
        if( do.brms.cmp0 )
        {
          ret.val$BRMS.vs0.BF        <- cmp_brms_0$BF; 
          ret.val$BRMS.vs0.BFinterp  <- cmp_brms_0$BF_interpretation; 
          ret.val$BRMS.vs0.BF.better <- ifelse(cmp_brms_0$BF < 1/3, "-", ifelse(cmp_brms_0$BF <= 3, "≈", ifelse(cmp_brms_0$BF <= 10, "+", "++")));
          
          ret.val$BRMS.vs0.LOO.diff   <- cmp_brms_0$LOO["full","elpd_diff"] - cmp_brms_0$LOO["null","elpd_diff"];     
          ret.val$BRMS.vs0.LOO.se     <- abs(cmp_brms_0$LOO["full","se_diff"] - cmp_brms_0$LOO["null","se_diff"]);
          ret.val$BRMS.vs0.LOO.better <- ifelse(abs(ret.val$BRMS.vs0.LOO.diff) < 4 || abs(ret.val$BRMS.vs0.LOO.diff) < ret.val$BRMS.vs0.LOO.se, "≈", 
                                                ifelse(ret.val$BRMS.vs0.LOO.diff > 0, "-",
                                                       ifelse(abs(ret.val$BRMS.vs0.LOO.diff) < 2*ret.val$BRMS.vs0.LOO.se, "+", "++")));
          
          ret.val$BRMS.vs0.WAIC.diff   <- cmp_brms_0$WAIC["full","elpd_diff"] - cmp_brms_0$WAIC["null","elpd_diff"];   
          ret.val$BRMS.vs0.WAIC.se     <- abs(cmp_brms_0$WAIC["full","se_diff"] - cmp_brms_0$WAIC["null","se_diff"]);
          ret.val$BRMS.vs0.WAIC.better <- ifelse(abs(ret.val$BRMS.vs0.WAIC.diff) < 4 || abs(ret.val$BRMS.vs0.WAIC.diff) < ret.val$BRMS.vs0.WAIC.se, "≈", 
                                                 ifelse(ret.val$BRMS.vs0.WAIC.diff > 0, "-",
                                                        ifelse(abs(ret.val$BRMS.vs0.WAIC.diff) < 2*ret.val$BRMS.vs0.WAIC.se, "+", "++")));
          
          if( !is.null(cmp_brms_0$KFOLD) && !is.na(cmp_brms_0$KFOLD) )
          {
            ret.val$BRMS.vs0.KFOLD.diff   <- cmp_brms_0$KFOLD["full","elpd_diff"] - cmp_brms_0$KFOLD["null","elpd_diff"]; 
            ret.val$BRMS.vs0.KFOLD.se     <- abs(cmp_brms_0$KFOLD["full","se_diff"] - cmp_brms_0$KFOLD["null","se_diff"]);
            ret.val$BRMS.vs0.KFOLD.better <- ifelse(abs(ret.val$BRMS.vs0.KFOLD.diff) < 4 || abs(ret.val$BRMS.vs0.KFOLD.diff) < ret.val$BRMS.vs0.KFOLD.se, "≈", 
                                                    ifelse(ret.val$BRMS.vs0.KFOLD.diff > 0, "-",
                                                           ifelse(abs(ret.val$BRMS.vs0.KFOLD.diff) < 2*ret.val$BRMS.vs0.KFOLD.se, "+", "++")));
          }
          
          ret.val$BRMS.vs0.WAIC.weight        <- cmp_brms_0$model_weights_WAIC["full"];
          ret.val$BRMS.vs0.WAIC.weight.better <- ifelse(cmp_brms_0$model_weights_WAIC["full"] <= 0.5, "-", "+");
        }
        for( x in IVs_informative )
        {
          ret.val[,paste0("BRMS.",x)]           <- fe[grep(x, rownames(fe), fixed=TRUE), "Estimate"];
          ret.val[,paste0("BRMS.",x,".hdi89")]  <- sprintf("[%.2f, %.2f]", hdi_brms89$CI_low[ grep(x,hdi_brms89$Parameter,fixed=TRUE) ], hdi_brms89$CI_high[ grep(x,hdi_brms89$Parameter,fixed=TRUE) ]); 
          ret.val[,paste0("BRMS.",x,".rope89")] <- rope_brms89$ROPE_Percentage[ grep(x,rope_brms89$Parameter,fixed=TRUE) ]; 
          ret.val[,paste0("BRMS.",x,".hdi95")]  <- sprintf("[%.2f, %.2f]", hdi_brms95$CI_low[ grep(x,hdi_brms95$Parameter,fixed=TRUE) ], hdi_brms95$CI_high[ grep(x,hdi_brms95$Parameter,fixed=TRUE) ]); 
          ret.val[,paste0("BRMS.",x,".rope95")] <- rope_brms95$ROPE_Percentage[ grep(x,rope_brms95$Parameter,fixed=TRUE) ]; 
          ret.val[,paste0("BRMS.",x,".p0")]     <- h_brms$hypothesis$Post.Prob[ grep(x,h_brms$hypothesis$Hypothesis,fixed=TRUE) ];
          ret.val[,paste0("BRMS.",x,".p0star")] <- h_brms$hypothesis$Star[ grep(x,h_brms$hypothesis$Hypothesis,fixed=TRUE) ];
        }
      }
    }
    
    
    # Return it:
    return (ret.val);
  }
  
  IVs_to_test <- c("UV_mean_r", "UV_sd_r", 
                   "longitude", "latitude", 
                   "log_popSize_ethno", "subsistence", 
                   "dist2water_r", "dist2rivers_r", "dist2ocean_r","dist2lakes_r", 
                   "clim_PC1_r", "clim_PC2_r", "clim_PC3_r", "hum_median", "hum_IQR");
  for(iv in IVs_to_test)
  {
    ret.val.name <- paste0("phyreg__",iv,"__blue");
    phyreg__blue_varnames <- c(phyreg__blue_varnames, ret.val.name);
    file_name <- paste0("./cached_results/phyreg__",iv,"__blue.RData");
    if( !file.exists(file_name) )
    {
      cat(paste0("\n** Testing IV '",iv,"' (",which(IVs_to_test == iv)," of ",length(IVs_to_test),")... ***\n\n"));
    
      ret.val <- NULL;

      # Afro-Asiatic:
      cat("  - Fitting phylogenetic regression for Afro-Asiatic (1/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$afro_asiatic$glottolog$original,    iv, "Afro-Asiatic", "Glottolog (original)",    do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$afro_asiatic$glottolog$exponential, iv, "Afro-Asiatic", "Glottolog (exponential)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$afro_asiatic$glottolog$ultrametric, iv, "Afro-Asiatic", "Glottolog (ultrametric)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$afro_asiatic$gerhard,               iv, "Afro-Asiatic", "Jäger (2018)", do.brms=TRUE));
      
      # Atlantic-Congo:
      cat("  - Fitting phylogenetic regression for Atlantic-Congo (2/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$atlantic_congo$glottolog$original,    iv, "Atlantic-Congo", "Glottolog (original)",    do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$atlantic_congo$glottolog$exponential, iv, "Atlantic-Congo", "Glottolog (exponential)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$atlantic_congo$glottolog$ultrametric, iv, "Atlantic-Congo", "Glottolog (ultrametric)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$atlantic_congo$gerhard,               iv, "Atlantic-Congo", "Jäger (2018)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$bantu$mcmc$summary, iv, "Bantu", "MCMC (summary)", do.brms=TRUE));
      ret.val <- rbind(ret.val, do.call(rbind, mclapply(trees$bantu$mcmc$posterior, function(x) .phylo.regress.blue(x, iv, "Bantu", "MCMC (posterior)", do.brms=FALSE), mc.cores=max(1,brms_ncores-1))));
      
      # Austroasiatic:
      cat("  - Fitting phylogenetic regression for Austroasiatic (3/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$austroasiatic$glottolog$original,    iv, "Austroasiatic", "Glottolog (original)",    do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$austroasiatic$glottolog$exponential, iv, "Austroasiatic", "Glottolog (exponential)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$austroasiatic$glottolog$ultrametric, iv, "Austroasiatic", "Glottolog (ultrametric)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$austroasiatic$gerhard,               iv, "Austroasiatic", "Jäger (2018)", do.brms=TRUE));
      
      # Austronesian:
      cat("  - Fitting phylogenetic regression for Austronesian (4/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$austronesian$glottolog$original,    iv, "Austronesian", "Glottolog (original)",    do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$austronesian$glottolog$exponential, iv, "Austronesian", "Glottolog (exponential)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$austronesian$glottolog$ultrametric, iv, "Austronesian", "Glottolog (ultrametric)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$austronesian$gerhard,               iv, "Austronesian", "Jäger (2018)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$austronesian$mcmc$summary,          iv, "Austronesian", "MCMC (summary)",          do.brms=TRUE));
      ret.val <- rbind(ret.val, do.call(rbind, mclapply(trees$austronesian$mcmc$posterior, function(x) .phylo.regress.blue(x, iv, "Austronesian", "MCMC (posterior)", do.brms=FALSE), mc.cores=max(1,brms_ncores-1))));
      
      # Hmong-Mien:
      cat("  - Fitting phylogenetic regression for Hmong-Mien (5/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$hmong_mien$glottolog$original,    iv, "Hmong-Mien", "Glottolog (original)",    do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$hmong_mien$glottolog$exponential, iv, "Hmong-Mien", "Glottolog (exponential)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$hmong_mien$glottolog$ultrametric, iv, "Hmong-Mien", "Glottolog (ultrametric)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$hmong_mien$gerhard,               iv, "Hmong-Mien", "Jäger (2018)", do.brms=TRUE));
      
      # Indo-European:
      cat("  - Fitting phylogenetic regression for Indo-European (6/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$indo_european$glottolog$original,    iv, "Indo-European", "Glottolog (original)",    do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$indo_european$glottolog$exponential, iv, "Indo-European", "Glottolog (exponential)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$indo_european$glottolog$ultrametric, iv, "Indo-European", "Glottolog (ultrametric)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$indo_european$gerhard,               iv, "Indo-European", "Jäger (2018)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$indo_european$mcmc$summary, iv, "Indo-European", "MCMC (summary)", do.brms=TRUE));
      ret.val <- rbind(ret.val, do.call(rbind, mclapply(trees$indo_european$mcmc$posterior, function(x) .phylo.regress.blue(x, iv, "Indo-European", "MCMC (posterior)", do.brms=FALSE), mc.cores=max(1,brms_ncores-1))));
      
      # Nakh-Daghestanian:
      cat("  - Fitting phylogenetic regression for Hmong-Mien (7/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$nakh_daghestanian$glottolog$original,    iv, "Nakh-Daghestanian", "Glottolog (original)",    do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$nakh_daghestanian$glottolog$exponential, iv, "Nakh-Daghestanian", "Glottolog (exponential)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$nakh_daghestanian$glottolog$ultrametric, iv, "Nakh-Daghestanian", "Glottolog (ultrametric)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$nakh_daghestanian$gerhard,               iv, "Nakh-Daghestanian", "Jäger (2018)", do.brms=TRUE));
      
      # Pama-Nyungan:
      cat("  - Fitting phylogenetic regression for Pama-Nyungan (8/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$pama_nyungan$glottolog$original,    iv, "Pama-Nyungan", "Glottolog (original)",    do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$pama_nyungan$glottolog$exponential, iv, "Pama-Nyungan", "Glottolog (exponential)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$pama_nyungan$glottolog$ultrametric, iv, "Pama-Nyungan", "Glottolog (ultrametric)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$pama_nyungan$gerhard,               iv, "Pama-Nyungan", "Jäger (2018)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$pama_nyungan$mcmc$summary,          iv, "Pama-Nyungan", "MCMC (summary)",          do.brms=TRUE));
      ret.val <- rbind(ret.val, do.call(rbind, mclapply(trees$pama_nyungan$mcmc$posterior, function(x) .phylo.regress.blue(x, iv, "Pama-Nyungan", "MCMC (posterior)", do.brms=FALSE), mc.cores=max(1,brms_ncores-1))));
      
      # Pano-Tacanan:
      cat("  - Fitting phylogenetic regression for Pano-Tacanan (9/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$pano_tacanan$glottolog$original,    iv, "Pano-Tacanan", "Glottolog (original)",    do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$pano_tacanan$glottolog$exponential, iv, "Pano-Tacanan", "Glottolog (exponential)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$pano_tacanan$glottolog$ultrametric, iv, "Pano-Tacanan", "Glottolog (ultrametric)", do.brms=TRUE));
      
      # Sino-Tibetan:
      cat("  - Fitting phylogenetic regression for Sino-Tibetan (10/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$sino_tibetan$glottolog$original,    iv, "Sino-Tibetan", "Glottolog (original)",    do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$sino_tibetan$glottolog$exponential, iv, "Sino-Tibetan", "Glottolog (exponential)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$sino_tibetan$glottolog$ultrametric, iv, "Sino-Tibetan", "Glottolog (ultrametric)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$sino_tibetan$gerhard,               iv, "Sino-Tibetan", "Jäger (2018)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$sino_tibetan$zhang,                 iv, "Sino-Tibetan", "Zhang et al. (2019)", do.brms=TRUE));
      
      # Tai-Kadai:
      cat("  - Fitting phylogenetic regression for Tai-Kadai (11/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$tai_kadai$glottolog$original,    iv, "Tai-Kadai", "Glottolog (original)",    do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$tai_kadai$glottolog$exponential, iv, "Tai-Kadai", "Glottolog (exponential)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$tai_kadai$glottolog$ultrametric, iv, "Tai-Kadai", "Glottolog (ultrametric)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$tai_kadai$gerhard,               iv, "Tai-Kadai", "Jäger (2018)", do.brms=TRUE));
      
      # Timor-Alor-Pantar:
      cat("  - Fitting phylogenetic regression for Timor-Alor-Pantar (12/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$timor_alor_pantar$glottolog$original,    iv, "Timor-Alor-Pantar", "Glottolog (original)",    do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$timor_alor_pantar$glottolog$exponential, iv, "Timor-Alor-Pantar", "Glottolog (exponential)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$timor_alor_pantar$glottolog$ultrametric, iv, "Timor-Alor-Pantar", "Glottolog (ultrametric)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$timor_alor_pantar$gerhard,               iv, "Timor-Alor-Pantar", "Jäger (2018)", do.brms=TRUE));
      
      # Turkic:
      cat("  - Fitting phylogenetic regression for Turkic (13/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$turkic$glottolog$original,    iv, "Turkic", "Glottolog (original)",    do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$turkic$glottolog$exponential, iv, "Turkic", "Glottolog (exponential)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$turkic$glottolog$ultrametric, iv, "Turkic", "Glottolog (ultrametric)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$turkic$mcmc$summary,          iv, "Turkic", "MCMC (summary)",          do.brms=TRUE));
      ret.val <- rbind(ret.val, do.call(rbind, mclapply(trees$turkic$mcmc$posterior, function(x) .phylo.regress.blue(x, iv, "Turkic", "MCMC (posterior)", do.brms=FALSE), mc.cores=max(1,brms_ncores-1))));
      
      # Uralic:
      cat("  - Fitting phylogenetic regression for Uralic (14/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$uralic$glottolog$original,    iv, "Uralic", "Glottolog (original)",    do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$uralic$glottolog$exponential, iv, "Uralic", "Glottolog (exponential)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$uralic$glottolog$ultrametric, iv, "Uralic", "Glottolog (ultrametric)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$uralic$gerhard,               iv, "Uralic", "Jäger (2018)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$uralic$mcmc$summary,          iv, "Uralic", "MCMC (summary)",          do.brms=TRUE));
      ret.val <- rbind(ret.val, do.call(rbind, mclapply(trees$uralic$mcmc$posterior, function(x) .phylo.regress.blue(x, iv, "Uralic", "MCMC (posterior)", do.brms=FALSE), mc.cores=max(1,brms_ncores-1))));
      
      # World:
      cat("  - Fitting phylogenetic regression for World (15/15)...\n");
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$world$gerhard, iv, "World", "Jäger (2018)", do.brms=TRUE));
      ret.val <- rbind(ret.val, .phylo.regress.blue(trees$world$betal22, iv, "World", "Bouckaert et al. (2022)", do.brms=TRUE));
      
      # Rename and save it:
      assign(ret.val.name, ret.val);
      
      saveRDS(get(ret.val.name), file=file_name, compress="xz");
      
      gc(); # force garbage collection!
      
      #### Force stopping as the temp folder gets clogged by .so files (in Linux) probably from brms/stan and it also goes over the limit of loaded DLLs
      # so, restart the whole session manually and continue :( 
      #stop(">>> Restart the session and come back here...");
      
    } else
    {
      assign(ret.val.name, readRDS(file_name));
    } 
  }
} 
```

```{r}
# Summarize and plot phylogeentic regressions for a given IV:
#truncate.CIs <- 20;
.summarize_plot_phyreg <- function(IV)
{
  require(forcats);
  tmp <- get(paste0("phyreg__",IV,"__blue"));
  tmp$family2 <- tmp$family;
  #tmp$family2[ tmp$family2 == "World" & tmp$tree == "Jäger (2018)" ] <- "WJ18";
  #tmp$family2[ tmp$family2 == "World" & tmp$tree == "Bouckaert et al. (2022)" ] <- "WB22";
  tmp$family2 <- forcats::fct_collapse(tmp$family2, "Atlantic-Congo/Bantu" = c("Atlantic-Congo", "Bantu")); # collapse Atlantic-Congo and Bantu
  tmp$family2 <- forcats::fct_recode(tmp$family2, 
                                     "AA"="Afro-Asiatic", 
                                     "AC/B"="Atlantic-Congo/Bantu",
                                     "Aas"="Austroasiatic",
                                     "Aan"="Austronesian",
                                     "HM"="Hmong-Mien",
                                     "IE"="Indo-European",
                                     "ND"="Nakh-Daghestanian",
                                     "PN"="Pama-Nyungan",
                                     "PT"="Pano-Tacanan",
                                     "ST"="Sino-Tibetan",
                                     "TK"="Tai-Kadai",
                                     "TAP"="Timor-Alor-Pantar",
                                     "T"="Turkic",
                                     "U"="Uralic");
  tmp$tree[ tmp$tree %in% c("Zhang et al. (2019)", "Bouckaert et al. (2022)") ] <- "MCMC (summary)"; # consider the MCC tree of Zhang et al. (2019) and of Bouckaert et al. (2022) as MCMC (summary) for plotting purposes
  tmp$tree2 <- factor(tmp$tree, 
                      levels=c("Glottolog (original)", "Glottolog (exponential)", "Glottolog (ultrametric)", "MCMC (summary)", "MCMC (posterior)", "Jäger (2018)"),
                      labels=c("G(o)", "G(x)", "G(u)", "M(s)", "M(p)", "J18")); # shorter names for the trees
  tmp$GLM <- tmp[,paste0("GLM.",IV)]; 
  tmp$GLM.lo <- (tmp[,paste0("GLM.",IV)] - tmp[,paste0("GLM.",IV,".se")]); tmp$GLM.lo2 <- (tmp[,paste0("GLM.",IV)] - 2*tmp[,paste0("GLM.",IV,".se")]);
  tmp$GLM.hi <- (tmp[,paste0("GLM.",IV)] + tmp[,paste0("GLM.",IV,".se")]); tmp$GLM.hi2 <- (tmp[,paste0("GLM.",IV)] + 2*tmp[,paste0("GLM.",IV,".se")]);
  tmp$GLM.signif <- (tmp[,paste0("GLM.",IV,".p")] < 0.05); 
  tmp$PGLMM <- tmp[,paste0("PGLMM.",IV)]; 
  tmp$PGLMM.lo <- (tmp[,paste0("PGLMM.",IV)] - tmp[,paste0("PGLMM.",IV,".se")]); tmp$PGLMM.lo2 <- (tmp[,paste0("PGLMM.",IV)] - 2*tmp[,paste0("PGLMM.",IV,".se")]);
  tmp$PGLMM.hi <- (tmp[,paste0("PGLMM.",IV)] + tmp[,paste0("PGLMM.",IV,".se")]); tmp$PGLMM.hi2 <- (tmp[,paste0("PGLMM.",IV)] + 2*tmp[,paste0("PGLMM.",IV,".se")]);
  tmp$PGLMM.signif <- (tmp[,paste0("PGLMM.",IV,".p")] < 0.05); 
  tmp$IG10 <- tmp[,paste0("IG10.",IV)]; 
  tmp$IG10.lo <- (tmp[,paste0("IG10.",IV)] - tmp[,paste0("IG10.",IV,".se")]); tmp$IG10.lo2 <- (tmp[,paste0("IG10.",IV)] - 2*tmp[,paste0("IG10.",IV,".se")]);
  tmp$IG10.hi <- (tmp[,paste0("IG10.",IV)] + tmp[,paste0("IG10.",IV,".se")]); tmp$IG10.hi2 <- (tmp[,paste0("IG10.",IV)] + 2*tmp[,paste0("IG10.",IV,".se")]);
  tmp$IG10.signif <- (tmp[,paste0("IG10.",IV,".p")] < 0.05); 
  tmp$MPLE <- tmp[,paste0("MPLE.",IV)]; 
  tmp$MPLE.lo <- (tmp[,paste0("MPLE.",IV)] - tmp[,paste0("MPLE.",IV,".se")]); tmp$MPLE.lo2 <- (tmp[,paste0("MPLE.",IV)] - 2*tmp[,paste0("MPLE.",IV,".se")]);
  tmp$MPLE.hi <- (tmp[,paste0("MPLE.",IV)] + tmp[,paste0("MPLE.",IV,".se")]); tmp$MPLE.hi2 <- (tmp[,paste0("MPLE.",IV)] + 2*tmp[,paste0("MPLE.",IV,".se")]);
  tmp$MPLE.signif <- (tmp[,paste0("MPLE.",IV,".p")] < 0.05);  
  tmp$BRMSf <- tmp[,paste0("BRMSf.",IV)]; 
  tmp$BRMSf.lo  <- vapply(tmp[,paste0("BRMSf.",IV,".hdi89")], function(s) ifelse(is.na(s), NA, as.numeric(trimws(strsplit(substring(s,2,nchar(s)-1), ",", fixed=TRUE)[[1]][1]))), numeric(1)); 
  tmp$BRMSf.lo2 <- vapply(tmp[,paste0("BRMSf.",IV,".hdi95")], function(s) ifelse(is.na(s), NA, as.numeric(trimws(strsplit(substring(s,2,nchar(s)-1), ",", fixed=TRUE)[[1]][1]))), numeric(1)); 
  tmp$BRMSf.hi  <- vapply(tmp[,paste0("BRMSf.",IV,".hdi89")], function(s) ifelse(is.na(s), NA, as.numeric(trimws(strsplit(substring(s,2,nchar(s)-1), ",", fixed=TRUE)[[1]][2]))), numeric(1)); 
  tmp$BRMSf.hi2 <- vapply(tmp[,paste0("BRMSf.",IV,".hdi95")], function(s) ifelse(is.na(s), NA, as.numeric(trimws(strsplit(substring(s,2,nchar(s)-1), ",", fixed=TRUE)[[1]][2]))), numeric(1));
  tmp$BRMSf.signif <- (tmp[,paste0("BRMSf.",IV,".p0star")] != ""); 
  tmp$BRMS <- tmp[,paste0("BRMS.",IV)]; 
  tmp$BRMS.lo  <- vapply(tmp[,paste0("BRMS.",IV,".hdi89")], function(s) ifelse(is.na(s), NA, as.numeric(trimws(strsplit(substring(s,2,nchar(s)-1), ",", fixed=TRUE)[[1]][1]))), numeric(1)); 
  tmp$BRMS.lo2 <- vapply(tmp[,paste0("BRMS.",IV,".hdi95")], function(s) ifelse(is.na(s), NA, as.numeric(trimws(strsplit(substring(s,2,nchar(s)-1), ",", fixed=TRUE)[[1]][1]))), numeric(1)); 
  tmp$BRMS.hi  <- vapply(tmp[,paste0("BRMS.",IV,".hdi89")], function(s) ifelse(is.na(s), NA, as.numeric(trimws(strsplit(substring(s,2,nchar(s)-1), ",", fixed=TRUE)[[1]][2]))), numeric(1)); 
  tmp$BRMS.hi2 <- vapply(tmp[,paste0("BRMS.",IV,".hdi95")], function(s) ifelse(is.na(s), NA, as.numeric(trimws(strsplit(substring(s,2,nchar(s)-1), ",", fixed=TRUE)[[1]][2]))), numeric(1));
  tmp$BRMS.signif <- (tmp[,paste0("BRMS.",IV,".p0star")] != ""); 
  tmp <- tmp[,c("family", "tree", "family2", "tree2", "error", 
                "GLM",   "GLM.lo",   "GLM.lo2",   "GLM.hi",   "GLM.hi2",   "GLM.signif", 
                "PGLMM", "PGLMM.lo", "PGLMM.lo2", "PGLMM.hi", "PGLMM.hi2", "PGLMM.signif", 
                "IG10",  "IG10.lo",  "IG10.lo2",  "IG10.hi",  "IG10.hi2",  "IG10.signif", 
                "MPLE",  "MPLE.lo",  "MPLE.lo2",  "MPLE.hi",  "MPLE.hi2",  "MPLE.signif",
                "BRMSf", "BRMSf.lo", "BRMSf.lo2", "BRMSf.hi", "BRMSf.hi2", "BRMSf.signif",
                "BRMS",  "BRMS.lo",  "BRMS.lo2",  "BRMS.hi",  "BRMS.hi2",  "BRMS.signif")]; # keep only the columns we actually need...
  tmp1 <- rbind(tmp[,c("family", "tree", "family2", "tree2", "error", 
                       "GLM",   "GLM.lo",   "GLM.lo2",   "GLM.hi",   "GLM.hi2",   "GLM.signif")],
                setNames(tmp[,c("family", "tree", "family2", "tree2", "error",
                                "PGLMM", "PGLMM.lo", "PGLMM.lo2", "PGLMM.hi", "PGLMM.hi2", "PGLMM.signif")], names(tmp)[1:11]),
                setNames(tmp[,c("family", "tree", "family2", "tree2", "error", 
                                "IG10", "IG10.lo", "IG10.lo2", "IG10.hi", "IG10.hi2", "IG10.signif")], names(tmp)[1:11]),
                setNames(tmp[,c("family", "tree", "family2", "tree2", "error", 
                                "MPLE", "MPLE.lo", "MPLE.lo2", "MPLE.hi", "MPLE.hi2", "MPLE.signif")], names(tmp)[1:11]),
                setNames(tmp[,c("family", "tree", "family2", "tree2", "error", 
                                "BRMSf", "BRMSf.lo", "BRMSf.lo2", "BRMSf.hi", "BRMSf.hi2", "BRMSf.signif")], names(tmp)[1:11]),
                setNames(tmp[,c("family", "tree", "family2", "tree2", "error", 
                                "BRMS", "BRMS.lo", "BRMS.lo2", "BRMS.hi", "BRMS.hi2", "BRMS.signif")], names(tmp)[1:11]));
  tmp1$measure <- factor(rep(c("GLM", "PGLMM", "IG10", "MPLE", "BRMSf", "BRMS"), each=nrow(tmp)), levels=c("GLM", "PGLMM", "IG10", "MPLE", "BRMSf", "BRMS"));
  names(tmp1)[6:11] <- c("estimate", "lo", "lo2", "hi", "hi2", "signif");
  tmp1$signif <- factor(ifelse(is.na(tmp1$signif), "n/a", ifelse(tmp1$signif, "yes", "no")), levels=c("yes", "no", "n/a"));
  #if( !is.na(truncate.estimate) )
  #{
  #  if( any(s <- (!is.na(tmp1$estimate) & abs(tmp1$estimate) > truncate.estimate)) ) tmp1$estimate[s] <- NA;
  #}
  #if( !is.na(truncate.CIs) )
  #{
  #  if( any(s <- (!is.na(tmp1$lo)  & abs(tmp1$lo)  > truncate.CIs)) ) tmp1$lo[s]  <- ifelse(is.na(tmp1$estimate[s]), -truncate.CIs, pmin(-truncate.CIs, tmp1$estimate[s]-1));
  #  if( any(s <- (!is.na(tmp1$lo2) & abs(tmp1$lo2) > truncate.CIs)) ) tmp1$lo2[s] <- ifelse(is.na(tmp1$estimate[s]), -truncate.CIs, pmin(-truncate.CIs, tmp1$estimate[s]-1));
  #  if( any(s <- (!is.na(tmp1$hi)  & abs(tmp1$hi)  > truncate.CIs)) ) tmp1$hi[s]  <- ifelse(is.na(tmp1$estimate[s]),  truncate.CIs, pmax( truncate.CIs, tmp1$estimate[s]+1));
  #  if( any(s <- (!is.na(tmp1$hi2) & abs(tmp1$hi2) > truncate.CIs)) ) tmp1$hi2[s] <- ifelse(is.na(tmp1$estimate[s]),  truncate.CIs, pmax( truncate.CIs, tmp1$estimate[s]+1));
  #}
  
  p <- ggplot(tmp1,
              aes(x=tree2, y=estimate, color=signif)) + 
    geom_hline(yintercept=0.0, linetype="dashed", color="salmon") + 
    geom_point(size=2.0) + 
    geom_errorbar(aes(ymin=lo, ymax=hi), linetype="solid", width=0.20, size=1.0, alpha=0.75) + 
    geom_errorbar(aes(ymin=lo2, ymax=hi2), linetype="solid", width=0.15, alpha=0.75) +
    geom_vline(data=unique(tmp1[,c("family2", "tree2", "error")]), aes(xintercept=ifelse(is.na(error), NA, tree2)), color="red", size=3, alpha=0.5) + 
    facet_wrap(family2 ~ measure, scales="free_y", ncol=length(unique(tmp1$measure)), labeller=label_wrap_gen(multi_line=FALSE)) + 
    scale_color_manual("Significant?", values=c("blue", "gray30", "white")) + 
    xlab("Tree") + ylab("Measure") + #coord_cartesian(ylim = c(-truncate.CIs, truncate.CIs)) + 
    theme_bw() + theme(axis.text.x = element_text(angle=45, vjust=0.5, hjust=1)) +
    NULL;
  
  return (list("summary"=tmp1, "plot"=p));
}
```

We performed the **phylogenetic regression** of 'blue' on various IVs of interest, using three methods:

- *Phylogenetic Generalized Linear Mixed Model for Binary Data* as implemented by `binaryPGLMM()` in package `ape`,
- *Phylogenetic Generalized Linear Model* as implemented by `phyloglm()` in package `phylolm`, implementing the phylogenetic logistic regression of @IG2010 with both "logistic_IG10" ("optimizes a GEE approximation to the penalized likelihood of the logistic regression") and "logistic_MPLE" ("maximizes the penalized likelihood of the logistic regression") methods,
- *Bayesian logistic regression controlling for phylogeny* as implemented by `brm()` in package `brms`, using `gr(glottocode, cov=A)` where `A` is the phylogenetic variance-covariance matrix.

We also estimated the "flat" logistic regressions which completely disregard the phylogenetic information (frequentist: `glm`, Bayesian: `brm`), which we should take as a baseline test of the relationship between 'blue' and the considered IV ignoring Galton's problem.

In the following we look at correlated evolution and phylogenetic regression for each IV considered separately.

Please note the following conventions for the **phylogenetic regression plots**:

- each row represents a family 
- each column and method 
- the actual trees are shown within each panel on the x-axis
- the y-axis shows, for each family, method and tree, the point estimate (as a dot) of the regression coefficient *β*, its incertitude (as ±1sd and ±2sd, in darker and ligher colored segments, respectively, for the non-Bayesian methods, and the 89% and 95%HDI for brms, respectively), and its nominal statistical significance (as color; for brms, we used the posterior probability *p*(*β*=0))
- the tree names are abbreviated as: G(o) = 'Glottolog (original)', G(x) = 'Glottolog (exponential)', G(u) = 'Glottolog (ultrametric)', M(s) = 'MCMC (summary)', M(p) = 'MCMC (posterior)', and J18 = '@jagerGlobalscalePhylogeneticLinguistic2018'
- for plotting purposes, the Sino-Tibetan MCC tree of @zhangPhylogeneticEvidenceSinoTibetan2019a and the MCC global phylogeny of @bouckaert_global_2022 are considered as M(s) (i.e., 'MCMC (summary)')
- for the MCMC (posterior) trees, we plot all the posterior trees superposed
- the family names are abbreviated as: AA = 'Afro-Asiatic', AC/B = 'Atlantic-Congo/Bantu', Aas = 'Austroasiatic', Aan = 'Austronesian', HM = 'Hmong-Mien', IE = 'Indo-European', ND = 'Nakh-Daghestanian', PN = 'Pama-Nyungan', PT = 'Pano-Tacanan', ST = 'Sino-Tibetan' , TK = 'Tai-Kadai', TAP = 'Timor-Alor-Pantar', T = 'Turkic', and U = 'Uralic'
- the dotted red line represents 0.0
- the thick transparent vertical red lines represent cases where 'blue' is constant on the tree
- missing M(s) and M(p) mean that there are no posterior trees available for the family
- *GLM* is the 'flat' maxmimum-likelihood logistic regression of 'blue' on the IV, while *BRMSf* is the Bayesian (brms) version; i.e., these two are the baseline regressions where the phylogenetic information is completely ignored
- each panel has its own y-axis limits to allow the plotting of the full range without swamping the methods with smaller and tighter estimates by those with bigger or less precise ones, but makes comparing the results between methods and families trickier.


#### UV-B incidence (mean)

```{r}
y <- correv__UV_mean_r__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__UV_mean_r__blue$family))*1.5, fig.width=length(unique(phyreg__UV_mean_r__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("UV_mean_r"))$plot;
ggsave(paste0("./paper/fig_phyreg_uvbm.pdf"), device="pdf", height=length(unique(phyreg__UV_mean_r__blue$family))*1.0, width=length(unique(phyreg__UV_mean_r__blue$tree))*1.5, units="in"); # for SI
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary 
```

**Summary:**

For **correlated evolution** there are indications of a *significant correlated evolution* for:

- considering all trees, `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases, and
- excluding the posterior MCMC trees, `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases [`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`].

For **phylogenetic regression**, the regression coefficient of 'blue' is:

- considering all trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and *negative* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate < 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases, and
- excluding the posterior MCMC trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases: `r paste0("*", x$family[s], "* [", x$tree[s],", ",x$measure[s],"]",collapse=", ")`; and *negative* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate < 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.

```{r include=FALSE, eval=FALSE}
# Export as LaTeX table for the paper (sill needs some re-arranging and small changes, but the bulk of the work is done):
tmp <- data.frame("family"=tmp_no_post$family, "tree"=tmp_no_post$tree, "pagel"=tmp_no_post$Pagel, "threshBayes"=tmp_no_post$threshBayes);
tmp$family[ tmp$family == "World" & tmp$tree == "Jäger (2018)" ] <- "``global'' (1)";
tmp$family[ tmp$family == "World" & tmp$tree == "Bouckaert et al. (2022)" ] <- "``global'' (2)";

tmp <- rbind(tmp, data.frame("family"=tmp_post$family, "tree"="posterior", "pagel"=tmp_post$Pagel, "threshBayes"=tmp_post$threshBayes));

tmp$tree <- vapply(tmp$tree, function(s) switch(s, "Glottolog (original)"="Go", "Glottolog (exponential)"="Ge", "Glottolog (ultrametric)"="Gu", 
                                                "Jäger (2018)"="\\citet{JagerGlobal2018}", "Zhang et al. (2019)"="summary", "Bouckaert et al. (2022)"="\\citet{bouckaert_global_2022}",
                                                "MCMC (summary)"="summary", s), character(1));

tmp <- tmp[ tmp$pagel != "-", ];
             
tmp$family[ tmp$family == "Bantu" ] <- "(Bantu)"

rownames(tmp) <- paste0(ifelse(tmp$family == "(Bantu)", "Atlantic-Congo", ifelse(tmp$family == "``global'' (1)", "XXX1", ifelse(tmp$family == "``global'' (2)", "XXX2", tmp$family))), 
                        ".",
                        ifelse(tmp$tree == "Go", 1, 
                               ifelse(tmp$tree == "Ge", 2, 
                                      ifelse(tmp$tree == "Gu", 3, 
                                             ifelse(tmp$tree == "\\citet{JagerGlobal2018}", 4, 
                                                    ifelse(tmp$tree == "\\citet{bouckaert_global_2022}", 5,
                                                           ifelse(tmp$tree == "summary", 6,
                                                                  7)))))));
tmp <- tmp[ order(rownames(tmp)), ];
i <- 2;
while( i < nrow(tmp) )
{
  if( strsplit(rownames(tmp)[i-1],".",fixed=TRUE)[[1]][1] != strsplit(rownames(tmp)[i],".",fixed=TRUE)[[1]][1] )
  {
    # change of family:
    tmp <- rbind(tmp[1:i-1,], data.frame("family"="\\hline", "tree"="", "pagel"="", "threshBayes"=""), tmp[i:nrow(tmp),]);
    rownames(tmp)[i] <- paste0(rownames(tmp)[i+1],".");
  } 
  i <- i+1;
}
for( i in 2:nrow(tmp) )
{
  if( strsplit(rownames(tmp)[i-1],".",fixed=TRUE)[[1]][1] == strsplit(rownames(tmp)[i],".",fixed=TRUE)[[1]][1] && tmp$family[i-1] != "\\hline") tmp$family[i] <- "";
}

tmp$pagel <- ifelse(startsWith(tmp$pagel, "**"), paste0("\\pmb{", str_sub(tmp$pagel,3,-3), "}"), tmp$pagel);
tmp$pagel <- ifelse(tmp$family != "\\hline", paste0("$",str_replace_all(tmp$pagel, fixed("*p*"), "~p"),"$"), tmp$pagel);
tmp$pagel <- str_replace_all(tmp$pagel, fixed("*"), "^{*}");
tmp$pagel[ tmp$tree == "posterior" ] <- vapply(tmp$pagel[ tmp$tree == "posterior" ], function(s) str_replace_all(s, "\\([[:digit:]]+\\.[[:digit:]]+\\) ", "~p:"), character(1));

tmp$threshBayes <- ifelse(startsWith(tmp$threshBayes, "**"), paste0("\\pmb{", str_sub(tmp$threshBayes,3,-3), "}"), tmp$threshBayes);
tmp$threshBayes <- ifelse(tmp$family != "\\hline", paste0("$",str_replace_all(tmp$threshBayes, fixed("*p*"), "~p"),"$"), tmp$threshBayes);
tmp$threshBayes <- str_replace_all(tmp$threshBayes, fixed("*"), "^{*}");
tmp$threshBayes <- str_replace_all(tmp$threshBayes, fixed("["), "~[");
tmp$threshBayes[ tmp$tree == "posterior" ] <- vapply(tmp$pagel[ tmp$tree == "posterior" ], function(s) str_replace_all(s, "\\([[:digit:]]+\\.[[:digit:]]+\\) ", "~p:"), character(1));

for( i in 1:nrow(tmp) )
{
  if( tmp$family[i] != "\\hline" && (startsWith(tmp$pagel[i], "$\\pmb{") || startsWith(tmp$threshBayes[i], "$\\pmb{")) )
  {
    tmp$tree[i] <- paste0("\\textbf{",tmp$tree[i],"}");
  }
  if( tmp$family[i] != "\\hline" )
  {
    if( str_detect(tmp$pagel[i], "e") )
    {
      tmp$pagel[i] <- str_replace_all(tmp$pagel[i], "e\\-[0]?", "\\\\cdot10^{-");
      tmp$pagel[i] <- str_replace_all(tmp$pagel[i], fixed("^{*"), "*"); 
    }
    if( str_detect(tmp$threshBayes[i], "e") )
    {
      tmp$threshBayes[i] <- str_replace_all(tmp$threshBayes[i], "e\\-[0]?", "\\\\cdot10^{-");
      tmp$threshBayes[i] <- str_replace_all(tmp$threshBayes[i], fixed("^{*"), "*"); 
    }
  }
}

s <- vapply(1:nrow(tmp), function(i) ifelse(tmp$tree[i] == "", tmp$family[i], paste0(tmp[i,], collapse=" & ")), character(1));
s <- paste0(s, ifelse(s=="\\hline", "\n", "\\\\ \n"));
s <- str_replace_all(s, fixed("%"), "\\%");
library("clipr");
write_clip(s); # copy it directly to clipboard for pasting in the latex file...
#cat(paste0(s,collapse="\n"));
```


#### UV-B incidence (sd)

```{r}
y <- correv__UV_sd_r__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__UV_sd_r__blue$family))*1.5, fig.width=length(unique(phyreg__UV_sd_r__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("UV_sd_r"))$plot;
ggsave(paste0("./paper/fig_phyreg_uvbs.pdf"), device="pdf", height=length(unique(phyreg__UV_sd_r__blue$family))*1.0, width=length(unique(phyreg__UV_sd_r__blue$tree))*1.5, units="in"); # for SI
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary
```

**Summary:**

For **correlated evolution**, there are indications of a *significant correlated evolution* for:

- considering all trees, `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases, and
- excluding the posterior MCMC trees, `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases [`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`].

For **phylogenetic regression**, the regression coefficient of 'blue' is:

- considering all trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases, and
- excluding the posterior MCMC trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases: `r paste0("*", x$family[s], "* [", x$tree[s],", ",x$measure[s],"]",collapse=", ")`; and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.

```{r include=FALSE, eval=FALSE}
# Export as LaTeX table for the paper (sill needs some re-arranging and small changes, but the bulk of the work is done):
tmp <- data.frame("family"=tmp_no_post$family, "tree"=tmp_no_post$tree, "pagel"=tmp_no_post$Pagel, "threshBayes"=tmp_no_post$threshBayes);
tmp$family[ tmp$family == "World" & tmp$tree == "Jäger (2018)" ] <- "``global'' (1)";
tmp$family[ tmp$family == "World" & tmp$tree == "Bouckaert et al. (2022)" ] <- "``global'' (2)";

tmp <- rbind(tmp, data.frame("family"=tmp_post$family, "tree"="posterior", "pagel"=tmp_post$Pagel, "threshBayes"=tmp_post$threshBayes));

tmp$tree <- vapply(tmp$tree, function(s) switch(s, "Glottolog (original)"="Go", "Glottolog (exponential)"="Ge", "Glottolog (ultrametric)"="Gu", 
                                                "Jäger (2018)"="\\citet{JagerGlobal2018}", "Zhang et al. (2019)"="summary", "Bouckaert et al. (2022)"="\\citet{bouckaert_global_2022}",
                                                "MCMC (summary)"="summary", s), character(1));

tmp <- tmp[ tmp$pagel != "-", ];
             
tmp$family[ tmp$family == "Bantu" ] <- "(Bantu)"

rownames(tmp) <- paste0(ifelse(tmp$family == "(Bantu)", "Atlantic-Congo", ifelse(tmp$family == "``global'' (1)", "XXX1", ifelse(tmp$family == "``global'' (2)", "XXX2", tmp$family))), 
                        ".",
                        ifelse(tmp$tree == "Go", 1, 
                               ifelse(tmp$tree == "Ge", 2, 
                                      ifelse(tmp$tree == "Gu", 3, 
                                             ifelse(tmp$tree == "\\citet{JagerGlobal2018}", 4, 
                                                    ifelse(tmp$tree == "\\citet{bouckaert_global_2022}", 5,
                                                           ifelse(tmp$tree == "summary", 6,
                                                                  7)))))));
tmp <- tmp[ order(rownames(tmp)), ];
i <- 2;
while( i < nrow(tmp) )
{
  if( strsplit(rownames(tmp)[i-1],".",fixed=TRUE)[[1]][1] != strsplit(rownames(tmp)[i],".",fixed=TRUE)[[1]][1] )
  {
    # change of family:
    tmp <- rbind(tmp[1:i-1,], data.frame("family"="\\hline", "tree"="", "pagel"="", "threshBayes"=""), tmp[i:nrow(tmp),]);
    rownames(tmp)[i] <- paste0(rownames(tmp)[i+1],".");
  } 
  i <- i+1;
}
for( i in 2:nrow(tmp) )
{
  if( strsplit(rownames(tmp)[i-1],".",fixed=TRUE)[[1]][1] == strsplit(rownames(tmp)[i],".",fixed=TRUE)[[1]][1] && tmp$family[i-1] != "\\hline") tmp$family[i] <- "";
}

tmp$pagel <- ifelse(startsWith(tmp$pagel, "**"), paste0("\\pmb{", str_sub(tmp$pagel,3,-3), "}"), tmp$pagel);
tmp$pagel <- ifelse(tmp$family != "\\hline", paste0("$",str_replace_all(tmp$pagel, fixed("*p*"), "~p"),"$"), tmp$pagel);
tmp$pagel <- str_replace_all(tmp$pagel, fixed("*"), "^{*}");
tmp$pagel[ tmp$tree == "posterior" ] <- vapply(tmp$pagel[ tmp$tree == "posterior" ], function(s) str_replace_all(s, "\\([[:digit:]]+\\.[[:digit:]]+\\) ", "~p:"), character(1));

tmp$threshBayes <- ifelse(startsWith(tmp$threshBayes, "**"), paste0("\\pmb{", str_sub(tmp$threshBayes,3,-3), "}"), tmp$threshBayes);
tmp$threshBayes <- ifelse(tmp$family != "\\hline", paste0("$",str_replace_all(tmp$threshBayes, fixed("*p*"), "~p"),"$"), tmp$threshBayes);
tmp$threshBayes <- str_replace_all(tmp$threshBayes, fixed("*"), "^{*}");
tmp$threshBayes <- str_replace_all(tmp$threshBayes, fixed("["), "~[");
tmp$threshBayes[ tmp$tree == "posterior" ] <- vapply(tmp$pagel[ tmp$tree == "posterior" ], function(s) str_replace_all(s, "\\([[:digit:]]+\\.[[:digit:]]+\\) ", "~p:"), character(1));

for( i in 1:nrow(tmp) )
{
  if( tmp$family[i] != "\\hline" && (startsWith(tmp$pagel[i], "$\\pmb{") || startsWith(tmp$threshBayes[i], "$\\pmb{")) )
  {
    tmp$tree[i] <- paste0("\\textbf{",tmp$tree[i],"}");
  }
  if( tmp$family[i] != "\\hline" )
  {
    if( str_detect(tmp$pagel[i], "e") )
    {
      tmp$pagel[i] <- str_replace_all(tmp$pagel[i], "e\\-[0]?", "\\\\cdot10^{-");
      tmp$pagel[i] <- str_replace_all(tmp$pagel[i], fixed("^{*"), "*"); 
    }
    if( str_detect(tmp$threshBayes[i], "e") )
    {
      tmp$threshBayes[i] <- str_replace_all(tmp$threshBayes[i], "e\\-[0]?", "\\\\cdot10^{-");
      tmp$threshBayes[i] <- str_replace_all(tmp$threshBayes[i], fixed("^{*"), "*"); 
    }
  }
}

s <- vapply(1:nrow(tmp), function(i) ifelse(tmp$tree[i] == "", tmp$family[i], paste0(tmp[i,], collapse=" & ")), character(1));
s <- paste0(s, ifelse(s=="\\hline", "\n", "\\\\ \n"));
s <- str_replace_all(s, fixed("%"), "\\%");
library("clipr");
write_clip(s); # copy it directly to clipboard for pasting in the latex file...
#cat(paste0(s,collapse="\n"));
```


#### Latitude

```{r}
y <- correv__latitude__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__latitude__blue$family))*1.5, fig.width=length(unique(phyreg__latitude__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("latitude"))$plot;
ggsave(paste0("./paper/fig_phyreg_lat.pdf"), device="pdf", height=length(unique(phyreg__latitude__blue$family))*1.0, width=length(unique(phyreg__latitude__blue$tree))*1.5, units="in"); # for SI
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary
```

**Summary:**

For **correlated evolution**, there are indications of a *significant correlated evolution* for:

- considering all trees, `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases, and
- excluding the posterior MCMC trees, `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases [`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`].

For **phylogenetic regression**, the regression coefficient of 'blue' is:

- considering all trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases, and
- excluding the posterior MCMC trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases: `r paste0("*", x$family[s], "* [", x$tree[s],", ",x$measure[s],"]",collapse=", ")`; and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.


#### Longitude

```{r}
y <- correv__longitude__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__longitude__blue$family))*1.5, fig.width=length(unique(phyreg__longitude__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("longitude"))$plot;
ggsave(paste0("./paper/fig_phyreg_long.pdf"), device="pdf", height=length(unique(phyreg__longitude__blue$family))*1.0, width=length(unique(phyreg__longitude__blue$tree))*1.5, units="in"); # for SI
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary
```

**Summary:**

For **correlated evolution**, there are indications of a *significant correlated evolution* for:

- considering all trees, `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases, and
- excluding the posterior MCMC trees, `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases [`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`].

For **phylogenetic regression**, the regression coefficient of 'blue' is:

- considering all trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases, and
- excluding the posterior MCMC trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases: `r paste0("*", x$family[s], "* [", x$tree[s],", ",x$measure[s],"]",collapse=", ")`; and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.


#### Population size

```{r}
y <- correv__log_popSize_ethno__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__log_popSize_ethno__blue$family))*1.5, fig.width=length(unique(phyreg__log_popSize_ethno__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("longitude"))$plot;
ggsave(paste0("./paper/fig_phyreg_psiz.pdf"), device="pdf", height=length(unique(phyreg__log_popSize_ethno__blue$family))*1.0, width=length(unique(phyreg__log_popSize_ethno__blue$tree))*1.5, units="in"); # for SI
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary
```

**Summary:**

For **correlated evolution**, there are indications of a *significant correlated evolution* for:

- considering all trees, `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases, and
- excluding the posterior MCMC trees, `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases [`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`].

For **phylogenetic regression**, the regression coefficient of 'blue' is:

- considering all trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases, and
- excluding the posterior MCMC trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases: `r paste0("*", x$family[s], "* [", x$tree[s],", ",x$measure[s],"]",collapse=", ")`; and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.


#### Subsistence

```{r}
y <- correv__subsistence__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__subsistence__blue$family))*1.5, fig.width=length(unique(phyreg__subsistence__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("subsistence"))$plot;
ggsave(paste0("./paper/fig_phyreg_subs.pdf"), device="pdf", height=length(unique(phyreg__subsistence__blue$family))*1.0, width=length(unique(phyreg__subsistence__blue$tree))*1.5, units="in"); # for SI
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary
```

**Summary:**

For **correlated evolution**, there are indications of a *significant correlated evolution* for:

- considering all trees, `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases, and
- excluding the posterior MCMC trees, `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases [`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`].

For **phylogenetic regression**, the regression coefficient of 'blue' is:

- considering all trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases, and
- excluding the posterior MCMC trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases: `r paste0("*", x$family[s], "* [", x$tree[s],", ",x$measure[s],"]",collapse=", ")`; and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.


#### Climate PC1

```{r}
y <- correv__clim_PC1_r__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__clim_PC1_r__blue$family))*1.5, fig.width=length(unique(phyreg__clim_PC1_r__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("clim_PC1_r"))$plot;
ggsave(paste0("./paper/fig_phyreg_climpc1.pdf"), device="pdf", height=length(unique(phyreg__clim_PC1_r__blue$family))*1.0, width=length(unique(phyreg__clim_PC1_r__blue$tree))*1.5, units="in"); # for SI
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary
```

**Summary:**

For **correlated evolution**, there are indications of a *significant correlated evolution* for:

- considering all trees, `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases, and
- excluding the posterior MCMC trees, `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases [`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`].

For **phylogenetic regression**, the regression coefficient of 'blue' is:

- considering all trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases, and
- excluding the posterior MCMC trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases: `r paste0("*", x$family[s], "* [", x$tree[s],", ",x$measure[s],"]",collapse=", ")`; and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.


#### Climate PC2

```{r}
y <- correv__clim_PC2_r__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__clim_PC2_r__blue$family))*1.5, fig.width=length(unique(phyreg__clim_PC2_r__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("clim_PC2_r"))$plot;
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary
```

**Summary:**

For **correlated evolution**, there are indications of a *significant correlated evolution* for:

- considering all trees, `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases, and
- excluding the posterior MCMC trees, `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases [`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`].

For **phylogenetic regression**, the regression coefficient of 'blue' is:

- considering all trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases, and
- excluding the posterior MCMC trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases: `r paste0("*", x$family[s], "* [", x$tree[s],", ",x$measure[s],"]",collapse=", ")`; and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.


#### Climate PC3

```{r}
y <- correv__clim_PC3_r__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__clim_PC3_r__blue$family))*1.5, fig.width=length(unique(phyreg__clim_PC3_r__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("clim_PC3_r"))$plot;
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary
```

**Summary:**

For **correlated evolution**, there are indications of a *significant correlated evolution* for:

- considering all trees, `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases, and
- excluding the posterior MCMC trees, `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases [`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`].

For **phylogenetic regression**, the regression coefficient of 'blue' is:

- considering all trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases, and
- excluding the posterior MCMC trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases: `r paste0("*", x$family[s], "* [", x$tree[s],", ",x$measure[s],"]",collapse=", ")`; and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.


#### Humidity (median)

```{r}
y <- correv__hum_median__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__hum_median__blue$family))*1.5, fig.width=length(unique(phyreg__hum_median__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("hum_median"))$plot;
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary
```

**Summary:**

For **correlated evolution**, there are indications of a *significant correlated evolution* for:

- considering all trees, `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases, and
- excluding the posterior MCMC trees, `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases [`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`].

For **phylogenetic regression**, the regression coefficient of 'blue' is:

- considering all trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases, and
- excluding the posterior MCMC trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases: `r paste0("*", x$family[s], "* [", x$tree[s],", ",x$measure[s],"]",collapse=", ")`; and *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.


#### Humidity (IQR)

```{r}
y <- correv__hum_IQR__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__hum_IQR__blue$family))*1.5, fig.width=length(unique(phyreg__hum_IQR__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("hum_IQR"))$plot;
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary
```

**Summary:**

For **correlated evolution**, there are `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases with a significant correlated evolution.
Excluding the posterior MCMC trees, there are `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases with a significant correlated evolution (`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`).

For **phylogenetic regression**.
The regression coefficient of 'blue' is nominally significantly different from 0 in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and is *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases.
Excluding the posterior MCMC trees, the regression coefficient of 'blue' is nominally significantly different from 0 in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases (`r paste0("*", x$family[s], "* : ", x$tree[s],collapse=", ")`), and is *positive* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate > 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.


#### Distance to lakes

```{r}
y <- correv__dist2lakes_r__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__dist2lakes_r__blue$family))*1.5, fig.width=length(unique(phyreg__dist2lakes_r__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("dist2lakes_r"))$plot;
ggsave(paste0("./paper/fig_phyreg_d2l.pdf"), device="pdf", height=length(unique(phyreg__dist2lakes_r__blue$family))*1.0, width=length(unique(phyreg__dist2lakes_r__blue$tree))*1.5, units="in"); # for SI
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary
```

**Summary:**

For **correlated evolution**, there are indications of a *significant correlated evolution* for:

- considering all trees, `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases, and
- excluding the posterior MCMC trees, `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases [`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`].

For **phylogenetic regression**, the rregression coefficient of 'blue' is:

- considering all trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and *negative* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate < 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases, and
- excluding the posterior MCMC trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases: `r paste0("*", x$family[s], "* [", x$tree[s],", ",x$measure[s],"]",collapse=", ")`; and *negative* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate < 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.


#### Distance to rivers

```{r}
y <- correv__dist2rivers_r__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__dist2rivers_r__blue$family))*1.5, fig.width=length(unique(phyreg__dist2rivers_r__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("dist2rivers_r"))$plot;
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary
```

**Summary:**

For **correlated evolution**, there are indications of a *significant correlated evolution* for:

- considering all trees, `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases, and
- excluding the posterior MCMC trees, `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases [`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`].

For **phylogenetic regression**, the regression coefficient of 'blue' is:

- considering all trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and *negative* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate < 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases, and
- excluding the posterior MCMC trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases: `r paste0("*", x$family[s], "* [", x$tree[s],", ",x$measure[s],"]",collapse=", ")`; and *negative* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate < 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.


#### Distance to oceans

```{r}
y <- correv__dist2ocean_r__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__dist2ocean_r__blue$family))*1.5, fig.width=length(unique(phyreg__dist2ocean_r__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("dist2ocean_r"))$plot;
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary
```

**Summary:**

For **correlated evolution**, there are indications of a *significant correlated evolution* for:

- considering all trees, `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases, and
- excluding the posterior MCMC trees, `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases [`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`].

For **phylogenetic regression**, the regression coefficient of 'blue' is:

- considering all trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and *negative* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate < 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases, and
- excluding the posterior MCMC trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases: `r paste0("*", x$family[s], "* [", x$tree[s],", ",x$measure[s],"]",collapse=", ")`; and *negative* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate < 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.


#### Distance to water

```{r}
y <- correv__dist2water_r__blue;
y <- y[ order(y$family), ];

tmp_no_post <- y[ !(y$tree %in% c("MCMC (posterior)")), ];
tmp_no_post$error[ is.na(tmp_no_post$error) ] <- "-";
tmp_no_post$Pagel <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.1f *p*=%.2g%s%s", 
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", ""),
                                                                   tmp_no_post$Pagel.DeltaAIC, tmp_no_post$Pagel.LR.p, ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "*", ""),
                                                                   ifelse(tmp_no_post$Pagel.DeltaAIC >= 3 | tmp_no_post$Pagel.LR.p < 0.05, "**", "")));
tmp_no_post$threshBayes <- ifelse(tmp_no_post$error != "-", "-", sprintf("%s%.2f [%.2f, %.2f] *p*=%.2g%s%s", 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**"),
                                                                         tmp_no_post$threshBayes.mean, tmp_no_post$threshBayes.hdi_low, tmp_no_post$threshBayes.hdi_high, tmp_no_post$threshBayes.p.rope, 
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "*"),
                                                                         ifelse( tmp_no_post$threshBayes.hdi_low < 0 & tmp_no_post$threshBayes.hdi_high > 0, "", "**")));
knitr::kable(tmp_no_post[,c("family", "tree", "error", "Pagel", "threshBayes")], 
             row.names=FALSE, 
             col.names=c("Family", "Tree", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **Glottolog trees**, **@jagerGlobalscalePhylogeneticLinguistic2018's trees** and the **summary MCMC trees**. For Pagel's method we show the ΔAIC(indep - dep) and the LR test's *p*-value. For threshBayes, we show the mean evolutionary correlation, its 95%HDI and its pROPE. We show a * (and use **bold**) when there is some evidence for correlated evolution, provided either as ΔAIC(indep - dep) > 3, LR test's *p* < 0.05, or 0 ∉ 95%HDI."));
```

```{r}
tmp_post <- y[ (y$tree %in% c("MCMC (posterior)")), ];
tmp_post <- tmp_post %>% group_by(family) %>%
  summarise(error=paste0(unique(error),collapse=", "),
            Pagel=sprintf("%.2f (%.2f) %.1f%%", mean(Pagel.DeltaAIC,na.rm=TRUE), sd(Pagel.DeltaAIC,na.rm=TRUE), 100*sum(Pagel.LR.p < 0.05,na.rm=TRUE)/sum(!is.na(Pagel.LR.p))),
            threshBayes=sprintf("%.2f (%.2f) %.1f%%", mean(threshBayes.mean,na.rm=TRUE), sd(threshBayes.mean,na.rm=TRUE), 100*sum(!(threshBayes.hdi_low < 0 & threshBayes.hdi_high > 0),na.rm=TRUE)/sum(!is.na(threshBayes.hdi_low))));
tmp_post$error[ tmp_post$error == "NA" ] <- "-";
tmp_post$Pagel[ tmp_post$error != "-" ] <- tmp_post$threshBayes[ tmp_post$error != "-" ] <- "-";
knitr::kable(tmp_post, 
             row.names=FALSE, 
             col.names=c("Family", "Errors?", "Pagel", "threshBayes"),
             align="r",
             caption=capTab("Various estimates of correlated evolution when using the **posterior MCMC trees**. For Pagel we consider ΔAIC(indep - dep) and for threshBayes we consider the mean evolutionary correlation, and for both measures we give the mean (standard deviation) and % trees which a significant signal."));
```

```{r fig.height=length(unique(phyreg__dist2water_r__blue$family))*1.5, fig.width=length(unique(phyreg__dist2water_r__blue$tree))*2.5, fig.cap=capFig("Phylogenetic regression (see text for conventions).")}
(x <- .summarize_plot_phyreg("dist2water_r"))$plot;
x <- x$summary[ !(x$summary$measure %in% c("GLM", "BRMSf")), ]; # keep only the phylogenetic regressions for the summary
```

**Summary:**

For **correlated evolution**, there are indications of a *significant correlated evolution* for:

- considering all trees, `r sprintf("%d (%.1f%%)", sum(s <- (!is.na(y$threshBayes.mean) & (!(y$threshBayes.hdi_low < 0 & y$threshBayes.hdi_high > 0) | y$Pagel.DeltaAIC >= 3 | y$Pagel.LR.p < 0.05))), 100*sum(s)/nrow(y))` cases, and
- excluding the posterior MCMC trees, `r sprintf("%d (%.1f%%)", sum(s <- s & y$tree != "MCMC (posterior)"), 100*sum(s)/sum(y$tree != "MCMC (posterior)"))` cases [`r paste0("*", y$family[s], "* : ", y$tree[s],collapse=", ")`].

For **phylogenetic regression**, the regression coefficient of 'blue' is:

- considering all trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes"), 100*sum(s)/nrow(x))` cases, and *negative* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate < 0, na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate)))` cases, and
- excluding the posterior MCMC trees, *nominally significant* in `r sprintf("%d (%.1f%%)", sum(s <- x$signif == "yes" & x$tree != "MCMC (posterior)"), 100*sum(s)/sum(x$tree != "MCMC (posterior)"))` cases: `r paste0("*", x$family[s], "* [", x$tree[s],", ",x$measure[s],"]",collapse=", ")`; and *negative* in `r sprintf("%d (%.1f%%)", sum(s <- x$estimate < 0 & x$tree != "MCMC (posterior)", na.rm=TRUE), 100*sum(s, na.rm=TRUE)/sum(!is.na(x$estimate) & x$tree != "MCMC (posterior)"))` cases.


### Summary of phylogenetic analyses for UV-B incidence → 'blue'

We need to note that we very probably suffer from a lack of statistical power, even in the largest families, because:

- most families have little data,
- moreover, 'blue' tends to show little variation within families (being fixed in some cases)
- probably, in part as a consequence of the above, 'blue' shows very little phylogenetic signal in our data.

However, the "global" trees (@jagerGlobalscalePhylogeneticLinguistic2018 and @bouckaert_global_2022), with all their caveats, have the highest statistical power. 

<!--
#### Phylogenetic signal

Depending on the measure, there seem to be a phylogenetic signal in some families/trees (both higher than 0 and lower than 1), in particular for *Austronesian*, *Indo-European* and the *World* trees. 
However, the lack of a clear phylogenetic signal overall is probably due, at least in part, to the the limited data we have, but might also reflect the fact that 'blue' is relatively free to change under non-vertical influences (including the environment, culture and language contact).

##### Ancestral state reconstruction

As expected given the results for the phylogenetic signal above, the estimates of the root probabilities for ‘blue’ seem to depend to a certain extent on the particular branch lengths and model used. 
However, the following families seem to have had ‘blue’ "from the beginning": *Austronesian*, *Indo-European*, *Nakh-Daghestanian*, *Sino-Tibetan*, *Tai-Kadai*, *Turkic* and *Uralic*, while *Pama-Nyungan* seemingly did not. 
Moreover, the *World* trees are suggested to (possibly) have had ‘blue’ at the root.

##### Correlated evolution & phylogenetic regression

For regression, controlling for phylogeny (as opposed to not considering the phylogeny at all) seems not to matter much (both in terms of point estimate and standard errors) for the maximum-likelihood methods, but for the Bayesian regression, controlling for phylogeny does move the posterior distribution towards zero.
Relatedly, the Bayesian method seems more conservative than the maximum-likelihood ones.
-->

<!--
#### The *a priori* hypothesis: UV-B incidence → 'blue'

The original version of this hypothesis states that the *mean* UV-B incidence has a *negative* effect on the probability of having a dedicated word for 'blue'.
We found significant correlated evolution (ce) for *Austroasiatic* and *Hmong-Mien*, with a weak possible signal for *Indo-European*; for the *World* trees [@jagerGlobalscalePhylogeneticLinguistic2018;@bouckaert_global_2022], Pagel's method finds a highly significant signal.
On the other hand, the logistic phylogenetic regression reaches a nominally significant negative effect (encapsulated by the regression coefficient *β*) only in a few cases, but the *β*'s point estimate is negative in the vast majority of cases (≈95% when including the MCMC posterior trees, which biases the percent heavily towards the few families with such trees, and ≈80% when excluding them, which gives a much more balanced view); for the *World* trees [@jagerGlobalscalePhylogeneticLinguistic2018;@bouckaert_global_2022], there is a clear and strong negative effect for all methods.

However, there is a strong negative correlation between the *standard deviation* (sd) of UV-B incidence and the mean incidence (essentially, due to seasonality), but, to our knowledge, there is no proposed causal mechanism linking the variation in UV-B incidence and 'blue'.
The signal of correlated evolution between *sd*(UV-B) and 'blue' is much less consistent, and there is a nominally significant positive effect for slightly more cases, being positive in ≈90% and 70% of cases, when including or not the posterior MCMC trees, respectively; again, the *World* trees [@jagerGlobalscalePhylogeneticLinguistic2018;@bouckaert_global_2022] find a strong positive signal.
-->

We will now focus on each individual family: for each family and tree, we show two figures, each with two panels.
The first figure shows the map of the family, with the left panel showing the family on the world map, mapped to the tree (the colors gradient is used simply to improve the visual correspondence between the points on the map and the tree tips), while the right panel zooms in and also shows the presence of a dedicated word for 'blue' (blue) or not (green). Please note that in this map not all languages have been labelled to avoid clutter.
The second figure shows the presence of a dedicated word for 'blue' (blue) or not (green) simultaneously with the value (also given in [] after the glottocode of the language) of the mean UV-B incidence (left panel) or its sd (right panel); please note that these are the absolute values (i.e., not relative to the family minimum or maximum values) and, unfortunately, the scale could not be drawn.

```{r}
# Figure 1:
.fam.map.tree.fig1 <- function()
{
  d <- d_colors_ag[ d_colors_ag$glottocode %in% fam_tree$tip.label, ];
  y <- as.matrix(d[,c("latitude","longitude_180")]); rownames(y) <- d$glottocode;
  reg_names <- map("world", plot=FALSE, namesonly=TRUE);
  x <- phytools::phylo.to.map(fam_tree, y, plot=FALSE, rotate=FALSE, database="world", regions=reg_names[ -grep("Antarctica", reg_names) ]);
  colfunc <- colorRampPalette(c("red", "yellow"));
  cols<-setNames(colfunc(n=Ntip(fam_tree)), fam_tree$tip.label);
  plot(x, type="phylogram", asp=1.3, mar=c(0.1,0.5,3.1,0.1), colors=cols, cex=0.5, lty="dotted", cex.points=1.5);
  
  map.ratio <- (max(mapWorld$lat,na.rm=TRUE) - min(mapWorld$lat,na.rm=TRUE)) / (max(mapWorld$long,na.rm=TRUE) - min(mapWorld$long,na.rm=TRUE));
  submap.lat.range  <- c(min(d$latitude, na.rm=TRUE)-5,      max(d$latitude, na.rm=TRUE)+5);
  submap.long.range <- c(min(d$longitude_180, na.rm=TRUE)-5, max(d$longitude_180, na.rm=TRUE)+5);
  submap.ratio <- (submap.lat.range[2] - submap.lat.range[1]) / (submap.long.range[2] - submap.long.range[1]);
  #submap.long.range[1] <- submap.long.range[1] * (1 - 1/(submap.ratio - map.ratio)/2);
  #submap.long.range[2] <- submap.long.range[2] * (1 + 1/(submap.ratio - map.ratio)/2);
  submap_fam <- mapWorld[mapWorld$lat > submap.lat.range[1] & mapWorld$lat < submap.lat.range[2] & 
                           mapWorld$long > submap.long.range[1] & mapWorld$long < submap.long.range[2],];
  ggplot() + 
    geom_polygon(data=submap_fam, aes(x=long, y=lat, group=group), fill="grey80") + xlab("Longitude (°)") + ylab("Latitude (°)") + # landmasses
    geom_point(data=d, aes(x=longitude_180, y=latitude, fill=exists_blue), color="black", shape=21, alpha=0.5, size=3) +
    geom_label_repel(data=d, aes(x=longitude_180, y=latitude, label=glottocode, color=exists_blue, fill=exists_blue), alpha=0.95, size=2.75, label.padding=0.10, label.r=0.05, max.overlaps=20) + 
    scale_fill_manual("Blue?", values=c("no"="green", "yes"="blue")) + scale_color_manual("Blue?", values=c("no"="black", "yes"="white")) + 
    NULL;
}

# Figure 2:
.fam.map.tree.fig2 <- function()
{
  invisible(.map.data.to.tree(tree=fam_tree, family.name=fam_name, tree.name=tree_name, show.IV="UV_mean", binarize.IV=FALSE, plot.tree=TRUE));
  invisible(.map.data.to.tree(tree=fam_tree, family.name=fam_name, tree.name=tree_name, show.IV="UV_sd",   binarize.IV=FALSE, plot.tree=TRUE));
}
```


***`r paste0((fam_name <- "Afro-Asiatic")," using the ",(tree_name <- "Glottolog (ultrametric)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$afro_asiatic$glottolog$ultrametric;
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2();
```


***`r paste0((fam_name <- "Atlantic-Congo")," using the ",(tree_name <- "Glottolog (ultrametric)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$atlantic_congo$glottolog$ultrametric; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2();
```


***`r paste0((fam_name <- "Bantu")," using the ",(tree_name <- "MCMC (summary)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$bantu$mcmc$summary; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Austroasiatic")," using the ",(tree_name <- "Glottolog (ultrametric)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$austroasiatic$glottolog$ultrametric; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Austronesian")," using the ",(tree_name <- "Glottolog (ultrametric)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$austronesian$glottolog$ultrametric; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Austronesian")," using the ",(tree_name <- "MCMC (summary)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$austronesian$mcmc$summary; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Hmong-Mien")," using the ",(tree_name <- "Glottolog (ultrametric)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$hmong_mien$glottolog$ultrametric; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Indo-European")," using the ",(tree_name <- "Glottolog (ultrametric)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$indo_european$glottolog$ultrametric; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Nakh-Daghestanian")," using the ",(tree_name <- "Glottolog (ultrametric)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$nakh_daghestanian$glottolog$ultrametric; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Indo-European")," using the ",(tree_name <- "MCMC (summary)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$indo_european$mcmc$summary; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Pama-Nyungan")," using the ",(tree_name <- "Glottolog (ultrametric)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$pama_nyungan$glottolog$ultrametric; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Pama-Nyungan")," using the ",(tree_name <- "MCMC (summary)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$pama_nyungan$mcmc$summary; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Pano-Tacanan")," using the ",(tree_name <- "Glottolog (ultrametric)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$pano_tacanan$glottolog$ultrametric; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Sino-Tibetan")," using the ",(tree_name <- "Glottolog (ultrametric)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$sino_tibetan$glottolog$ultrametric; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Tai-Kadai")," using the ",(tree_name <- "Glottolog (ultrametric)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$tai_kadai$glottolog$ultrametric; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Timor-Alor-Pantar")," using the ",(tree_name <- "Glottolog (ultrametric)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$timor_alor_pantar$glottolog$ultrametric; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Turkic")," using the ",(tree_name <- "Glottolog (ultrametric)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$turkic$glottolog$ultrametric; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Turkic")," using the ",(tree_name <- "MCMC (summary)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$turkic$mcmc$summary; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Uralic")," using the ",(tree_name <- "Glottolog (ultrametric)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$uralic$glottolog$ultrametric; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Uralic")," using the ",(tree_name <- "MCMC (summary)")," tree:")`***

```{r}
# Selection:
fam_tree <- trees$uralic$mcmc$summary; 
```

```{r fig.cap=capFig(paste0("Map of the '",fam_name,"' family (using the '",tree_name,"' tree). See text for interpretation."), TRUE, c("ggplot2", "maps"), is_map=TRUE), fig.height=8, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig1();
```

```{r fig.cap=capFig(paste0("Family tree for the '",fam_name,"' family (using the '",tree_name,"' tree).See text for interpretation."), TRUE, c("phytools"), FALSE), fig.height=length(fam_tree$tip.label)*0.2+1, fig.width=8, fig.show="hold", out.width="50%"}
.fam.map.tree.fig2(); 
```


***`r paste0((fam_name <- "Uralic")," using the ",(tree_name <- "MCMC (summary)")," tree:")`***

Thw World trees [@jagerGlobalscalePhylogeneticLinguistic2018;@bouckaert_global_2022] are too big to usefully be shown here.

<!--
***Summary of the results***

| Family | mean(UV-B) | sd(UV-B) | Comments |
|--------+------------+----------+----------|
| **Afro-Asiatic** | no ce, **-- effect (ns)** | no ce, **+ effect (ns)** | brms is close to 0; most languages have 'blue' except for a few concentrated around 10°N 10°E that do not seem phylogenetically clustered and are mixed with 'blue' languages photogenically and geographically |
| Atlantic-Congo | no ce, no effect | no ce, no effect | just Glottolog; very few languages in fact, and very few have 'blue' but these seem to be in relatively lower UV-B locations |
| **Bantu** | no ce, **-- effect (ns)** | no ce, no effect | just the MCMC trees; brms is close to 0; very few languages |
| **Austroasiatic** | **ce (3 of 4^﹡^)**, **-- effect (ns)** | no ce, no effect | brms is close to 0; few languages without 'blue' that indeed seem to exist in high UV-B locations |
| **Austronesian** | no ce, no effect | **possibly ce**, **+ effect (ns)** | brms is close to 0; lack of 'blue' seems phylogenetically clustered and impressionistically in zones of high UV-B incidence |
| **Hmong-Mien** | **ce (2 of 4^﹡^)**, **-- effect (ns)** | no ce, **+ effect (ns)** | brms is close to 0; visually clear that languages with 'blue' tend to be in zones of lower UV-B incidence |
| **Indo-European** | no ce, **-- effect (1^﹡^)** | no ce, **+ effect (2^﹡^)** | MCMC trees unusable (constant 'blue'), brms much weaker; also clear that the few languages without 'blue' are in higher UV-B incidence zones and tend to be phylogenetically clustered |
| Nakh-Daghestanian | no ce, no effect | no ce, no effect |  |
| **Pama-Nyungan** | no ce, **-- effect (ns)** | **possible ce (1^﹡^)**, **+ effect (3^﹡^)** | brms much weaker; the few languages with 'blue' are in zones of lower UV-B incidence |
| Pano-Tacanan | no ce, no effect | no ce, no effect | only two languages (Shipibo-Conibo [ship1254] and Araona [arao1248]) with 'blue' phylogenetically distance and located towards the lowest range of UV-B incidence |
| **Sino-Tibetan** | no ce, **-- effect (ns)** | no ce, no effect | brms is close to 0; again, the languages without 'blue' exist in areas of higher UV-B incidence |
| Tai-Kadai | no ce, no effect | no ce, no effect | the few languages without 'blue' seem to exist in areas of higher UV-B incidence |
| ***Timor-Alor-Pantar*** | no ce, no effect | no ce, ***-- effect (ns)*** | brms is close to 0; very little variation in UV-B incidence and phylogenetic clustering of languages with 'blue' |
| ***Turkic*** | no ce, ***+ effect (ns)*** | no ce, ***-- effect (ns)*** | brms is weaker; interestingly, there is only one language without 'blue' (Sakha [yaku1245]) that is also the northern-most language in the sample -- it is this outlier that creates the apparent effect in the "wrong" direction |
| ***Uralic*** | no ce, ***+ effect (1^*^)*** | no ce, no effect | MCMC trees unusable (constant 'blue'), brms is close to 0; as for Turkic, there is one language spoken in the north (Nganasan [ngan1291]) without 'blue' that create the effect in the "wrong" direction |
| **World** | **ce (Pagel^﹡^)**, **-- effect (^﹡^)** | **ce (Pagel^﹡^)**, **+ effect (^﹡^)** | two very different global phylogenties used: @jagerGlobalscalePhylogeneticLinguistic2018 and @bouckaert_global_2022 |

Table: Summary of correlated evolution (ce) and phylogenetic regression for the considered families. In **bold** are marked those consistent effects (usually among the maximum-likelihood methods, sometimes also the Bayesian regression but much weaker), which may or may not be nominally statistically significant (when not formally significant, we considered the ±1sd and the 89%HDI); ***italic bold*** marks those that have the opposite direction of the effect to the one predicted by the *a priori* hypothesis. A star (^﹡^) marks nominal significance, "ns" non-significance. Please also see the maps and phylogenetic trees for each individual family shown above.

Assuming this **very liberal interpretation** (i.e., where we also consider effects where 0 is not included in, or at the limits of, the estimate ± 1sd interval or the 89%HDI, respectively), obviously without multiple testing correction, we find that:

- only 4 families (*Atlantic-Congo* as a whole [but see below for Bantu], *Nakh-Daghestanian*, *Pano-Tacanan* and *Tai-Kadai*) do not show **any effect** of UV-B incidence on 'blue', but even for these, languages without 'blue' tend to be found in zones of higher UV-B incidence
- 8 (sub)families show a **signal consistent with the hypothesis**, either for the mean (*Bantu*, *Austroasiatic* and *Sino-Tibetan*), the standard deviation (*Austronesian*) or both (*Afro-Asiatic*, *Hmong-Mien*, *Indo-European* and *Pama-Nyungan*)
- 3 families show an effect but in the **opposite direction** to that predicted, for the mean (*Uralic*), sd (*Timor-Alor-Pantar*) or both (*Turkic*), however it is clear for Uralic and Trukic this is driven by outliers in the north, while for Timor-Alor-Pantar there is very little variation in UV-B (and, moreover, most languages are without 'blue' and high UV-B incidence)
- the *World* trees [@jagerGlobalscalePhylogeneticLinguistic2018;@bouckaert_global_2022] show a **clear effect in the expected direction** for both the mean and standard deviation of UV-B incidence

Finally, while we clearly lack the grounds for claiming a solid negative influence of UV-B mean (or, complementarily, of a positive one of UV-B variation) on the probability of having a dedicated word for 'blue', we would argue that the evidence we have, especially seen in the context of the few data for most families and of the other potential predictors (discussed below), does support the hypothesized relationship between UV-B incidence and 'blue'


#### Exploratory relationships

Here we look at the possible relationships within families, between 'blue' and various potential IVs...

***Geography:*** latitude and longitude seem to have no effect on 'blue', in the sense of very few nominally statistically significant cases (in particular *Sino-Tibetan* for longitude, probably related to the geography of its distribution, the Tibetan plateau and the Himalayas, and possibly *Turkic* and *Uralic*) and the even (almost 50%:50%) split between positive and negative effects; *World* finds a significant effect for both, probably reflecting the skewed geographic distribution of the languages with data.

**Population size:** likewise seems to have no clear effect on 'blue', with basically just *Sino-Tibetan* being statistically significant and with an even split between positive and negative effects; *World* finds a significant negative effect.

**Subsistence:** is hard to interpret as many families show no variation and there is a lot of missing data, but there seems to be no effect on 'blue', including an even split between positive and negative effects; *World* finds a suggestion of a positive effect of agriculture.

**Climate:** does not seem to have any consistent effect, except possibly for PC2 in *Atlatic-Congo* and *Sino-Tibetan*, PC3 in *Indo-European*, and humidity variability in *Indo-European*, including an even split between positive and negative effects (except for PC3, which is ≈70% negative); *World* also does not finds a consistent effect.

**Distance to bodies of water:** distance to *lakes* is significant for *Sino-Tibetan* and tends to be negative (≈65%), while distance to rivers, oceans and water in general are less convincing (with the possible exception of *Pama-Nyungan* where the distance to rivers and oceans has a positive effect, but might be a proxy for geography and UV-B incidence).

Thus, while the evidence for an effect of UV-B incidence on 'blue' is weak on its own, seen in the context of the other variables considered, it is the strongest signal we have.
-->


# Appendices


## Appendix I. Potential predictorsfor 'blue'

The full output of these models is given below.


### UV → 'blue' [@lindsey_color_2002;@brown_color_2004]

- when using the locations of **actual languages**:

  - `glmer`: `r .print.model.comparison(a=uv__blue$toms_vs_wc$glmer, a.names=c("m_t"="TOMS", "m_w"="WorldClim"))`
  - `brms`: `r .print.model.comparison(b=uv__blue$toms_vs_wc$brms)`


  + the **mean** UV-B incidence:

    - *TOMS*:
    
      + *quadratic* model:
    
        + `glmer`: `r s <- uv__blue$toms$mean$glmer$quadratic; iv <- "UV_mean_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`

        + `brms`: `r s <- uv__blue$toms$mean$brms$quadratic; iv <- "UV_mean_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
      + *purely linear* model:
    
        + `glmer`: `r s <- uv__blue$toms$mean$glmer$linear; iv <- "UV_mean_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`

        + `brms`: `r s <- uv__blue$toms$mean$brms$linear; iv <- "UV_mean_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

    - *WorldClim*:
    
      + *quadratic* model:
    
        + `glmer`: `r s <- uv__blue$wc$mean$glmer$quadratic; iv <- "UV_mean_wc_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`

        + `brms`: `r s <- uv__blue$wc$mean$brms$quadratic; iv <- "UV_mean_wc_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
      + *purely linear* model:
    
        + `glmer`: `r s <- uv__blue$wc$mean$glmer$linear; iv <- "UV_mean_wc_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`

        + `brms`: `r s <- uv__blue$wc$mean$brms$linear; iv <- "UV_mean_wc_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

  + the **standard deviation** of the UV-B incidence:

    - *TOMS*:
    
      + *quadratic* model:
    
        + `glmer`: `r s <- uv__blue$toms$sd$glmer$quadratic; iv <- "UV_sd_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`

        + `brms`: `r s <- uv__blue$toms$sd$brms$quadratic; iv <- "UV_sd_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
      + *purely linear* model:
    
        + `glmer`: `r s <- uv__blue$toms$sd$glmer$linear; iv <- "UV_sd_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`

        + `brms`: `r s <- uv__blue$toms$sd$brms$linear; iv <- "UV_sd_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

    - *WorldClim*:
    
      + *quadratic* model:
    
        + `glmer`: `r s <- uv__blue$wc$sd$glmer$quadratic; iv <- "UV_sd_wc_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`

        + `brms`: `r s <- uv__blue$wc$sd$brms$quadratic; iv <- "UV_sd_wc_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
      + *purely linear* model:
    
        + `glmer`: `r s <- uv__blue$wc$sd$glmer$linear; iv <- "UV_sd_wc_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`

        + `brms`: `r s <- uv__blue$wc$sd$brms$linear; iv <- "UV_sd_wc_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`


- when using the putative locations of **language families**:

  - `glmer`: `r .print.model.comparison(a=uv__blue$toms_vs_wc$glmer_fam, a.names=c("m_t"="TOMS", "m_w"="WorldClim"))`
  - `brms`: `r .print.model.comparison(b=uv__blue$toms_vs_wc$brms_fam)`
  
  + the **mean** UV-B incidence:
  
    - *TOMS*:
    
      + *quadratic* model:
    
        + `glmer`: `r s <- uv__blue$toms$mean_fam$glmer$quadratic; iv <- "UV_mean_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`

        + `brms`: `r s <- uv__blue$toms$mean_fam$brms$quadratic; iv <- "UV_mean_family_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
      + *purely linear* model:
    
        + `glmer`: `r s <- uv__blue$toms$mean_fam$glmer$linear; iv <- "UV_mean_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`

        + `brms`: `r s <- uv__blue$toms$mean_fam$brms$linear; iv <- "UV_mean_family_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

    - *WorldClim*:
    
      + *quadratic* model:
    
        + `glmer`: `r s <- uv__blue$wc$mean_fam$glmer$quadratic; iv <- "UV_mean_wc_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`

        + `brms`: `r s <- uv__blue$wc$mean_fam$brms$quadratic; iv <- "UV_mean_wc_family_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
      + *purely linear* model:
    
        + `glmer`: `r s <- uv__blue$wc$mean_fam$glmer$linear; iv <- "UV_mean_wc_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`

        + `brms`: `r s <- uv__blue$wc$mean_fam$brms$linear; iv <- "UV_mean_wc_family_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

  + the **standard deviation** of the UV-B incidence:

    - *TOMS*:
    
      + *quadratic* model:
    
        + `glmer`: `r s <- uv__blue$toms$sd_fam$glmer$quadratic; iv <- "UV_sd_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`

        + `brms`: `r s <- uv__blue$toms$sd_fam$brms$quadratic; iv <- "UV_sd_family_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
      + *purely linear* model:
    
        + `glmer`: `r s <- uv__blue$toms$sd_fam$glmer$linear; iv <- "UV_sd_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`

        + `brms`: `r s <- uv__blue$toms$sd_fam$brms$linear; iv <- "UV_sd_family_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

    - *WorldClim*:
    
      + *quadratic* model:
    
        + `glmer`: `r s <- uv__blue$wc$sd_fam$glmer$quadratic; iv <- "UV_sd_wc_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`

        + `brms`: `r s <- uv__blue$wc$sd_fam$brms$quadratic; iv <- "UV_sd_wc_family_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
      + *purely linear* model:
    
        + `glmer`: `r s <- uv__blue$wc$sd_fam$glmer$linear; iv <- "UV_sd_wc_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`

        + `brms`: `r s <- uv__blue$wc$sd_fam$brms$linear; iv <- "UV_sd_wc_family_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`


### Latitude → 'blue'

- latitude of the *languages*: 

  + *quadratic* model:

    + `glmer`: `r s <- lat__blue$toms$langs$glmer$quadratic; iv <- "latitude_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`

    + `brms`: `r s <- lat__blue$toms$langs$brms$quadratic; iv <- "latitude_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`

  + *purely linear* model:

    + `glmer`: `r s <- lat__blue$toms$langs$glmer$linear; iv <- "latitude_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`

    + `brms`: `r s <- lat__blue$toms$langs$brms$linear; iv <- "latitude_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

- latitude of the *language families*:

  + *quadratic* model:

    + `glmer`: `r s <- lat__blue$toms$fams$glmer$quadratic; iv <- "latitude_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`

    + `brms`: `r s <- lat__blue$toms$fams$brms$quadratic; iv <- "latitude_family_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`

  + *purely linear* model:

    + `glmer`: `r s <- lat__blue$toms$fams$glmer$linear; iv <- "latitude_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`

    + `brms`: `r s <- lat__blue$toms$fams$brms$linear; iv <- "latitude_family_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`


### Subsistence → 'blue'

  + *purely linear* model (the only one possible with categorical predictors):

    + `glmer`: `r s <- subsist__blue$toms$langs$glmer$linear; iv <- "subsistenceAGR"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`

    + `brms`: `r s <- subsist__blue$toms$langs$brms$linear; iv <- "subsistenceAGR"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`



### Elevation → 'blue'

- altitude of the *languages*: 

  + *quadratic* model:

    + `glmer`: `r s <- elevation__blue$toms$langs$glmer$quadratic; iv <- "elevation_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`

    + `brms`: `r s <- elevation__blue$toms$langs$brms$quadratic; iv <- "elevation_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`

  + *purely linear* model:

    + `glmer`: `r s <- elevation__blue$toms$langs$glmer$linear; iv <- "elevation_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`

    + `brms`: `r s <- elevation__blue$toms$langs$brms$linear; iv <- "elevation_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

- altitude of the *language families*:

  + *quadratic* model:

    + `glmer`: `r s <- elevation__blue$toms$fams$glmer$quadratic; iv <- "elevation_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`

    + `brms`: `r s <- elevation__blue$toms$fams$brms$quadratic; iv <- "elevation_family_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`

  + *purely linear* model:

    + `glmer`: `r s <- elevation__blue$toms$fams$glmer$linear; iv <- "elevation_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`

    + `brms`: `r s <- elevation__blue$toms$fams$brms$linear; iv <- "elevation_family_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`


### Climate, ecology and humidity → 'blue'

- when using the locations of **actual languages**:

  - *Climate*:

    - *PC1*: 
    
      + *quadratic* model:
      
        + `glmer`: `r s <- clim__blue$toms$climPC1$glmer$quadratic; iv <- "clim_PC1_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
      
        + `brms`: `r s <- clim__blue$toms$climPC1$brms$quadratic; iv <- "clim_PC1_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
      
      + *purely linear* model:
      
        + `glmer`: `r s <- clim__blue$toms$climPC1$glmer$linear; iv <- "clim_PC1_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
      
        + `brms`: `r s <- clim__blue$toms$climPC1$brms$linear; iv <- "clim_PC1_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

    - *PC2*: 
    
      + *quadratic* model:
      
        + `glmer`: `r s <- clim__blue$toms$climPC2$glmer$quadratic; iv <- "clim_PC2_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
      
        + `brms`: `r s <- clim__blue$toms$climPC2$brms$quadratic; iv <- "clim_PC2_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
      
      + *purely linear* model:
      
        + `glmer`: `r s <- clim__blue$toms$climPC2$glmer$linear; iv <- "clim_PC2_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
      
        + `brms`: `r s <- clim__blue$toms$climPC2$brms$linear; iv <- "clim_PC2_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

    - *PC3*: 
    
      + *quadratic* model:
      
        + `glmer`: `r s <- clim__blue$toms$climPC3$glmer$quadratic; iv <- "clim_PC3_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
      
        + `brms`: `r s <- clim__blue$toms$climPC3$brms$quadratic; iv <- "clim_PC3_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
      
      + *purely linear* model:
      
        + `glmer`: `r s <- clim__blue$toms$climPC3$glmer$linear; iv <- "clim_PC3_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
      
        + `brms`: `r s <- clim__blue$toms$climPC3$brms$linear; iv <- "clim_PC3_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`


  - *Humidity*:

    - *median*: 
    
      + *quadratic* model:
      
        + `glmer`: `r s <- clim__blue$toms$hummed$glmer$quadratic; iv <- "hum_median"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
      
        + `brms`: `r s <- clim__blue$toms$hummed$brms$quadratic; iv <- "hum_median"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
      
      + *purely linear* model:
      
        + `glmer`: `r s <- clim__blue$toms$hummed$glmer$linear; iv <- "hum_median"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
      
        + `brms`: `r s <- clim__blue$toms$hummed$brms$linear; iv <- "hum_median"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

    - *variation* (IQR):
    
      + *quadratic* model:
      
        + `glmer`: `r s <- clim__blue$toms$humiqr$glmer$quadratic; iv <- "hum_IQR"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
      
        + `brms`: `r s <- clim__blue$toms$humiqr$brms$quadratic; iv <- "hum_IQR"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
      
      + *purely linear* model:
      
        + `glmer`: `r s <- clim__blue$toms$humiqr$glmer$linear; iv <- "hum_IQR"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
      
        + `brms`: `r s <- clim__blue$toms$humiqr$brms$linear; iv <- "hum_IQR"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

- when using the locations of **language families**:

  - *Climate*:

    - *PC1*: 
    
      + *quadratic* model:
      
        + `glmer`: `r s <- clim__blue$toms$climPC1_fam$glmer$quadratic; iv <- "clim_PC1_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
      
        + `brms`: `r s <- clim__blue$toms$climPC1_fam$brms$quadratic; iv <- "clim_PC1_family_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
      
      + *purely linear* model:
      
        + `glmer`: `r s <- clim__blue$toms$climPC1_fam$glmer$linear; iv <- "clim_PC1_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
      
        + `brms`: `r s <- clim__blue$toms$climPC1_fam$brms$linear; iv <- "clim_PC1_family_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

    - *PC2*: 
    
      + *quadratic* model:
      
        + `glmer`: `r s <- clim__blue$toms$climPC2_fam$glmer$quadratic; iv <- "clim_PC2_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
      
        + `brms`: `r s <- clim__blue$toms$climPC2_fam$brms$quadratic; iv <- "clim_PC2_family_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
      
      + *purely linear* model:
      
        + `glmer`: `r s <- clim__blue$toms$climPC2_fam$glmer$linear; iv <- "clim_PC2_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
      
        + `brms`: `r s <- clim__blue$toms$climPC2_fam$brms$linear; iv <- "clim_PC2_family_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

    - *PC3*: 
    
      + *quadratic* model:
      
        + `glmer`: `r s <- clim__blue$toms$climPC3_fam$glmer$quadratic; iv <- "clim_PC3_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
      
        + `brms`: `r s <- clim__blue$toms$climPC3_fam$brms$quadratic; iv <- "clim_PC3_family_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
      
      + *purely linear* model:
      
        + `glmer`: `r s <- clim__blue$toms$climPC3_fam$glmer$linear; iv <- "clim_PC3_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
      
        + `brms`: `r s <- clim__blue$toms$climPC3_fam$brms$linear; iv <- "clim_PC3_family_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`


  - *Humidity*:

    - *median*: 
    
      + *quadratic* model:
      
        + `glmer`: `r s <- clim__blue$toms$hummed_fam$glmer$quadratic; iv <- "hum_median_family"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
      
        + `brms`: `r s <- clim__blue$toms$hummed_fam$brms$quadratic; iv <- "hum_median_family"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
      
      + *purely linear* model:
      
        + `glmer`: `r s <- clim__blue$toms$hummed_fam$glmer$linear; iv <- "hum_median_family"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
      
        + `brms`: `r s <- clim__blue$toms$hummed_fam$brms$linear; iv <- "hum_median_family"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

    - *variation* (IQR):
    
      + *quadratic* model:
      
        + `glmer`: `r s <- clim__blue$toms$humiqr_fam$glmer$quadratic; iv <- "hum_IQR_family"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
      
        + `brms`: `r s <- clim__blue$toms$humiqr_fam$brms$quadratic; iv <- "hum_IQR_family"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
      
      + *purely linear* model:
      
        + `glmer`: `r s <- clim__blue$toms$humiqr_fam$glmer$linear; iv <- "hum_IQR_family"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
      
        + `brms`: `r s <- clim__blue$toms$humiqr_fam$brms$linear; iv <- "hum_IQR_family"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`


### Distance to water → 'blue'

- when using the locations of **actual languages**:

  - distance to **lakes**:
  
    + *quadratic* model:
    
      + `glmer`: `r s <- water__blue$toms$lakes$glmer$quadratic; iv <- "dist2lakes_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
    
      + `brms`: `r s <- water__blue$toms$lakes$brms$quadratic; iv <- "dist2lakes_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
    + *purely linear* model:
    
      + `glmer`: `r s <- water__blue$toms$lakes$glmer$linear; iv <- "dist2lakes_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
    
      + `brms`: `r s <- water__blue$toms$lakes$brms$linear; iv <- "dist2lakes_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

  - the distance to **rivers**:

    + *quadratic* model:
    
      + `glmer`: `r s <- water__blue$toms$rivers$glmer$quadratic; iv <- "dist2rivers_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
    
      + `brms`: `r s <- water__blue$toms$rivers$brms$quadratic; iv <- "dist2rivers_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
    + *purely linear* model:
    
      + `glmer`: `r s <- water__blue$toms$rivers$glmer$linear; iv <- "dist2rivers_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
    
      + `brms`: `r s <- water__blue$toms$rivers$brms$linear; iv <- "dist2rivers_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

  - the distance to **oceans**:

    + *quadratic* model:
    
      + `glmer`: `r s <- water__blue$toms$oceans$glmer$quadratic; iv <- "dist2ocean_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
    
      + `brms`: `r s <- water__blue$toms$oceans$brms$quadratic; iv <- "dist2ocean_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
    + *purely linear* model:
    
      + `glmer`: `r s <- water__blue$toms$oceans$glmer$linear; iv <- "dist2ocean_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
    
      + `brms`: `r s <- water__blue$toms$oceans$brms$linear; iv <- "dist2ocean_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

  - the distance to **water** in general:

    + *quadratic* model:
    
      + `glmer`: `r s <- water__blue$toms$water$glmer$quadratic; iv <- "dist2water_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
    
      + `brms`: `r s <- water__blue$toms$water$brms$quadratic; iv <- "dist2water_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
    + *purely linear* model:
    
      + `glmer`: `r s <- water__blue$toms$water$glmer$linear; iv <- "dist2water_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
    
      + `brms`: `r s <- water__blue$toms$water$brms$linear; iv <- "dist2water_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`


- when using the locations of **language families**:

  - distance to **lakes**:
  
    + *quadratic* model:
    
      + `glmer`: `r s <- water__blue$toms$lakes_fam$glmer$quadratic; iv <- "dist2lakes_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
    
      + `brms`: `r s <- water__blue$toms$lakes_fam$brms$quadratic; iv <- "dist2lakes_family_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
    + *purely linear* model:
    
      + `glmer`: `r s <- water__blue$toms$lakes_fam$glmer$linear; iv <- "dist2lakes_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
    
      + `brms`: `r s <- water__blue$toms$lakes_fam$brms$linear; iv <- "dist2lakes_family_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

  - the distance to **rivers**:

    + *quadratic* model:
    
      + `glmer`: `r s <- water__blue$toms$rivers_fam$glmer$quadratic; iv <- "dist2rivers_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
    
      + `brms`: `r s <- water__blue$toms$rivers_fam$brms$quadratic; iv <- "dist2rivers_family_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
    + *purely linear* model:
    
      + `glmer`: `r s <- water__blue$toms$rivers_fam$glmer$linear; iv <- "dist2rivers_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
    
      + `brms`: `r s <- water__blue$toms$rivers_fam$brms$linear; iv <- "dist2rivers_family_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

  - the distance to **oceans**:

    + *quadratic* model:
    
      + `glmer`: `r s <- water__blue$toms$oceans_fam$glmer$quadratic; iv <- "dist2ocean_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
    
      + `brms`: `r s <- water__blue$toms$oceans_fam$brms$quadratic; iv <- "dist2ocean_family_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
    + *purely linear* model:
    
      + `glmer`: `r s <- water__blue$toms$oceans_fam$glmer$linear; iv <- "dist2ocean_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
    
      + `brms`: `r s <- water__blue$toms$oceans_fam$brms$linear; iv <- "dist2ocean_family_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

  - the distance to **water** in general:

    + *quadratic* model:
    
      + `glmer`: `r s <- water__blue$toms$water_fam$glmer$quadratic; iv <- "dist2water_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
    
      + `brms`: `r s <- water__blue$toms$water_fam$brms$quadratic; iv <- "dist2water_family_r"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
    
    + *purely linear* model:
    
      + `glmer`: `r s <- water__blue$toms$water_fam$glmer$linear; iv <- "dist2water_family_r"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
    
      + `brms`: `r s <- water__blue$toms$water_fam$brms$linear; iv <- "dist2water_family_r"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`


### (log) population size → 'blue'

- from **Ethnologue**:

  + *quadratic* model:
  
    + `glmer`: `r s <- popsize__blue$toms$ethno$glmer$quadratic; iv <- "log_popSize_ethno"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
  
    + `brms`: `r s <- popsize__blue$toms$ethno$brms$quadratic; iv <- "log_popSize_ethno"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
  
  + *purely linear* model:
  
    + `glmer`: `r s <- popsize__blue$toms$ethno$glmer$linear; iv <- "log_popSize_ethno"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
  
    + `brms`: `r s <- popsize__blue$toms$ethno$brms$linear; iv <- "log_popSize_ethno"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`

- from **Wikipedia**:

  + *quadratic* model:
  
    + `glmer`: `r s <- popsize__blue$toms$wiki$lmer$quadratic; iv <- "log_popSize_wiki"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*linear term*: *&beta;*~1~ = %.2f ± %.2f, *p* = %s; *quadratic term*: *&beta;*~2~ = %.2f ± %.2f, *p* = %s, *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), s$coefs[iv2, "Estimate"], s$coefs[iv2, "Std. Error"], scinot(s$coefs[iv2, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m12"="quadratic")), .print.model.comparison(a=s$anova_vs_linear, a.names=c("m1"="linear", "m12"="quadratic")))`
  
    + `brms`: `r s <- popsize__blue$toms$wiki$brms$quadratic; iv <- "log_popSize_wiki"; sprintf("*linear term*: *&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *quadratic term*: *&beta;*~2~ = %.2f, [%.2f, %.2f], *p*(*&beta;*~2~=0) = %.3g; *model comparison vs null*: %s; *model comparison vs linear*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_I",iv,"E2") ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(I",iv,"E2) = 0")], .print.model.comparison(b=s$cmp_vs_0), .print.model.comparison(b=s$cmp_vs_linear))`
  
  + *purely linear* model:
  
    + `glmer`: `r s <- popsize__blue$toms$wiki$glmer$linear; iv <- "log_popSize_wiki"; iv2 <- paste0("I(",iv,"^2)"); sprintf("*&beta;*~1~ = %.2f ± %.2f, *p* = %s; *R*^2^~marginal~ = %.1f%%; *model comparison vs null*: %s", s$coefs[iv, "Estimate"], s$coefs[iv, "Std. Error"], scinot(s$coefs[iv, "Pr(>|z|)"]), 100*s$R2$R2_marginal, .print.model.comparison(a=s$anova_vs_0, a.names=c("m0"="null", "m1"="linear")))`
  
    + `brms`: `r s <- popsize__blue$toms$wiki$brms$linear; iv <- "log_popSize_wiki"; sprintf("*&beta;*~1~ = %.2f, 95%% HDI [%.2f, %.2f], *p*(*&beta;*~1~=0) = %.3g, *p*(*&beta;*~1~<0) = %.3g, *p*(*&beta;*~1~>0) = %.3g; *model comparison vs null*: %s", s$hyps$hypothesis$Estimate[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$HDI$CI_low[ s$HDI$Parameter == paste0("b_",iv) ], s$HDI$CI_high[ s$HDI$Parameter == paste0("b_",iv) ], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") = 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") < 0")], s$hyps$hypothesis$Post.Prob[s$hyps$hypothesis$Hypothesis == paste0("(",iv,") > 0")], .print.model.comparison(b=s$cmp_vs_0))`


## Appendix II. Path analysis for 'blue'

The full output of the "full" model, with all the fit indices, is:

```{r}
summary(sem_blue$full$UV_both);
fitMeasures(sem_blue$full$UV_both);
```

The full output of the "relaxed" model (which includes only the assumed causal arrows), with all the fit indices, is:


```{r}
summary(sem_blue$strict$UV_both);
fitMeasures(sem_blue$strict$UV_both);
```


## Appendix III: finer-grade control for contact and history when regresing *blue*

### 2D Gaussian Process as a model of contact

Here we model language contact with a *2D Gaussian Process* as suggested in, for example, @mcelreath_statistical_2020, using `brms`'s `gp()`.
We model language *family* as random effect, and a we use 2D Gaussian process separately for each *macroarea* (as opposed to considering *macroarea* as a crossed random effect, as we do in the main analysis).
However, this is very computationally expensive!

```{r include=FALSE}
file_name <- "./cached_results/2dgp_reg.RData";
if( !file.exists(file_name) )
{
  ### collect results:
  b_2dgp_reg <- list();

  # mean(UV-B):
  b_2dgp_m_full <- brm(exists_blue ~ 1 + UV_mean_r + subsistence + log_popSize_ethno + clim_PC1_r + clim_PC2_r + clim_PC3_r + hum_median + hum_IQR + dist2water_r + dist2ocean_r + dist2lakes_r + dist2rivers_r + # the relevant predictors
                         (1 | glottocode_family) + # family as random effect
                         gp(longitude, latitude, by=macroarea, gr=TRUE), # one 2D Gaussian process per macroarea
                       family=bernoulli(link="logit"), data=d_colors_ag, 
                       prior=c(prior(student_t(3, 0, 2.5), class="Intercept"),
                               prior(student_t(3, 0, 2.5), class="b"), # pretty wide priors centered on 0
                               prior(normal(0, 0.1), class="sd"), 
                               prior(normal(0, 1), class="sdgp")), # Gaussian Process priors
                       sample_prior=TRUE,  # needed for hypotheses tests
                       cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9999, max_treedepth=15));
  summary(b_2dgp_m_full); mcmc_plot(b_2dgp_m_full, type="trace"); mcmc_plot(b_2dgp_m_full);
  hdi(b_2dgp_m_full, ci=0.95);
  brms::hypothesis(b_2dgp_m_full, c("UV_mean_r = 0", "UV_mean_r < 0", 
                                    "subsistenceAGR = 0", "subsistenceAGR > 0", 
                                    "log_popSize_ethno = 0", "log_popSize_ethno > 0", 
                                    "clim_PC1_r = 0", "clim_PC2_r = 0", "clim_PC3_r = 0", "hum_median = 0", "hum_IQR = 0", 
                                    "dist2water_r = 0", "dist2ocean_r = 0", "dist2lakes_r = 0", "dist2rivers_r = 0"));
  # save(b_2dgp_m_full, file="~/Temp/b_2dgp_m_full.RData", compress="xz", compression_level=9); # takes a long time to do it and we manually simplify from it, so make a safe copy in case all crashes so we can continue...
  
  # manual simplification:
  b_2dgp_red <- update(b_2dgp_m_full, . ~ . - hum_IQR - hum_median - clim_PC3_r - clim_PC2_r - dist2ocean_r - dist2rivers_r - clim_PC1_r - dist2water_r - dist2lakes_r, 
                       cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9999, max_treedepth=15));
  summary(b_2dgp_red); mcmc_plot(b_2dgp_red, type="trace"); mcmc_plot(b_2dgp_red);
  (hdi_2dgp_red <- hdi(b_2dgp_red, ci=0.95));
  (h_2dgp_red <- brms::hypothesis(b_2dgp_red, c("UV_mean_r = 0", "UV_mean_r < 0", "subsistenceAGR = 0", "subsistenceAGR > 0", "log_popSize_ethno = 0", "log_popSize_ethno > 0")));
  # save(h_2dgp_red, file="~/Temp/h_2dgp_red.RData", compress="xz", compression_level=9);
  
  ## this is extremely slow and actually of doubtful relevance here...
  ## null model:
  #b_2dgp_0 <- update(b_2dgp_m_full, . ~ . - hum_IQR - hum_median - dist2ocean_r - dist2rivers_r - clim_PC1_r - clim_PC2_r - clim_PC3_r - dist2water_r - UV_mean_r - subsistence - log_popSize_ethno - dist2lakes_r, 
  #                   cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9999, max_treedepth=15));
  #b_2dgp_red <- brms_fit_indices(b_2dgp_red);
  #b_2dgp_0 <- brms_fit_indices(b_2dgp_0);
  #cmp_null_red <- brms_compare_models(b_2dgp_0, b_2dgp_red, "null", "reduced"); # they seem equivalent
  
  # Save the results:
  b_2dgp_reg <- list("hdi"=hdi_2dgp_red, "hyps"=h_2dgp_red);
  save(b_2dgp_reg, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

We started with a full model (we only consider here mean(UV-B) incidence as given by TOMS) and did manual simplification based on the posterior distribution (is 0 in the 95%HDI?) and Bayesian hypothesis testing (against 0); the retain predictors are:

```{r}
df <- data.frame("iv"=c("mean(UV-B)", 
                        "subsistence",
                        "(log) population size"),
                 "beta"=c(sprintf("%.2f [%.2f, %.2f]", 
                                  b_2dgp_reg$hyps$hypothesis$Estimate[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) = 0" ], 
                                  b_2dgp_reg$hdi$CI_low[ b_2dgp_reg$hdi$Parameter == "b_UV_mean_r" ], b_2dgp_reg$hdi$CI_high[ b_2dgp_reg$hdi$Parameter == "b_UV_mean_r" ]),
                          sprintf("%.2f [%.2f, %.2f]", 
                                  b_2dgp_reg$hyps$hypothesis$Estimate[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(subsistenceAGR) = 0" ], 
                                  b_2dgp_reg$hdi$CI_low[ b_2dgp_reg$hdi$Parameter == "b_subsistenceAGR" ], b_2dgp_reg$hdi$CI_high[ b_2dgp_reg$hdi$Parameter == "b_subsistenceAGR" ]),
                          sprintf("%.2f [%.2f, %.2f]", 
                                  b_2dgp_reg$hyps$hypothesis$Estimate[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(log_popSize_ethno) = 0" ], 
                                  b_2dgp_reg$hdi$CI_low[ b_2dgp_reg$hdi$Parameter == "b_log_popSize_ethno" ], b_2dgp_reg$hdi$CI_high[ b_2dgp_reg$hdi$Parameter == "b_log_popSize_ethno" ])),
                 "p.0"=c(sprintf("%.2f%s", b_2dgp_reg$hyps$hypothesis$Post.Prob[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) = 0" ], b_2dgp_reg$hyps$hypothesis$Star[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) = 0" ]),
                         sprintf("%.2f%s", b_2dgp_reg$hyps$hypothesis$Post.Prob[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(subsistenceAGR) = 0" ], b_2dgp_reg$hyps$hypothesis$Star[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(subsistenceAGR) = 0" ]),
                         sprintf("%.2f%s", b_2dgp_reg$hyps$hypothesis$Post.Prob[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(log_popSize_ethno) = 0" ], b_2dgp_reg$hyps$hypothesis$Star[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(log_popSize_ethno) = 0" ])),
                 "h.dir"=c("negative (-)", 
                           "positive (+) of agriculture",
                           "positive (+)"),
                 "p.dir"=c(sprintf("%.2f%s", b_2dgp_reg$hyps$hypothesis$Post.Prob[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) < 0" ], b_2dgp_reg$hyps$hypothesis$Star[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) < 0" ]),
                           sprintf("%.2f%s", b_2dgp_reg$hyps$hypothesis$Post.Prob[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(subsistenceAGR) > 0" ], b_2dgp_reg$hyps$hypothesis$Star[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(subsistenceAGR) > 0" ]),
                           sprintf("%.2f%s", b_2dgp_reg$hyps$hypothesis$Post.Prob[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(log_popSize_ethno) > 0" ], b_2dgp_reg$hyps$hypothesis$Star[ b_2dgp_reg$hyps$hypothesis$Hypothesis == "(log_popSize_ethno) > 0" ])));
kable(df, row.names=FALSE, col.names=c("Predictor", "&beta;", "p(&beta; = 0)", "Direction of effect", "p(directional effect)"), align="r",
      caption=capTab("Results for the manually simplified model regressing 'blue' on all the relevant predictors using a 2D Gaussian Processes to model language contact, showing the estimate of the regression coefficient *&beta;* and its 95% HDI, as well as the posterior probability of the point hypothesis that *&beta;* == 0, and of the appropriate directional hypothesis *&beta;* < 0 or *&beta;* > 0. Please note that we only did this for mean(UV-B) due to its computational costs."));
```

It can be seen that most effects are found and in the expected direction; in particular, the negative effect of mean(UV-B) is really strong.

<!---
### Mediation

Due to the computational costs, we only test the most important mediation models here.


#### Latitude → UV-B → 'blue'

```{r include=FALSE, eval=FALSE}
file_name <- "./cached_results/2dgp_med_lat_uvb__blue.RData";
if( !all(file.exists(file_name)) )
{
  # Store the results:
  bmed_2dgp_lat_uvb__blue <- list();
  
  # Fit the mediation model:
  bmed_2dgp_lat_uvb__blue <- .fit_mediation_model(d=d_colors_ag, 
                                                  outcome="exists_blue", outcome_name="blue", 
                                                  treatment="latitude_r", treatment_name="latitude", 
                                                  mediator="UV_mean_r", mediator_name="mean(UV-B)", 
                                                  family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + gp(longitude, latitude, by=macroarea, gr=TRUE)",
                                                  cores=brms_ncores, iter=6000, warmup=2000, thin=2, control=med_control,
                                                  save_model=FALSE, show_results=TRUE);
  
  # Save results:
  save(bmed_lat_uvb__blue, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_uvb__blue$toms$mean)}
if( !is.null(m) ) .plot_mediation(m);
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_uvb__blue$toms$sd)}
if( !is.null(m) ) .plot_mediation(m);
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_uvb__blue$wc$mean)}
if( !is.null(m) ) .plot_mediation(m);
```

```{r fig.cap=capFig('Mediation analysis showing the total, direct and indirect effects, as well as the actual regression coefficients. Please note that because the outcome is binary, the direct and indirect effects may be on different scales.', TRUE, c("DiagrammeR"), is_map=FALSE), fig.width=15, fig.height=5, include=!is.null(m <- bmed_lat_uvb__blue$wc$sd)}
if( !is.null(m) ) .plot_mediation(m);
```
-->


### The "global" tree in @jagerGlobalscalePhylogeneticLinguistic2018 to control for history

Here we look in more detail at the relationship between predictors and 'blue' when using the @jagerGlobalscalePhylogeneticLinguistic2018 "global" tree.

```{r include=FALSE}
file_name <- "./cached_results/worldtree_reg.RData";
if( !file.exists(file_name) )
{
  ### collect results:
  b_wt_reg <- list();
  
  # Select and align the data to the tree:
  tree <- trees$world$gerhard;
  d <- unique(d_colors_ag[ !is.na(d_colors_ag$exists_blue) & 
                             !is.na(d_colors_ag$UV_mean_r) & !is.na(d_colors_ag$subsistence) & !is.na(d_colors_ag$log_popSize_ethno) & !is.na(d_colors_ag$clim_PC1_r) & !is.na(d_colors_ag$clim_PC2_r) & !is.na(d_colors_ag$clim_PC3_r) & 
                             !is.na(d_colors_ag$hum_median) & !is.na(d_colors_ag$hum_IQR) & !is.na(d_colors_ag$dist2water_r) & !is.na(d_colors_ag$dist2ocean_r) & !is.na(d_colors_ag$dist2lakes_r) & !is.na(d_colors_ag$dist2rivers_r) & 
                             (d_colors_ag$glottocode %in% tree$tip.label), 
                           c("glottocode", "macroarea", "exists_blue", "UV_mean_r", "subsistence", "log_popSize_ethno", "clim_PC1_r", "clim_PC2_r", "clim_PC3_r", "hum_median", "hum_IQR", "dist2water_r", "dist2ocean_r", "dist2lakes_r", "dist2rivers_r") ]);
  d <- d[ !duplicated(d$glottocode), ]; # keep the first of potentially duplicated rows
  d$exists_blue_num <- as.numeric(d$exists_blue == "yes"); 
  d <- as.data.frame(d);
  rownames(d) <- d$glottocode;
  d <- d[intersect(d$glottocode, tree$tip.label), ];
  tree <- drop.tip(tree, setdiff(tree$tip.label, d$glottocode), trim.internal=TRUE);
  d <- d[tree$tip.label,]; # make sure the tree and the data are identically ordered
  
  # Phylogeentic variance-covariance matrix:
  A <- ape::vcv.phylo(tree);
  
  # mean(UV-B):
  b_wt_m_full <- brm(exists_blue ~ 1 + UV_mean_r  + subsistence  + log_popSize_ethno + clim_PC1_r + clim_PC2_r + clim_PC3_r + hum_median + hum_IQR + dist2water_r + dist2ocean_r + dist2lakes_r + dist2rivers_r + # the relevant predictors
                       (1 | gr(glottocode, cov=A)) + # the "world" tree
                       (1 | macroarea), # macroarea as random effect
                     family=bernoulli(link="logit"), 
                     data=d, data2=list(A=A),
                     prior=c(prior(student_t(3, 0, 2.5), class="Intercept"),
                             prior(student_t(3, 0, 2.5), class="b"), # pretty wide priors centered on 0
                             prior(student_t(3, 0, 20),  class="sd")),
                     sample_prior=TRUE,  # needed for hypotheses tests
                     cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9999, max_treedepth=15));
  summary(b_wt_m_full); mcmc_plot(b_wt_m_full, type="trace"); mcmc_plot(b_wt_m_full, 
                                                                        variable=c("b_UV_mean_r", "b_subsistenceAGR", "b_log_popSize_ethno", 
                                                                                   "b_clim_PC1_r", "b_clim_PC2_r", "b_clim_PC3_r", "b_hum_median", "b_hum_IQR", 
                                                                                   "b_dist2water_r", "b_dist2ocean_r", "b_dist2lakes_r", "b_dist2rivers_r"));
  hdi(b_wt_m_full, ci=0.95);
  brms::hypothesis(b_wt_m_full, c("UV_mean_r = 0", "UV_mean_r < 0", 
                                  "subsistenceAGR = 0", "subsistenceAGR > 0", 
                                  "log_popSize_ethno = 0", "log_popSize_ethno > 0", 
                                  "clim_PC1_r = 0", "clim_PC2_r = 0", "clim_PC3_r = 0", "hum_median = 0", "hum_IQR = 0", 
                                  "dist2water_r = 0", "dist2ocean_r = 0", "dist2lakes_r = 0", "dist2rivers_r = 0"));
  # save(b_wt_m_full, file="~/Temp/b_wt_m_full.RData", compress="xz", compression_level=9); # takes a long time to do it and we manually simplify from it, so make a safe copy in case all crashes so we can continue...
  
  # manual simplification:
  b_wt_m_red <- update(b_wt_m_full, . ~ . - hum_IQR - hum_median - clim_PC1_r - clim_PC3_r - dist2ocean_r - dist2rivers_r - dist2water_r - clim_PC2_r - subsistence - dist2lakes_r - log_popSize_ethno, 
                       cores=brms_ncores, iter=6000, warmup=2000, thin=2, control=list(adapt_delta=0.9999, max_treedepth=15));
  summary(b_wt_m_red); mcmc_plot(b_wt_m_red, type="trace"); mcmc_plot(b_wt_m_red, variable=c("b_UV_mean_r"));
  (hdi_wt_m_red <- hdi(b_wt_m_red, ci=0.95));
  (h_wt_m_red <- brms::hypothesis(b_wt_m_red, c("UV_mean_r = 0", "UV_mean_r < 0")));

  # Save the results:
  b_wt_reg <- list("hdi"=hdi_wt_m_red, "hyps"=h_wt_m_red);
  save(b_wt_reg, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

We started with a full model (we only consider here mean(UV-B) incidence as given by TOMS) and did manual simplification based on the posterior distribution (is 0 in the 95%HDI?) and Bayesian hypothesis testing (against 0); the retained predictor is mean(UV-B):

```{r}
df <- data.frame("iv"=c("mean(UV-B)"),
                 "beta"=c(sprintf("%.2f [%.2f, %.2f]", 
                                  b_wt_reg$hyps$hypothesis$Estimate[ b_wt_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) = 0" ], 
                                  b_wt_reg$hdi$CI_low[ b_wt_reg$hdi$Parameter == "b_UV_mean_r" ], b_wt_reg$hdi$CI_high[ b_wt_reg$hdi$Parameter == "b_UV_mean_r" ])),
                 "p.0"=c(sprintf("%.2f%s", b_wt_reg$hyps$hypothesis$Post.Prob[ b_wt_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) = 0" ], b_wt_reg$hyps$hypothesis$Star[ b_wt_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) = 0" ])),
                 "h.dir"=c("negative (-)"),
                 "p.dir"=c(sprintf("%.2f%s", b_wt_reg$hyps$hypothesis$Post.Prob[ b_wt_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) < 0" ], b_wt_reg$hyps$hypothesis$Star[ b_wt_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) < 0" ])));
kable(df, row.names=FALSE, col.names=c("Predictor", "&beta;", "p(&beta; = 0)", "Direction of effect", "p(directional effect)"), align="r",
      caption=capTab("Results for the manually simplified model regressing 'blue' on all the relevant predictors using a 2D Gaussian Processes to model language contact, showing the estimate of the regression coefficient *&beta;* and its 95% HDI, as well as the posterior probability of the point hypothesis that *&beta;* == 0, and of the appropriate directional hypothesis *&beta;* < 0 or *&beta;* > 0. Please note that we only did this for mean(UV-B) due to its computational costs."));
```


### The "global" tree in @jagerGlobalscalePhylogeneticLinguistic2018 with a 2D Gaussian Processes

Here we combine the 2D Gaussian process and the "global" tree in @jagerGlobalscalePhylogeneticLinguistic2018:

```{r include=FALSE}
file_name <- "./cached_results/2dgp_wt_reg.RData";
if( !file.exists(file_name) )
{
  ### collect results:
  b_2dgp_wt_reg <- list();
  
  # Select and align the data to the tree:
  tree <- trees$world$gerhard;
  d <- unique(d_colors_ag[ !is.na(d_colors_ag$exists_blue) & 
                             !is.na(d_colors_ag$UV_mean_r) & !is.na(d_colors_ag$subsistence) & !is.na(d_colors_ag$log_popSize_ethno) & !is.na(d_colors_ag$clim_PC1_r) & !is.na(d_colors_ag$clim_PC2_r) & !is.na(d_colors_ag$clim_PC3_r) & 
                             !is.na(d_colors_ag$hum_median) & !is.na(d_colors_ag$hum_IQR) & !is.na(d_colors_ag$dist2water_r) & !is.na(d_colors_ag$dist2ocean_r) & !is.na(d_colors_ag$dist2lakes_r) & !is.na(d_colors_ag$dist2rivers_r) & 
                             (d_colors_ag$glottocode %in% tree$tip.label), 
                           c("glottocode", "macroarea", "exists_blue", "UV_mean_r", 
                             "subsistence", "log_popSize_ethno", "clim_PC1_r", "clim_PC2_r", "clim_PC3_r", "hum_median", "hum_IQR", 
                             "dist2water_r", "dist2ocean_r", "dist2lakes_r", "dist2rivers_r", 
                             "latitude", "longitude") ]);
  d <- d[ !duplicated(d$glottocode), ]; # keep the first of potentially duplicated rows
  d$exists_blue_num <- as.numeric(d$exists_blue == "yes"); 
  d <- as.data.frame(d);
  rownames(d) <- d$glottocode;
  d <- d[intersect(d$glottocode, tree$tip.label), ];
  tree <- drop.tip(tree, setdiff(tree$tip.label, d$glottocode), trim.internal=TRUE);
  d <- d[tree$tip.label,]; # make sure the tree and the data are identically ordered
  
  # Phylogeentic variance-covariance matrix:
  A <- ape::vcv.phylo(tree);
  
  # mean(UV-B):
  b_2dgp_wt_m_full <- brm(exists_blue ~ 1 + UV_mean_r + subsistence  + log_popSize_ethno + clim_PC1_r + clim_PC2_r + clim_PC3_r + hum_median + hum_IQR + dist2water_r + dist2ocean_r + dist2lakes_r + dist2rivers_r + # the relevant predictors
                            (1 | gr(glottocode, cov=A)) + # the "world" tree
                            gp(longitude, latitude, by=macroarea, gr=TRUE), # one 2D Gaussian process per macroarea
                          family=bernoulli(link="logit"), 
                          data=d, data2=list(A=A),
                          prior=c(prior(student_t(3, 0, 2.5), class="Intercept"),
                                  prior(student_t(3, 0, 2.5), class="b"), # pretty wide priors centered on 0
                                  prior(student_t(3, 0, 20),  class="sd"), 
                                  prior(normal(0, 1), class="sdgp")),
                          sample_prior=TRUE,  # needed for hypotheses tests
                          cores=brms_ncores, iter=10000, warmup=4000, thin=4, control=list(adapt_delta=0.9999, max_treedepth=15));
  summary(b_2dgp_wt_m_full); mcmc_plot(b_2dgp_wt_m_full, type="trace"); mcmc_plot(b_2dgp_wt_m_full, 
                                                                                  variable=c("b_UV_mean_r", "b_subsistenceAGR", "b_log_popSize_ethno", 
                                                                                             "b_clim_PC1_r", "b_clim_PC2_r", "b_clim_PC3_r", "b_hum_median", "b_hum_IQR", 
                                                                                             "b_dist2water_r", "b_dist2ocean_r", "b_dist2lakes_r", "b_dist2rivers_r"));
  (hdi_wt_m_full <- hdi(b_2dgp_wt_m_full, ci=0.95));
  (h_wt_m_full <- brms::hypothesis(b_2dgp_wt_m_full, c("UV_mean_r = 0", "UV_mean_r < 0", 
                                                       "subsistenceAGR = 0", "subsistenceAGR > 0", 
                                                       "log_popSize_ethno = 0", "log_popSize_ethno > 0", 
                                                       "clim_PC1_r = 0", "clim_PC2_r = 0", "clim_PC3_r = 0", "hum_median = 0", "hum_IQR = 0", 
                                                       "dist2water_r = 0", "dist2ocean_r = 0", "dist2lakes_r = 0", "dist2rivers_r = 0")));
  # save(b_2dgp_wt_m_full, file="~/Temp/b_2dgp_wt_m_full.RData", compress="xz", compression_level=9); # takes a long time to do it and we manually simplify from it, so make a safe copy in case all crashes so we can continue...
  
  # manual simplification:
  b_2dgp_wt_m_red <- update(b_2dgp_wt_m_full, . ~ . - clim_PC1_r - clim_PC3_r - hum_median - hum_IQR - dist2ocean_r - dist2rivers_r - log_popSize_ethno - dist2water_r - dist2lakes_r - subsistence - clim_PC2_r, 
                            cores=brms_ncores, iter=10000, warmup=4000, thin=4, control=list(adapt_delta=0.9999, max_treedepth=15));
  summary(b_2dgp_wt_m_red); mcmc_plot(b_2dgp_wt_m_red, type="trace"); mcmc_plot(b_2dgp_wt_m_red, variable=c("b_UV_mean_r"));
  (hdi_wt_m_red <- hdi(b_2dgp_wt_m_red, ci=0.95));
  (h_wt_m_red <- brms::hypothesis(b_2dgp_wt_m_red, c("UV_mean_r = 0", "UV_mean_r < 0")));
  
  
  # Save the results:
  b_2dgp_wt_reg <- list("hdi"=hdi_wt_m_red, "hyps"=h_wt_m_red);
  save(b_2dgp_wt_reg, file=file_name, compress="xz", compression_level=9);
} else
{
  load(file_name);
}
```

We started with a full model (we only consider here mean(UV-B) incidence as given by TOMS) and did manual simplification based on the posterior distribution (is 0 in the 95%HDI?) and Bayesian hypothesis testing (against 0); the retained predictor is mean(UV-B):

```{r}
df <- data.frame("iv"=c("mean(UV-B)"),
                 "beta"=c(sprintf("%.2f [%.2f, %.2f]", 
                                  b_2dgp_wt_reg$hyps$hypothesis$Estimate[ b_2dgp_wt_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) = 0" ], 
                                  b_2dgp_wt_reg$hdi$CI_low[ b_2dgp_wt_reg$hdi$Parameter == "b_UV_mean_r" ], b_2dgp_wt_reg$hdi$CI_high[ b_2dgp_wt_reg$hdi$Parameter == "b_UV_mean_r" ])),
                 "p.0"=c(sprintf("%.2f%s", b_2dgp_wt_reg$hyps$hypothesis$Post.Prob[ b_2dgp_wt_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) = 0" ], b_2dgp_wt_reg$hyps$hypothesis$Star[ b_2dgp_wt_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) = 0" ])),
                 "h.dir"=c("negative (-)"),
                 "p.dir"=c(sprintf("%.2f%s", b_2dgp_wt_reg$hyps$hypothesis$Post.Prob[ b_2dgp_wt_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) < 0" ], b_2dgp_wt_reg$hyps$hypothesis$Star[ b_2dgp_wt_reg$hyps$hypothesis$Hypothesis == "(UV_mean_r) < 0" ])));
kable(df, row.names=FALSE, col.names=c("Predictor", "&beta;", "p(&beta; = 0)", "Direction of effect", "p(directional effect)"), align="r",
      caption=capTab("Results for the manually simplified model regressing 'blue' on all the relevant predictors using a 2D Gaussian Processes to model language contact, showing the estimate of the regression coefficient *&beta;* and its 95% HDI, as well as the posterior probability of the point hypothesis that *&beta;* == 0, and of the appropriate directional hypothesis *&beta;* < 0 or *&beta;* > 0. Please note that we only did this for mean(UV-B) due to its computational costs."));
```




# Session information

```{r warning=FALSE, results='asis'}
if( require(benchmarkme) )
{
  # CPU:
  cpu_info <- benchmarkme::get_cpu();
  if( is.null(cpu_info) || is.na(cpu_info) )
  {
    cat("**CPU:** unknown.\n\n");
  } else
  {
    if( !is.null(cpu_info$model_name) && !is.na(cpu_info$model_name) )
    {
      cat(paste0("**CPU:** ",cpu_info$model_name));
      if( !is.null(cpu_info$no_of_cores) && !is.na(cpu_info$no_of_cores) )
      {
        cat(paste0(" (",cpu_info$no_of_cores," threads)"));
      }
      cat("\n\n");
    } else
    {
      cat("**CPU:** unknown.\n\n");
    }
  }
  
  # RAM:
  ram_info <- benchmarkme::get_ram();
  if( is.null(ram_info) || is.na(ram_info) )
  {
    cat("**RAM (memory):** unknown.\n\n");
  } else
  {
    cat("**RAM (memory):** "); print(ram_info); cat("\n");
  }
} else
{
  cat("**RAM (memory):** cannot get info (try installing package 'benchmarkme').\n\n");
}
```

```{r}
pander::pander(sessionInfo());
```



# References




